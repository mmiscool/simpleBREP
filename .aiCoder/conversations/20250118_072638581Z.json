{
  "messages": [
    {
      "role": "system",
      "content": "./.aiCoder/prompts/default-system-prompt.md",
      "filePath": "./.aiCoder/prompts/default-system-prompt.md",
      "description": "",
      "hidden": true
    },
    {
      "role": "user",
      "content": "./.aiCoder/prompts/default-plan-prompt.md",
      "filePath": "./.aiCoder/prompts/default-plan-prompt.md",
      "description": "",
      "hidden": true
    },
    {
      "role": "user",
      "content": "./brep.js",
      "filePath": "./brep.js",
      "description": "// Code file to be edited",
      "hidden": true
    },
    {
      "role": "system",
      "content": "./.aiCoder/prompts/snippet-production-prompt.md",
      "filePath": "./.aiCoder/prompts/snippet-production-prompt.md",
      "description": "",
      "hidden": true
    },
    {
      "role": "user",
      "content": "Add a new testing class. This class will be used to test the variouse classes in this library.\n\nMake another class called tests. This will have methods. Each method in this class will be an individual test. The test will return true if passed and will return an error message if it fails. \n\nThe testing class will itterate over each method in the test class using a try catch in a loop to run each test. Build the testing class and the first 2 tests that are needed to test the Point3D class.",
      "hidden": false
    },
    {
      "role": "assistant",
      "content": "```javascript\nexport class Point3D {\n    constructor(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    getX() {\n        return this.x;\n    }\n    getY() {\n        return this.y;\n    }\n    getZ() {\n        return this.z;\n    }\n    setX(x) {\n        this.x = x;\n    }\n    setY(y) {\n        this.y = y;\n    }\n    setZ(z) {\n        this.z = z;\n    }\n    toArray() {\n        return [\n            this.x,\n            this.y,\n            this.z\n        ];\n    }\n    distanceTo(otherPoint) {\n        const dx = this.x - otherPoint.x;\n        const dy = this.y - otherPoint.y;\n        const dz = this.z - otherPoint.z;\n        return Math.sqrt(dx * dx + dy * dy + dz * dz);\n    }\n    translate(vector) {\n        return new Point3D(this.x + vector.getX(), this.y + vector.getY(), this.z + vector.getZ());\n    }\n    add(vector) {\n        return new Point3D(this.x + vector.getX(), this.y + vector.getY(), this.z + vector.getZ());\n    }\n    sub(vector) {\n        return new Point3D(this.x - vector.getX(), this.y - vector.getY(), this.z - vector.getZ());\n    }\n}\nexport class Vector3D {\n    constructor(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    getX() {\n        return this.x;\n    }\n    getY() {\n        return this.y;\n    }\n    getZ() {\n        return this.z;\n    }\n    setX(x) {\n        this.x = x;\n    }\n    setY(y) {\n        this.y = y;\n    }\n    setZ(z) {\n        this.z = z;\n    }\n    toArray() {\n        return [\n            this.x,\n            this.y,\n            this.z\n        ];\n    }\n    magnitude() {\n        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n    }\n    normalize() {\n        const mag = this.magnitude();\n        if (mag === 0) {\n            return new Vector3D(0, 0, 0);\n        }\n        return new Vector3D(this.x / mag, this.y / mag, this.z / mag);\n    }\n    dot(otherVector) {\n        return this.x * otherVector.getX() + this.y * otherVector.getY() + this.z * otherVector.getZ();\n    }\n    cross(otherVector) {\n        const x = this.y * otherVector.getZ() - this.z * otherVector.getY();\n        const y = this.z * otherVector.getX() - this.x * otherVector.getZ();\n        const z = this.x * otherVector.getY() - this.y * otherVector.getX();\n        return new Vector3D(x, y, z);\n    }\n    add(otherVector) {\n        return new Vector3D(this.x + otherVector.getX(), this.y + otherVector.getY(), this.z + otherVector.getZ());\n    }\n    sub(otherVector) {\n        return new Vector3D(this.x - otherVector.getX(), this.y - otherVector.getY(), this.z - otherVector.getZ());\n    }\n    scale(scalar) {\n        return new Vector3D(this.x * scalar, this.y * scalar, this.z * scalar);\n    }\n}\nexport class NurbsCurve {\n    constructor(degree, controlPoints, knots, weights) {\n        this.degree = degree;\n        this.controlPoints = controlPoints;\n        this.knots = knots;\n        this.weights = weights;\n    }\n    getDegree() {\n        return this.degree;\n    }\n    getControlPoints() {\n        return this.controlPoints;\n    }\n    getKnots() {\n        return this.knots;\n    }\n    getWeights() {\n        return this.weights;\n    }\n    evaluate(u) {\n        if (u < this.knots[0] || u > this.knots[this.knots.length - 1]) {\n            return null;\n        }\n        return Utils.deBoor(this.degree, this.controlPoints, this.knots, this.weights, u);\n    }\n    evaluateDerivative(u, order) {\n        if (u < this.knots[0] || u > this.knots[this.knots.length - 1]) {\n            return null;\n        }\n        if (order < 0) {\n            return null;\n        }\n        return Utils.deBoorDerivative(this.degree, this.controlPoints, this.knots, this.weights, u, order);\n    }\n    length() {\n        let length = 0;\n        const numSamples = 100;\n        if (this.knots.length === 0) {\n            return length;\n        }\n        const start = this.knots[0];\n        const end = this.knots[this.knots.length - 1];\n        const step = (end - start) / numSamples;\n        let prevPoint = this.evaluate(start);\n        for (let i = 1; i <= numSamples; i++) {\n            const u = start + i * step;\n            const currentPoint = this.evaluate(u);\n            if (currentPoint && prevPoint) {\n                length += currentPoint.distanceTo(prevPoint);\n                prevPoint = currentPoint;\n            }\n        }\n        return length;\n    }\n    tangeant(u) {\n        const derivative = this.evaluateDerivative(u, 1);\n        if (!derivative)\n            return null;\n        return derivative.normalize();\n    }\n    insertKnot(u, multiplicity) {\n        if (multiplicity <= 0) {\n            return;\n        }\n        const n = this.controlPoints.length - 1;\n        const p = this.degree;\n        const knots = this.knots;\n        if (u < knots[0] || u > knots[knots.length - 1]) {\n            return;\n        }\n        const span = Utils.findSpan(n, p, u, knots);\n        let newKnots = [...knots];\n        let newControlPoints = [...this.controlPoints];\n        let newWeights = [...this.weights];\n        for (let j = 0; j < multiplicity; j++) {\n            newKnots.splice(span + 1, 0, u);\n            const alpha = [];\n            for (let i = 0; i <= p; i++) {\n                const numerator = u - knots[span - p + i];\n                const denominator = knots[span + 1 + i] - knots[span - p + i];\n                if (denominator === 0) {\n                    alpha[i] = 0;\n                } else {\n                    alpha[i] = numerator / denominator;\n                }\n            }\n            let newControlPointsTemp = [];\n            let newWeightsTemp = [];\n            for (let i = 0; i <= n; i++) {\n                if (i <= span - p) {\n                    newControlPointsTemp.push(newControlPoints[i]);\n                    newWeightsTemp.push(newWeights[i]);\n                } else if (i > span) {\n                    newControlPointsTemp.push(newControlPoints[i]);\n                    newWeightsTemp.push(newWeights[i]);\n                } else {\n                    let cp = newControlPoints[i];\n                    let w = newWeights[i];\n                    const prevCp = newControlPoints[i - 1];\n                    const prevW = newWeights[i - 1];\n                    if (i === span - p + 1) {\n                        const newPoint = new Point3D(alpha[1] * cp.x + (1 - alpha[1]) * prevCp.x, alpha[1] * cp.y + (1 - alpha[1]) * prevCp.y, alpha[1] * cp.z + (1 - alpha[1]) * prevCp.z);\n                        const newWeight = alpha[1] * w + (1 - alpha[1]) * prevW;\n                        newControlPointsTemp.push(newPoint);\n                        newWeightsTemp.push(newWeight);\n                        newControlPointsTemp.push(cp);\n                        newWeightsTemp.push(w);\n                    } else if (i > span - p + 1) {\n                        const newPoint = new Point3D(alpha[i - (span - p)] * cp.x + (1 - alpha[i - (span - p)]) * newControlPointsTemp[newControlPointsTemp.length - 1].x, alpha[i - (span - p)] * cp.y + (1 - alpha[i - (span - p)]) * newControlPointsTemp[newControlPointsTemp.length - 1].y, alpha[i - (span - p)] * cp.z + (1 - alpha[i - (span - p)]) * newControlPointsTemp[newControlPointsTemp.length - 1].z);\n                        const newWeight = alpha[i - (span - p)] * w + (1 - alpha[i - (span - p)]) * newWeightsTemp[newWeightsTemp.length - 1];\n                        newControlPointsTemp.push(newPoint);\n                        newWeightsTemp.push(newWeight);\n                        if (i < span) {\n                            newControlPointsTemp.push(cp);\n                            newWeightsTemp.push(w);\n                        }\n                    } else {\n                        newControlPointsTemp.push(cp);\n                        newWeightsTemp.push(w);\n                    }\n                }\n            }\n            newControlPoints = newControlPointsTemp;\n            newWeights = newWeightsTemp;\n            this.controlPoints = newControlPoints;\n            this.weights = newWeights;\n        }\n        this.knots = newKnots;\n    }\n    removeKnot(u, multiplicity) {\n        if (multiplicity <= 0) {\n            return;\n        }\n        const n = this.controlPoints.length - 1;\n        const p = this.degree;\n        const knots = this.knots;\n        if (u < knots[0] || u > knots[knots.length - 1]) {\n            return;\n        }\n        const span = Utils.findSpan(n, p, u, knots);\n        let newKnots = [...knots];\n        let newControlPoints = [...this.controlPoints];\n        let newWeights = [...this.weights];\n        let knotCount = 0;\n        for (let i = 0; i < knots.length; i++) {\n            if (knots[i] === u) {\n                knotCount++;\n            }\n        }\n        if (knotCount < multiplicity) {\n            return;\n        }\n        for (let j = 0; j < multiplicity; j++) {\n            newKnots.splice(span + 1, 1);\n            let newControlPointsTemp = [];\n            let newWeightsTemp = [];\n            for (let i = 0; i <= n; i++) {\n                if (i <= span - p) {\n                    newControlPointsTemp.push(newControlPoints[i]);\n                    newWeightsTemp.push(newWeights[i]);\n                } else if (i > span + 1) {\n                    newControlPointsTemp.push(newControlPoints[i]);\n                    newWeightsTemp.push(newWeights[i]);\n                } else {\n                    const alpha = [];\n                    for (let k = 0; k <= p; k++) {\n                        const numerator = u - knots[span - p + k];\n                        const denominator = knots[span + 1 + k] - knots[span - p + k];\n                        if (denominator === 0) {\n                            alpha[k] = 0;\n                        } else {\n                            alpha[k] = numerator / denominator;\n                        }\n                    }\n                    if (span - p - 1 < 0) {\n                        newControlPointsTemp.push(newControlPoints[i]);\n                        newWeightsTemp.push(newWeights[i]);\n                    } else {\n                        const cp = newControlPoints[i];\n                        const w = newWeights[i];\n                        const nextCp = newControlPoints[i + 1];\n                        const nextW = newWeights[i + 1];\n                        const newPoint = new Point3D((cp.x - (1 - alpha[1]) * nextCp.x) / alpha[1], (cp.y - (1 - alpha[1]) * nextCp.y) / alpha[1], (cp.z - (1 - alpha[1]) * nextCp.z) / alpha[1]);\n                        const newWeight = (w - (1 - alpha[1]) * nextW) / alpha[1];\n                        newControlPointsTemp.push(newPoint);\n                        newWeightsTemp.push(newWeight);\n                    }\n                }\n            }\n            newControlPoints = newControlPointsTemp;\n            newWeights = newWeightsTemp;\n            this.controlPoints = newControlPoints;\n            this.weights = newWeights;\n        }\n        this.knots = newKnots;\n    }\n    splitCurve(u) {\n        if (u < this.knots[0] || u > this.knots[this.knots.length - 1]) {\n            return null;\n        }\n        const n = this.controlPoints.length - 1;\n        const p = this.degree;\n        const knots = this.knots;\n        const span = Utils.findSpan(n, p, u, knots);\n        let newKnots = [...knots];\n        let newControlPoints = [...this.controlPoints];\n        let newWeights = [...this.weights];\n        let k = 0;\n        for (let i = 0; i < knots.length; i++) {\n            if (knots[i] === u) {\n                k++;\n            }\n        }\n        let multiplicity = p + 1 - k;\n        if (multiplicity > 0) {\n            this.insertKnot(u, multiplicity);\n            newKnots = this.knots;\n            newControlPoints = this.controlPoints;\n            newWeights = this.weights;\n        }\n        const spanSplit = Utils.findSpan(newControlPoints.length - 1, p, u, newKnots);\n        const curve1ControlPoints = newControlPoints.slice(0, spanSplit + 1);\n        const curve1Weights = newWeights.slice(0, spanSplit + 1);\n        const curve1Knots = newKnots.slice(0, spanSplit + p + 2);\n        const curve2ControlPoints = newControlPoints.slice(spanSplit);\n        const curve2Weights = newWeights.slice(spanSplit);\n        const curve2Knots = newKnots.slice(spanSplit);\n        const curve1 = new NurbsCurve(this.degree, curve1ControlPoints, curve1Knots, curve1Weights);\n        const curve2 = new NurbsCurve(this.degree, curve2ControlPoints, curve2Knots, curve2Weights);\n        return [\n            curve1,\n            curve2\n        ];\n    }\n    reverse() {\n        const reversedControlPoints = [...this.controlPoints].reverse();\n        const reversedWeights = [...this.weights].reverse();\n        const reversedKnots = [...this.knots].reverse().map(k => this.knots[this.knots.length - 1] - k);\n        return new NurbsCurve(this.degree, reversedControlPoints, reversedKnots, reversedWeights);\n    }\n}\nexport class NurbsSurface {\n    constructor(degreeU, degreeV, controlPoints, knotsU, knotsV, weights) {\n        this.degreeU = degreeU;\n        this.degreeV = degreeV;\n        this.controlPoints = controlPoints;\n        this.knotsU = knotsU;\n        this.knotsV = knotsV;\n        this.weights = weights;\n    }\n    getDegreeU() {\n        return this.degreeU;\n    }\n    getDegreeV() {\n        return this.degreeV;\n    }\n    getControlPoints() {\n        return this.controlPoints;\n    }\n    getKnotsU() {\n        return this.knotsU;\n    }\n    getKnotsV() {\n        return this.knotsV;\n    }\n    getWeights() {\n        return this.weights;\n    }\n    evaluate(u, v) {\n        if (u < this.knotsU[0] || u > this.knotsU[this.knotsU.length - 1] || v < this.knotsV[0] || v > this.knotsV[this.knotsV.length - 1]) {\n            return null;\n        }\n        const n = this.controlPoints.length - 1;\n        const m = this.controlPoints[0].length - 1;\n        const p = this.degreeU;\n        const q = this.degreeV;\n        const U = this.knotsU;\n        const V = this.knotsV;\n        const P = this.controlPoints;\n        const W = this.weights;\n        let Su = [];\n        for (let i = 0; i <= m; i++) {\n            let controlPoints = [];\n            let weights = [];\n            for (let j = 0; j <= n; j++) {\n                controlPoints.push(P[j][i]);\n                weights.push(W[j][i]);\n            }\n            Su.push(Utils.deBoor(p, controlPoints, U, weights, u));\n        }\n        let controlPoints = [...Su];\n        let weights = Array(Su.length).fill(1);\n        return Utils.deBoor(q, controlPoints, V, weights, v);\n    }\n    evaluatePartialDerivative(u, v, orderU, orderV) {\n        if (u < this.knotsU[0] || u > this.knotsU[this.knotsU.length - 1] || v < this.knotsV[0] || v > this.knotsV[this.knotsV.length - 1]) {\n            return null;\n        }\n        if (orderU < 0 || orderV < 0) {\n            return null;\n        }\n        const n = this.controlPoints.length - 1;\n        const m = this.controlPoints[0].length - 1;\n        const p = this.degreeU;\n        const q = this.degreeV;\n        const U = this.knotsU;\n        const V = this.knotsV;\n        const P = this.controlPoints;\n        const W = this.weights;\n        let Su = [];\n        for (let i = 0; i <= m; i++) {\n            let controlPoints = [];\n            let weights = [];\n            for (let j = 0; j <= n; j++) {\n                controlPoints.push(P[j][i]);\n                weights.push(W[j][i]);\n            }\n            Su.push(Utils.deBoorDerivative(p, controlPoints, U, weights, u, orderU));\n        }\n        let controlPoints = [...Su];\n        let weights = Array(Su.length).fill(1);\n        const derivative = Utils.deBoorDerivative(q, controlPoints, V, weights, v, orderV);\n        if (!derivative || isNaN(derivative.getX()) || isNaN(derivative.getY()) || isNaN(derivative.getZ())) {\n            return null;\n        }\n        return derivative;\n    }\n    normal(u, v) {\n        const derivativeU = this.evaluatePartialDerivative(u, v, 1, 0);\n        const derivativeV = this.evaluatePartialDerivative(u, v, 0, 1);\n        if (!derivativeU || !derivativeV) {\n            return null;\n        }\n        const normalVector = derivativeU.cross(derivativeV);\n        if (normalVector.magnitude() === 0) {\n            return null;\n        }\n        if (isNaN(normalVector.getX()) || isNaN(normalVector.getY()) || isNaN(normalVector.getZ())) {\n            return null;\n        }\n        return normalVector.normalize();\n    }\n    insertKnotU(u, multiplicity) {\n        if (multiplicity <= 0) {\n            return;\n        }\n        const n = this.controlPoints.length - 1;\n        const p = this.degreeU;\n        const knots = this.knotsU;\n        if (u < knots[0] || u > knots[knots.length - 1]) {\n            return;\n        }\n        const span = Utils.findSpan(n, p, u, knots);\n        let newKnots = [...knots];\n        let newControlPoints = this.controlPoints.map(row => [...row]);\n        let newWeights = this.weights.map(row => [...row]);\n        for (let j = 0; j < multiplicity; j++) {\n            newKnots.splice(span + 1, 0, u);\n            const alpha = [];\n            for (let i = 0; i <= p; i++) {\n                const numerator = u - knots[span - p + i];\n                const denominator = knots[span + 1 + i] - knots[span - p + i];\n                if (denominator === 0) {\n                    alpha[i] = 0;\n                } else {\n                    alpha[i] = numerator / denominator;\n                }\n            }\n            let newControlPointsTemp = [];\n            let newWeightsTemp = [];\n            for (let i = 0; i < newControlPoints.length; i++) {\n                let rowControlPoints = [];\n                let rowWeights = [];\n                for (let k = 0; k < newControlPoints[i].length; k++) {\n                    if (i <= span - p) {\n                        rowControlPoints.push(newControlPoints[i][k]);\n                        rowWeights.push(newWeights[i][k]);\n                    } else if (i > span) {\n                        rowControlPoints.push(newControlPoints[i][k]);\n                        rowWeights.push(newWeights[i][k]);\n                    } else {\n                        const cp = newControlPoints[i][k];\n                        const w = newWeights[i][k];\n                        const prevCp = newControlPoints[i - 1][k];\n                        const prevW = newWeights[i - 1][k];\n                        const newPoint = new Point3D(alpha[i - (span - p)] * cp.x + (1 - alpha[i - (span - p)]) * prevCp.x, alpha[i - (span - p)] * cp.y + (1 - alpha[i - (span - p)]) * prevCp.y, alpha[i - (span - p)] * cp.z + (1 - alpha[i - (span - p)]) * prevCp.z);\n                        const newWeight = alpha[i - (span - p)] * w + (1 - alpha[i - (span - p)]) * prevW;\n                        rowControlPoints.push(newPoint);\n                        rowWeights.push(newWeight);\n                        rowControlPoints.push(newControlPoints[i][k]);\n                        rowWeights.push(newWeights[i][k]);\n                    }\n                }\n                newControlPointsTemp.push(rowControlPoints);\n                newWeightsTemp.push(rowWeights);\n            }\n            newControlPoints = newControlPointsTemp;\n            newWeights = newWeightsTemp;\n            this.controlPoints = newControlPoints;\n            this.weights = newWeights;\n        }\n        this.knotsU = newKnots;\n    }\n    insertKnotV(v, multiplicity) {\n        if (multiplicity <= 0) {\n            return;\n        }\n        const m = this.controlPoints[0].length - 1;\n        const q = this.degreeV;\n        const knots = this.knotsV;\n        if (v < knots[0] || v > knots[knots.length - 1]) {\n            return;\n        }\n        const span = Utils.findSpan(m, q, v, knots);\n        let newKnots = [...knots];\n        let newControlPoints = this.controlPoints.map(row => [...row]);\n        let newWeights = this.weights.map(row => [...row]);\n        for (let j = 0; j < multiplicity; j++) {\n            newKnots.splice(span + 1, 0, v);\n            const alpha = [];\n            for (let i = 0; i <= q; i++) {\n                const numerator = v - knots[span - q + i];\n                const denominator = knots[span + 1 + i] - knots[span - q + i];\n                if (denominator === 0) {\n                    alpha[i] = 0;\n                } else {\n                    alpha[i] = numerator / denominator;\n                }\n            }\n            let newControlPointsTemp = [];\n            let newWeightsTemp = [];\n            for (let i = 0; i < newControlPoints.length; i++) {\n                let rowControlPoints = [];\n                let rowWeights = [];\n                for (let k = 0; k < newControlPoints[i].length; k++) {\n                    if (k <= span - q) {\n                        rowControlPoints.push(newControlPoints[i][k]);\n                        rowWeights.push(newWeights[i][k]);\n                    } else if (k > span) {\n                        rowControlPoints.push(newControlPoints[i][k]);\n                        rowWeights.push(newWeights[i][k]);\n                    } else {\n                        const cp = newControlPoints[i][k];\n                        const w = newWeights[i][k];\n                        const prevCp = newControlPoints[i][k - 1];\n                        const prevW = newWeights[i][k - 1];\n                        const newPoint = new Point3D(alpha[k - (span - q)] * cp.x + (1 - alpha[k - (span - q)]) * prevCp.x, alpha[k - (span - q)] * cp.y + (1 - alpha[k - (span - q)]) * prevCp.y, alpha[k - (span - q)] * cp.z + (1 - alpha[k - (span - q)]) * prevCp.z);\n                        const newWeight = alpha[k - (span - q)] * w + (1 - alpha[k - (span - q)]) * prevW;\n                        rowControlPoints.push(newPoint);\n                        rowWeights.push(newWeight);\n                        rowControlPoints.push(newControlPoints[i][k]);\n                        rowWeights.push(newWeights[i][k]);\n                    }\n                }\n                newControlPointsTemp.push(rowControlPoints);\n                newWeightsTemp.push(rowWeights);\n            }\n            newControlPoints = newControlPointsTemp;\n            newWeights = newWeightsTemp;\n            this.controlPoints = newControlPoints;\n            this.weights = newWeights;\n        }\n        this.knotsV = newKnots;\n    }\n    removeKnotU(u, multiplicity) {\n        if (multiplicity <= 0) {\n            return;\n        }\n        const n = this.controlPoints.length - 1;\n        const p = this.degreeU;\n        const knots = this.knotsU;\n        if (u <= knots[0] || u >= knots[knots.length - 1]) {\n            return;\n        }\n        const span = Utils.findSpan(n, p, u, knots);\n        let newKnots = [...knots];\n        let newControlPoints = this.controlPoints.map(row => [...row]);\n        let newWeights = this.weights.map(row => [...row]);\n        let knotCount = 0;\n        for (let i = 0; i < knots.length; i++) {\n            if (knots[i] === u) {\n                knotCount++;\n            }\n        }\n        if (knotCount < multiplicity) {\n            return;\n        }\n        for (let j = 0; j < multiplicity; j++) {\n            newKnots.splice(span + 1, 1);\n            let newControlPointsTemp = [];\n            let newWeightsTemp = [];\n            for (let i = 0; i < newControlPoints.length; i++) {\n                let rowControlPoints = [];\n                let rowWeights = [];\n                for (let k = 0; k < newControlPoints[i].length; k++) {\n                    if (i <= span - p) {\n                        rowControlPoints.push(newControlPoints[i][k]);\n                        rowWeights.push(newWeights[i][k]);\n                    } else if (i > span + 1) {\n                        rowControlPoints.push(newControlPoints[i][k]);\n                        rowWeights.push(newWeights[i][k]);\n                    } else {\n                        const alpha = [];\n                        for (let l = 0; l <= p; l++) {\n                            const numerator = u - knots[span - p + l];\n                            const denominator = knots[span + 1 + l] - knots[span - p + l];\n                            if (denominator === 0) {\n                                alpha[l] = 0;\n                            } else {\n                                alpha[l] = numerator / denominator;\n                            }\n                        }\n                        if (span - p - 1 < 0) {\n                            rowControlPoints.push(newControlPoints[i][k]);\n                            rowWeights.push(newWeights[i][k]);\n                        } else {\n                            const cp = newControlPoints[i][k];\n                            const w = newWeights[i][k];\n                            const nextCp = newControlPoints[i + 1][k];\n                            const nextW = newWeights[i + 1][k];\n                            const newPoint = new Point3D((cp.x - (1 - alpha[1]) * nextCp.x) / alpha[1], (cp.y - (1 - alpha[1]) * nextCp.y) / alpha[1], (cp.z - (1 - alpha[1]) * nextCp.z) / alpha[1]);\n                            const newWeight = (w - (1 - alpha[1]) * nextW) / alpha[1];\n                            rowControlPoints.push(newPoint);\n                            rowWeights.push(newWeight);\n                        }\n                    }\n                }\n                newControlPointsTemp.push(rowControlPoints);\n                newWeightsTemp.push(rowWeights);\n            }\n            newControlPoints = newControlPointsTemp;\n            newWeights = newWeightsTemp;\n            this.controlPoints = newControlPoints;\n            this.weights = newWeights;\n        }\n        this.knotsU = newKnots;\n    }\n    removeKnotV(v, multiplicity) {\n        if (multiplicity <= 0) {\n            return;\n        }\n        const m = this.controlPoints[0].length - 1;\n        const q = this.degreeV;\n        const knots = this.knotsV;\n        if (v <= knots[0] || v >= knots[knots.length - 1]) {\n            return;\n        }\n        const span = Utils.findSpan(m, q, v, knots);\n        let newKnots = [...knots];\n        let newControlPoints = this.controlPoints.map(row => [...row]);\n        let newWeights = this.weights.map(row => [...row]);\n        let knotCount = 0;\n        for (let i = 0; i < knots.length; i++) {\n            if (knots[i] === v) {\n                knotCount++;\n            }\n        }\n        if (knotCount < multiplicity) {\n            return;\n        }\n        for (let j = 0; j < multiplicity; j++) {\n            newKnots.splice(span + 1, 1);\n            let newControlPointsTemp = [];\n            let newWeightsTemp = [];\n            for (let i = 0; i < newControlPoints.length; i++) {\n                let rowControlPoints = [];\n                let rowWeights = [];\n                for (let k = 0; k < newControlPoints[i].length; k++) {\n                    if (k <= span - q) {\n                        rowControlPoints.push(newControlPoints[i][k]);\n                        rowWeights.push(newWeights[i][k]);\n                    } else if (k > span + 1) {\n                        rowControlPoints.push(newControlPoints[i][k]);\n                        rowWeights.push(newWeights[i][k]);\n                    } else {\n                        const alpha = [];\n                        for (let l = 0; l <= q; l++) {\n                            const numerator = v - knots[span - q + l];\n                            const denominator = knots[span + 1 + l] - knots[span - q + l];\n                            if (denominator === 0) {\n                                alpha[l] = 0;\n                            } else {\n                                alpha[l] = numerator / denominator;\n                            }\n                        }\n                        if (span - q - 1 < 0) {\n                            rowControlPoints.push(newControlPoints[i][k]);\n                            rowWeights.push(newWeights[i][k]);\n                        } else {\n                            const cp = newControlPoints[i][k];\n                            const w = newWeights[i][k];\n                            const nextCp = newControlPoints[i][k + 1];\n                            const nextW = newWeights[i][k + 1];\n                            const newPoint = new Point3D((cp.x - (1 - alpha[1]) * nextCp.x) / alpha[1], (cp.y - (1 - alpha[1]) * nextCp.y) / alpha[1], (cp.z - (1 - alpha[1]) * nextCp.z) / alpha[1]);\n                            const newWeight = (w - (1 - alpha[1]) * nextW) / alpha[1];\n                            rowControlPoints.push(newPoint);\n                            rowWeights.push(newWeight);\n                        }\n                    }\n                }\n                newControlPointsTemp.push(rowControlPoints);\n                newWeightsTemp.push(rowWeights);\n            }\n            newControlPoints = newControlPointsTemp;\n            newWeights",
      "hidden": false
    }
  ],
  "title": "NURBS Library Development in JavaScript",
  "id": "20250118_072638581Z",
  "targetFile": "./brep.js",
  "chatMode": "chat",
  "conversationNew": false,
  "lastModified": "2025-01-18T07:30:36.001Z"
}