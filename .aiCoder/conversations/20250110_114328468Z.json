{
  "messages": [
    {
      "role": "system",
      "content": "./.aiCoder/prompts/default-system-prompt.md",
      "filePath": "./.aiCoder/prompts/default-system-prompt.md",
      "description": "",
      "hidden": true
    },
    {
      "role": "user",
      "content": "./.aiCoder/prompts/default-plan-prompt.md",
      "filePath": "./.aiCoder/prompts/default-plan-prompt.md",
      "description": "",
      "hidden": true
    },
    {
      "role": "user",
      "content": "./brep.js",
      "filePath": "./brep.js",
      "description": "// Code file to be edited",
      "hidden": true
    },
    {
      "role": "system",
      "content": "./.aiCoder/prompts/snippet-production-prompt.md",
      "filePath": "./.aiCoder/prompts/snippet-production-prompt.md",
      "description": "",
      "hidden": true
    },
    {
      "role": "user",
      "content": "Are there any place holders or unimplemented portions of the classes?\nList each method as an individual numbered item in the list like this:\n##ACTION LIST\n1. className.methodName\n2. className.methodName",
      "hidden": false
    },
    {
      "role": "assistant",
      "content": "I've reviewed the code and noticed several placeholders or potentially unimplemented portions. Here's the list of methods that need attention:\n\n##ACTION LIST\n1. NurbsCurve.refine - Current implementation is basic and could be improved\n2. NurbsCurve.degreeElevate - Implementation needs optimization\n3. NurbsCurve.knotRemove - Could use more robust implementation\n4. NurbsIntersection.surfaceSurfaceIntersection - Could be optimized for better performance\n5. NurbsIntersection.curveSurfaceIntersection - Could be enhanced with better intersection detection\n6. NurbsIntersection.curveCurveIntersection - Could be improved with more robust intersection detection\n7. NumericalIntegration.gaussianQuadrature - Limited to 5 points, could be expanded\n8. Face.intersectEdge - Could be optimized for better performance\n9. Face.containsPoint - Could be enhanced for better point containment testing\n10. Shell.intersects - Could be optimized for better performance\n11. Solid.union - Implementation could be more robust\n12. Solid.intersection - Implementation could be more robust\n13. Solid.difference - Implementation could be more robust\n14. Surface.projectPoint - Could be optimized for better performance\n15. Edge.tangentAt - Could handle edge cases better\n\nThese methods, while implemented, could benefit from optimization, better error handling, or more robust implementations. Would you like me to focus on implementing any specific one from this list?",
      "hidden": false
    },
    {
      "role": "user",
      "content": "list was not in the correct format. Put a space between the ## and ACTION LIST\n",
      "hidden": false
    },
    {
      "role": "assistant",
      "content": "## ACTION LIST\n1. NurbsCurve.refine\n2. NurbsCurve.degreeElevate\n3. NurbsCurve.knotRemove\n4. NurbsIntersection.surfaceSurfaceIntersection\n5. NurbsIntersection.curveSurfaceIntersection\n6. NurbsIntersection.curveCurveIntersection\n7. NumericalIntegration.gaussianQuadrature\n8. Face.intersectEdge\n9. Face.containsPoint\n10. Shell.intersects\n11. Solid.union\n12. Solid.intersection\n13. Solid.difference\n14. Surface.projectPoint\n15. Edge.tangentAt",
      "hidden": false
    },
    {
      "role": "user",
      "content": "Perform action 1. NurbsCurve.refine",
      "hidden": false
    },
    {
      "role": "assistant",
      "content": "```javascript\nclass NurbsCurve {\n    refine(u) {\n        if (u < this.knotVector[0] || u > this.knotVector[this.knotVector.length - 1]) {\n            throw new Error('Parameter u is out of range of the knot vector.');\n        }\n\n        const n = this.controlPoints.length - 1;\n        const p = this.degree;\n        const U = this.knotVector;\n        let span = this.findSpan(n, p, u, U);\n        \n        if (span === -1) return null;\n\n        // Create new arrays for refined curve\n        const newKnotVector = [...U];\n        const newControlPoints = [];\n        \n        // Initialize new control points array\n        for (let i = 0; i <= n + 1; i++) {\n            newControlPoints[i] = new Array(this.isRational ? 4 : 3).fill(0);\n        }\n\n        // Insert the new knot\n        let k = span - p + 1;\n        const r = 1; // multiplicity of inserted knot\n        \n        // Load unaltered control points\n        for (let i = 0; i <= k - 1; i++) {\n            newControlPoints[i] = [...this.controlPoints[i]];\n        }\n        for (let i = k + p; i <= n; i++) {\n            newControlPoints[i + r] = [...this.controlPoints[i]];\n        }\n        \n        // Calculate alpha coefficients\n        const alpha = new Array(p + 1);\n        for (let j = 1; j <= p; j++) {\n            alpha[j] = 0;\n            for (let i = 0; i <= j - 1; i++) {\n                const denominator = U[span + i + 1] - U[span - j + i + 1];\n                alpha[j] += denominator !== 0 ? (u - U[span - j + i + 1]) / denominator : 0;\n            }\n        }\n        \n        // Create temporary storage arrays\n        const temp = new Array(p + 1);\n        for (let i = 0; i <= p; i++) {\n            temp[i] = [...this.controlPoints[k + i]];\n        }\n\n        // Insert the new knot\n        for (let j = 1; j <= p; j++) {\n            for (let i = 0; i <= p - j; i++) {\n                const alpha_i = alpha[j];\n                const oneMinusAlpha = 1.0 - alpha_i;\n                \n                // Interpolate each component\n                for (let d = 0; d < (this.isRational ? 4 : 3); d++) {\n                    temp[i][d] = oneMinusAlpha * temp[i][d] + alpha_i * temp[i + 1][d];\n                }\n            }\n        }\n\n        // Load computed control points\n        for (let i = k; i < k + p; i++) {\n            newControlPoints[i] = [...temp[i - k]];\n        }\n\n        // Insert the new knot into knot vector\n        newKnotVector.splice(span + 1, 0, u);\n\n        // Update the curve\n        this.knotVector = newKnotVector;\n        this.controlPoints = newControlPoints;\n    }\n}\n```",
      "hidden": false
    },
    {
      "role": "user",
      "content": "Perform action 2. NurbsCurve.degreeElevate",
      "hidden": false
    },
    {
      "role": "assistant",
      "content": "```javascript\nclass NurbsCurve {\n    degreeElevate() {\n        const p = this.degree;\n        const n = this.controlPoints.length - 1;\n        const U = this.knotVector;\n        const Q = this.controlPoints;\n        const newDegree = p + 1;\n\n        // Initialize new arrays\n        let newKnotVector = [...U];\n        let newControlPoints = [];\n        const bezalfs = Array(p + 2).fill().map(() => Array(p + 2).fill(0));\n        const bpts = [];\n        const ebpts = [];\n        const Nextbpts = [];\n        const alphas = [];\n\n        // Compute Bezier degree elevation coefficients\n        bezalfs[0][0] = 1.0;\n        bezalfs[p + 1][p + 1] = 1.0;\n\n        for (let i = 1; i <= p; i++) {\n            for (let j = Math.max(0, i - 1); j <= Math.min(p, i); j++) {\n                bezalfs[i][j] = this.combination(p, j) * this.combination(p - j, i - j) / this.combination(p + 1, i);\n            }\n        }\n\n        // Initialize first Bezier segment\n        const m = n + p + 1;\n        let kind = this.findSpan(n, p, U[0], U);\n        let r = -1;\n        let a = p;\n        let b = p + 1;\n        let cind = 1;\n        let ua = U[0];\n        let ub = 0;\n        const npts = [];\n        const allpts = [];\n\n        for (let i = 0; i <= p; i++) {\n            npts[i] = Q[i];\n        }\n\n        // Initialize points\n        for (let i = 0; i <= p; i++) {\n            bpts[i] = [...npts[i]];\n        }\n\n        // Loop through knot vector\n        while (b < m) {\n            i = b;\n            while (b < m && U[b] === U[b + 1]) b++;\n            let mul = b - i + 1;\n            ub = U[b];\n            let oldr = r;\n            r = p - mul;\n\n            // Insert knot u(b) r times\n            if (oldr > 0) lbz = (p + 1) - (oldr - 1);\n            else lbz = 1;\n\n            if (r > 0) rbz = p - r;\n            else rbz = p;\n\n            // Insert knot to get Bezier segment\n            if (r > 0) {\n                let numer = ub - ua;\n                for (let k = p; k >= mul; k--) {\n                    alphas[k - mul] = numer / (U[a + k] - ua);\n                }\n                for (let j = 1; j <= r; j++) {\n                    let save = r - j;\n                    let s = mul + j;\n                    for (let k = p; k >= s; k--) {\n                        bpts[k] = this.vectorAdd(\n                            this.vectorScale(alphas[k - s], bpts[k]),\n                            this.vectorScale(1.0 - alphas[k - s], bpts[k - 1])\n                        );\n                    }\n                    Nextbpts[save] = [...bpts[p]];\n                }\n            }\n\n            // Degree elevate Bezier\n            for (let i = lbz; i <= p; i++) {\n                ebpts[i] = Array(this.isRational ? 4 : 3).fill(0);\n                for (let j = Math.max(0, i - 1); j <= Math.min(p, i); j++) {\n                    ebpts[i] = this.vectorAdd(\n                        ebpts[i],\n                        this.vectorScale(bezalfs[i][j], bpts[j])\n                    );\n                }\n            }\n\n            // Must remove knot u=U[a] oldr times\n            if (oldr > 1) {\n                // If first time through, save original knot vector\n                if (first) {\n                    for (let k = 0; k < a; k++) {\n                        nc[cind] = [...Q[k]];\n                        cind++;\n                    }\n                }\n                for (let k = lbz; k <= p; k++) {\n                    nc[cind] = [...ebpts[k]];\n                    cind++;\n                }\n            } else {\n                for (let k = lbz; k <= p; k++) {\n                    nc[cind] = [...ebpts[k]];\n                    cind++;\n                }\n            }\n\n            // Set up for next pass through loop\n            if (b < m) {\n                for (let j = 0; j < r; j++) {\n                    bpts[j] = [...Nextbpts[j]];\n                }\n                for (let j = r; j <= p; j++) {\n                    bpts[j] = [...Q[b - p + j]];\n                }\n                a = b;\n                ua = ub;\n            }\n        }\n\n        // Compute new knot vector\n        const newLength = this.knotVector.length + this.controlPoints.length;\n        for (let i = 0; i < newLength; i++) {\n            if (i <= p + 1) {\n                newKnotVector[i] = U[0];\n            } else if (i >= newLength - p - 2) {\n                newKnotVector[i] = U[U.length - 1];\n            } else {\n                newKnotVector[i] = U[i - 1];\n            }\n        }\n\n        // Update curve properties\n        this.degree = newDegree;\n        this.controlPoints = newControlPoints;\n        this.knotVector = newKnotVector;\n    }\n\n    // Helper methods for degreeElevate\n    combination(n, k) {\n        if (k < 0 || k > n) return 0;\n        if (k === 0 || k === n) return 1;\n        \n        let r = 1;\n        for (let i = 0; i < k; i++) {\n            r *= (n - i);\n            r /= (i + 1);\n        }\n        return r;\n    }\n\n    vectorAdd(a, b) {\n        return a.map((v, i) => v + b[i]);\n    }\n\n    vectorScale(s, v) {\n        return v.map(x => s * x);\n    }\n}\n```",
      "hidden": false
    },
    {
      "role": "user",
      "content": "Perform action 3. NurbsCurve.knotRemove",
      "hidden": false
    },
    {
      "role": "assistant",
      "content": "```javascript\nclass NurbsCurve {\n    knotRemove(u) {\n        if (u < this.knotVector[0] || u > this.knotVector[this.knotVector.length - 1]) {\n            throw new Error('Parameter u is out of range of the knot vector.');\n        }\n\n        const n = this.controlPoints.length - 1;\n        const p = this.degree;\n        const U = this.knotVector;\n        let span = this.findSpan(n, p, u, U);\n        \n        if (span === -1) return null;\n\n        // Find multiplicity of knot\n        const multiplicity = this.knotMultiplicity(u);\n        if (multiplicity <= 1) {\n            return; // Nothing to remove\n        }\n\n        // Initialize new arrays\n        const newKnotVector = [...U];\n        const newControlPoints = [...this.controlPoints];\n\n        // Find the first and last affected control points\n        let firstAffected = span - p;\n        let lastAffected = span;\n\n        // Calculate alphas for affected control points\n        let alphas = new Array(p + 1).fill(0);\n        for (let j = 1; j <= multiplicity; j++) {\n            const i = span - p + j;\n            if (i >= 0 && i <= n) {\n                const diff = U[span + 1] - U[i];\n                alphas[j - 1] = diff !== 0 ? (u - U[i]) / diff : 0;\n            }\n        }\n\n        // Remove the knot\n        for (let r = 0; r < multiplicity; r++) {\n            // Update control points\n            for (let i = firstAffected + r; i <= lastAffected - r; i++) {\n                const alpha = alphas[i - firstAffected];\n                \n                // Skip if alpha is undefined or invalid\n                if (isNaN(alpha)) continue;\n\n                // Calculate new control point\n                for (let d = 0; d < (this.isRational ? 4 : 3); d++) {\n                    newControlPoints[i][d] = (newControlPoints[i][d] - (1 - alpha) * newControlPoints[i - 1][d]) / alpha;\n                }\n            }\n\n            // Remove the knot from the knot vector\n            newKnotVector.splice(span, 1);\n            span--;\n        }\n\n        // Remove affected control points\n        newControlPoints.splice(lastAffected - multiplicity + 1, multiplicity - 1);\n\n        // Update curve properties\n        this.knotVector = newKnotVector;\n        this.controlPoints = newControlPoints;\n    }\n\n    knotMultiplicity(u) {\n        let count = 0;\n        const tolerance = 1e-8;\n        \n        for (const knot of this.knotVector) {\n            if (Math.abs(knot - u) < tolerance) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n}\n```",
      "hidden": false
    },
    {
      "role": "user",
      "content": "Perform action 4. NurbsIntersection.surfaceSurfaceIntersection",
      "hidden": false
    },
    {
      "role": "assistant",
      "content": "```javascript\nclass NurbsIntersection {\n    surfaceSurfaceIntersection(surfaceA, surfaceB, tolerance) {\n        if (!surfaceA || !surfaceB || typeof tolerance !== 'number' || tolerance <= 0) {\n            return [];\n        }\n\n        const uDivisions = 20; // Increased from 10 for better accuracy\n        const vDivisions = 20;\n        const intersections = [];\n        const processedPoints = new Set();\n\n        // Adaptive mesh refinement parameters\n        const maxDepth = 5;\n        const minSize = 0.01;\n\n        const subdivideAndCheck = (u0, v0, u1, v1, depth = 0) => {\n            const p00 = surfaceA.evaluate(u0, v0);\n            const p01 = surfaceA.evaluate(u0, v1);\n            const p10 = surfaceA.evaluate(u1, v0);\n            const p11 = surfaceA.evaluate(u1, v1);\n\n            if (!p00 || !p01 || !p10 || !p11) {\n                return;\n            }\n\n            // Project points onto surface B\n            const q00 = surfaceB.projectPoint(p00);\n            const q01 = surfaceB.projectPoint(p01);\n            const q10 = surfaceB.projectPoint(p10);\n            const q11 = surfaceB.projectPoint(p11);\n\n            if (!q00 || !q01 || !q10 || !q11) {\n                return;\n            }\n\n            // Evaluate projected points on surface B\n            const q00Surface = surfaceB.pointAt(q00.u, q00.v);\n            const q01Surface = surfaceB.pointAt(q01.u, q01.v);\n            const q10Surface = surfaceB.pointAt(q10.u, q10.v);\n            const q11Surface = surfaceB.pointAt(q11.u, q11.v);\n\n            // Calculate distances\n            const dist00 = this.distance(p00, q00Surface);\n            const dist01 = this.distance(p01, q01Surface);\n            const dist10 = this.distance(p10, q10Surface);\n            const dist11 = this.distance(p11, q11Surface);\n\n            // Check if patch needs subdivision\n            const needsSubdivision = (\n                depth < maxDepth &&\n                (u1 - u0) > minSize &&\n                (v1 - v0) > minSize &&\n                Math.max(dist00, dist01, dist10, dist11) > tolerance &&\n                Math.min(dist00, dist01, dist10, dist11) < tolerance * 10\n            );\n\n            if (needsSubdivision) {\n                const uMid = (u0 + u1) / 2;\n                const vMid = (v0 + v1) / 2;\n\n                // Subdivide patch into four smaller patches\n                subdivideAndCheck(u0, v0, uMid, vMid, depth + 1);\n                subdivideAndCheck(uMid, v0, u1, vMid, depth + 1);\n                subdivideAndCheck(u0, vMid, uMid, v1, depth + 1);\n                subdivideAndCheck(uMid, vMid, u1, v1, depth + 1);\n            } else if (Math.max(dist00, dist01, dist10, dist11) < tolerance) {\n                // Found intersection point\n                const midU = (u0 + u1) / 2;\n                const midV = (v0 + v1) / 2;\n                const intersectionPoint = surfaceA.evaluate(midU, midV);\n\n                if (intersectionPoint) {\n                    // Check if point is already processed\n                    const pointKey = this.getPointKey(intersectionPoint);\n                    if (!processedPoints.has(pointKey)) {\n                        processedPoints.add(pointKey);\n                        intersections.push(intersectionPoint);\n                    }\n                }\n            }\n        };\n\n        // Initial subdivision of parameter space\n        for (let i = 0; i < uDivisions; i++) {\n            for (let j = 0; j < vDivisions; j++) {\n                const u0 = i / uDivisions;\n                const v0 = j / vDivisions;\n                const u1 = (i + 1) / uDivisions;\n                const v1 = (j + 1) / vDivisions;\n\n                subdivideAndCheck(u0, v0, u1, v1);\n            }\n        }\n\n        // Post-process intersections to remove duplicates and sort\n        return this.postProcessIntersections(intersections, tolerance);\n    }\n\n    // Helper methods\n    distance(point1, point2) {\n        return Math.sqrt(\n            Math.pow(point1.x - point2.x, 2) +\n            Math.pow(point1.y - point2.y, 2) +\n            Math.pow(point1.z - point2.z, 2)\n        );\n    }\n\n    getPointKey(point, precision = 6) {\n        return `${point.x.toFixed(precision)},${point.y.toFixed(precision)},${point.z.toFixed(precision)}`;\n    }\n\n    postProcessIntersections(intersections, tolerance) {\n        // Remove duplicates within tolerance\n        const filtered = [];\n        const used = new Set();\n\n        for (let i = 0; i < intersections.length; i++) {\n            if (used.has(i)) continue;\n\n            const current = intersections[i];\n            filtered.push(current);\n            used.add(i);\n\n            // Mark nearby points as used\n            for (let j = i + 1; j < intersections.length; j++) {\n                if (this.distance(current, intersections[j]) < tolerance) {\n                    used.add(j);\n                }\n            }\n        }\n\n        // Sort points to form a continuous curve where possible\n        const sorted = [filtered[0]];\n        const remaining = filtered.slice(1);\n\n        while (remaining.length > 0) {\n            const last = sorted[sorted.length - 1];\n            let nearestIndex = 0;\n            let nearestDistance = Infinity;\n\n            for (let i = 0; i < remaining.length; i++) {\n                const distance = this.distance(last, remaining[i]);\n                if (distance < nearestDistance) {\n                    nearestDistance = distance;\n                    nearestIndex = i;\n                }\n            }\n\n            sorted.push(remaining[nearestIndex]);\n            remaining.splice(nearestIndex, 1);\n        }\n\n        return sorted;\n    }\n}\n```",
      "hidden": false
    },
    {
      "role": "user",
      "content": "Perform action 5. NurbsIntersection.curveSurfaceIntersection",
      "hidden": false
    },
    {
      "role": "assistant",
      "content": "```javascript\nclass NurbsIntersection {\n    curveSurfaceIntersection(curve, surface, tolerance) {\n        if (!curve || !surface || typeof tolerance !== 'number' || tolerance <= 0) {\n            return [];\n        }\n\n        const numSamples = 100;\n        const intersections = [];\n        const processedPoints = new Set();\n        const maxIterations = 20;\n\n        // Adaptive refinement parameters\n        const minSegmentLength = 0.001;\n        const maxDepth = 8;\n\n        const subdivideAndCheck = (t0, t1, depth = 0) => {\n            const p0 = curve.evaluate(curve.knotVector[0] + t0 * (curve.knotVector[curve.knotVector.length - 1] - curve.knotVector[0]));\n            const p1 = curve.evaluate(curve.knotVector[0] + t1 * (curve.knotVector[curve.knotVector.length - 1] - curve.knotVector[0]));\n\n            if (!p0 || !p1) return;\n\n            const p0Projected = surface.projectPoint(p0);\n            const p1Projected = surface.projectPoint(p1);\n\n            if (!p0Projected || !p1Projected) return;\n\n            const p0Surface = surface.pointAt(p0Projected.u, p0Projected.v);\n            const p1Surface = surface.pointAt(p1Projected.u, p1Projected.v);\n\n            const dist0 = this.distance(p0, p0Surface);\n            const dist1 = this.distance(p1, p1Surface);\n\n            // Check if segment needs subdivision\n            const segmentLength = t1 - t0;\n            const needsSubdivision = (\n                depth < maxDepth &&\n                segmentLength > minSegmentLength &&\n                Math.max(dist0, dist1) > tolerance &&\n                Math.min(dist0, dist1) < tolerance * 10\n            );\n\n            if (needsSubdivision) {\n                const tMid = (t0 + t1) / 2;\n                subdivideAndCheck(t0, tMid, depth + 1);\n                subdivideAndCheck(tMid, t1, depth + 1);\n            } else if (Math.min(dist0, dist1) < tolerance) {\n                // Newton-Raphson refinement\n                let t = (t0 + t1) / 2;\n                let iteration = 0;\n                let lastDistance = Infinity;\n\n                while (iteration < maxIterations) {\n                    const point = curve.evaluate(curve.knotVector[0] + t * (curve.knotVector[curve.knotVector.length - 1] - curve.knotVector[0]));\n                    if (!point) break;\n\n                    const projected = surface.projectPoint(point);\n                    if (!projected) break;\n\n                    const surfacePoint = surface.pointAt(projected.u, projected.v);\n                    const distance = this.distance(point, surfacePoint);\n\n                    if (distance < tolerance) {\n                        const pointKey = this.getPointKey(point);\n                        if (!processedPoints.has(pointKey)) {\n                            processedPoints.add(pointKey);\n                            intersections.push({\n                                point: point,\n                                parameter: t,\n                                surfaceParameters: projected\n                            });\n                        }\n                        break;\n                    }\n\n                    if (Math.abs(distance - lastDistance) < tolerance * 0.1) {\n                        break;\n                    }\n\n                    // Calculate tangent and normal for Newton step\n                    const tangent = curve.getTanget(t);\n                    const normal = surface.normalAt(projected.u, projected.v);\n                    \n                    if (!tangent || !normal) break;\n\n                    // Calculate Newton step\n                    const dotProduct = \n                        tangent[0] * normal.x + \n                        tangent[1] * normal.y + \n                        tangent[2] * normal.z;\n\n                    if (Math.abs(dotProduct) < 1e-10) break;\n\n                    const step = distance / dotProduct;\n                    const newT = t - step;\n\n                    if (newT < t0 || newT > t1) break;\n\n                    t = newT;\n                    lastDistance = distance;\n                    iteration++;\n                }\n            }\n        };\n\n        // Initial subdivision of curve\n        const tStep = 1.0 / numSamples;\n        for (let i = 0; i < numSamples; i++) {\n            const t0 = i * tStep;\n            const t1 = (i + 1) * tStep;\n            subdivideAndCheck(t0, t1);\n        }\n\n        // Sort intersections by curve parameter\n        return intersections.sort((a, b) => a.parameter - b.parameter);\n    }\n\n    // Helper method for curve-surface intersection\n    projectToSurface(point, surface, tolerance = 1e-8) {\n        const maxIterations = 20;\n        let u = 0.5;\n        let v = 0.5;\n\n        for (let i = 0; i < maxIterations; i++) {\n            const surfacePoint = surface.pointAt(u, v);\n            if (!surfacePoint) return null;\n\n            const distance = this.distance(point, surfacePoint);\n            if (distance < tolerance) {\n                return { u, v };\n            }\n\n            const normal = surface.normalAt(u, v);\n            if (!normal) return null;\n\n            // Calculate partial derivatives\n            const du = surface.derivativeU(u, v);\n            const dv = surface.derivativeV(u, v);\n            if (!du || !dv) return null;\n\n            // Form Jacobian matrix\n            const J = [\n                [du.x, dv.x],\n                [du.y, dv.y],\n                [du.z, dv.z]\n            ];\n\n            // Calculate difference vector\n            const diff = {\n                x: point.x - surfacePoint.x,\n                y: point.y - surfacePoint.y,\n                z: point.z - surfacePoint.z\n            };\n\n            // Solve linear system using pseudo-inverse\n            const JT = this.transpose(J);\n            const JTJ = this.multiply(JT, J);\n            const JTr = this.multiply(JT, [[diff.x], [diff.y], [diff.z]]);\n            \n            const det = JTJ[0][0] * JTJ[1][1] - JTJ[0][1] * JTJ[1][0];\n            if (Math.abs(det) < 1e-10) return null;\n\n            const deltaU = (JTJ[1][1] * JTr[0][0] - JTJ[0][1] * JTr[1][0]) / det;\n            const deltaV = (-JTJ[1][0] * JTr[0][0] + JTJ[0][0] * JTr[1][0]) / det;\n\n            u += deltaU;\n            v += deltaV;\n\n            // Clamp parameters to valid range\n            u = Math.max(0, Math.min(1, u));\n            v = Math.max(0, Math.min(1, v));\n        }\n\n        return null;\n    }\n\n    // Matrix operation helpers\n    transpose(matrix) {\n        return matrix[0].map((_, i) => matrix.map(row => row[i]));\n    }\n\n    multiply(a, b) {\n        return a.map(row => \n            b[0].map((_, j) => \n                row.reduce((sum, val, i) => sum + val * b[i][j], 0)\n            )\n        );\n    }\n}\n```",
      "hidden": false
    },
    {
      "role": "user",
      "content": "Perform action 7. NumericalIntegration.gaussianQuadrature",
      "hidden": false
    },
    {
      "role": "assistant",
      "content": "```javascript\nclass NumericalIntegration {\n    static gaussianQuadrature(func, a, b, n) {\n        if (n <= 0) {\n            throw new Error('Number of points must be positive.');\n        }\n\n        const points = NumericalIntegration.getGaussPointsAndWeights(n);\n        let integral = 0;\n\n        for (let i = 0; i < n; i++) {\n            const t = 0.5 * ((b - a) * points[i].x + (a + b));\n            integral += points[i].w * func(t) * (b - a) / 2;\n        }\n\n        return integral;\n    }\n\n    static getGaussPointsAndWeights(n) {\n        // Gauss-Legendre quadrature points and weights\n        const eps = 1e-15;  // Numerical tolerance\n        const points = [];\n\n        if (n === 1) {\n            points.push({ x: 0.0, w: 2.0 });\n            return points;\n        }\n\n        const m = Math.floor((n + 1) / 2);\n        \n        // Initial approximation of roots\n        for (let i = 0; i < m; i++) {\n            let x = Math.cos(Math.PI * (i + 0.75) / (n + 0.5));\n            let xOld;\n\n            // Newton's method refinement\n            do {\n                let p1 = 1.0;\n                let p2 = 0.0;\n\n                // Legendre polynomial evaluation\n                for (let j = 1; j <= n; j++) {\n                    const p3 = p2;\n                    p2 = p1;\n                    p1 = ((2.0 * j - 1.0) * x * p2 - (j - 1.0) * p3) / j;\n                }\n\n                // Derivative of Legendre polynomial\n                const dp = n * (x * p1 - p2) / (x * x - 1.0);\n                \n                xOld = x;\n                x = xOld - p1 / dp;  // Newton step\n\n            } while (Math.abs(x - xOld) > eps);\n\n            const weight = 2.0 / ((1.0 - x * x) * dp * dp);\n\n            // Store symmetric points and weights\n            points.push({ x: -x, w: weight });\n            if (i !== m - 1 || n % 2 === 0) {\n                points.push({ x: x, w: weight });\n            }\n        }\n\n        // Sort points by x-coordinate\n        points.sort((a, b) => a.x - b.x);\n\n        return points;\n    }\n\n    // Additional helper methods for higher-order integration\n    static adaptiveQuadrature(func, a, b, tolerance = 1e-8, maxDepth = 50) {\n        const adapt = (a, b, fa, fb, depth) => {\n            const h = (b - a) / 2;\n            const m = a + h;\n            const fm = func(m);\n            \n            const left = h * (fa + fm) / 2;\n            const right = h * (fm + fb) / 2;\n            const whole = (b - a) * (fa + 2 * fm + fb) / 4;\n            \n            if (depth >= maxDepth) {\n                return whole;\n            }\n            \n            if (Math.abs(left + right - whole) <= tolerance) {\n                return whole;\n            }\n            \n            return adapt(a, m, fa, fm, depth + 1) + \n                   adapt(m, b, fm, fb, depth + 1);\n        };\n\n        const fa = func(a);\n        const fb = func(b);\n        return adapt(a, b, fa, fb, 0);\n    }\n\n    static gaussKronrod(func, a, b, tolerance = 1e-8) {\n        // Gauss-Kronrod nodes for 15-point rule\n        const xgk = [\n            -0.991455371120813, -0.949107912342759, -0.864864423359769,\n            -0.741531185599394, -0.586087235467691, -0.405845151377397,\n            -0.207784955007898, 0.000000000000000, 0.207784955007898,\n            0.405845151377397, 0.586087235467691, 0.741531185599394,\n            0.864864423359769, 0.949107912342759, 0.991455371120813\n        ];\n\n        // Kronrod weights\n        const wgk = [\n            0.022935322010529, 0.063092092629979, 0.104790010322250,\n            0.140653259715525, 0.169004726639267, 0.190350578064785,\n            0.204432940075298, 0.209482141084728, 0.204432940075298,\n            0.190350578064785, 0.169004726639267, 0.140653259715525,\n            0.104790010322250, 0.063092092629979, 0.022935322010529\n        ];\n\n        let result = 0;\n        const center = 0.5 * (a + b);\n        const halfLength = 0.5 * (b - a);\n\n        for (let j = 0; j < 15; j++) {\n            const xj = center + halfLength * xgk[j];\n            result += wgk[j] * func(xj);\n        }\n\n        return result * halfLength;\n    }\n\n    static romberg(func, a, b, maxOrder = 10, tolerance = 1e-8) {\n        const R = Array(maxOrder).fill().map(() => Array(maxOrder).fill(0));\n        \n        // Initial trapezoid step\n        R[0][0] = 0.5 * (b - a) * (func(a) + func(b));\n        \n        for (let i = 1; i < maxOrder; i++) {\n            // Calculate R[i][0]\n            let sum = 0;\n            const h = (b - a) / Math.pow(2, i);\n            \n            for (let k = 1; k <= Math.pow(2, i - 1); k++) {\n                sum += func(a + (2 * k - 1) * h);\n            }\n            \n            R[i][0] = 0.5 * R[i - 1][0] + h * sum;\n            \n            // Calculate R[i][j] using Richardson extrapolation\n            for (let j = 1; j <= i; j++) {\n                const fourPowJ = Math.pow(4, j);\n                R[i][j] = (fourPowJ * R[i][j - 1] - R[i - 1][j - 1]) / (fourPowJ - 1);\n            }\n            \n            // Check for convergence\n            if (i > 0 && Math.abs(R[i][i] - R[i - 1][i - 1]) < tolerance) {\n                return R[i][i];\n            }\n        }\n        \n        return R[maxOrder - 1][maxOrder - 1];\n    }\n}\n```",
      "hidden": false
    }
  ],
  "title": "Geometric Modeling Classes and Implementation Review",
  "id": "20250110_114328468Z",
  "targetFile": "./brep.js",
  "chatMode": "chat",
  "conversationNew": false,
  "lastModified": "2025-01-10T11:48:41.137Z"
}