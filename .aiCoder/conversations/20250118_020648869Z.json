{
  "messages": [
    {
      "role": "system",
      "content": "./.aiCoder/prompts/default-system-prompt.md",
      "filePath": "./.aiCoder/prompts/default-system-prompt.md",
      "description": "",
      "hidden": true
    },
    {
      "role": "user",
      "content": "./.aiCoder/prompts/default-plan-prompt.md",
      "filePath": "./.aiCoder/prompts/default-plan-prompt.md",
      "description": "",
      "hidden": true
    },
    {
      "role": "user",
      "content": "./brep.js",
      "filePath": "./brep.js",
      "description": "// Code file to be edited",
      "hidden": true
    },
    {
      "role": "system",
      "content": "./.aiCoder/prompts/snippet-production-prompt.md",
      "filePath": "./.aiCoder/prompts/snippet-production-prompt.md",
      "description": "",
      "hidden": true
    },
    {
      "role": "user",
      "content": "Look at the BooleanOperation class. Determine if we are missing any edge cases that need to be handled.\n\nAddress the first problem you find.\n\nRemember to only produce code snippets that follow the formatting rules.\nYou can include an explanation with your snippet. \n\nonly modify a few methods at a time. ",
      "hidden": false
    },
    {
      "role": "assistant",
      "content": "```javascript\n class BooleanOperation {\n    constructor() {\n        this.vertices = [];\n    }\n   \n    union(solid1, solid2) {\n        if (!solid1 || !solid2) {\n            return null;\n        }\n         const solid1Copy = solid1.copy();\n        const solid2Copy = solid2.copy();\n        const allFaces1 = solid1Copy.getFaces();\n        const allFaces2 = solid2Copy.getFaces();\n        const intersections = [];\n        //check for self intersections in each solid\n         for (const face of allFaces1) {\n            if (this._hasSelfIntersections(face.getSurface())) {\n                console.warn('Self intersection detected in solid 1');\n                return null;\n            }\n        }\n        for (const face of allFaces2) {\n            if (this._hasSelfIntersections(face.getSurface())) {\n                console.warn('Self intersection detected in solid 2');\n                return null;\n            }\n        }\n        for (const face1 of allFaces1) {\n            for (const face2 of allFaces2) {\n                 const surface1 = face1.getSurface();\n                const surface2 = face2.getSurface();\n                  if (!surface1 || !surface2) {\n                    continue;\n                }\n                if (this._isCoincident(surface1, surface2)) {\n                     // if surfaces are coincident, we skip the intersection calculation\n                    // we should check if the faces are coplanar and if they are perform a boolean operation directly in 2d\n                    continue;\n                 }\n                const surfaceIntersections = this.findSurfaceIntersections(surface1, surface2);\n                if (surfaceIntersections && surfaceIntersections.length > 0) {\n                    intersections.push(...surfaceIntersections);\n                }\n            }\n        }\n        const allFaces = [\n            ...allFaces1,\n            ...allFaces2\n        ];\n        const trimmedFaces = [];\n        const trimmer = new SurfaceTrimmer();\n          for (const face of allFaces) {\n            let currentSurface = face.getSurface();\n              if (!currentSurface)\n                continue;\n            for (const intersection of intersections) {\n                const surface1 = intersection.getSurface1();\n                const surface2 = intersection.getSurface2();\n                if (surface1 === currentSurface) {\n                     const trimmedSurface = trimmer.trimSurface(currentSurface, intersection, false);\n                    if (trimmedSurface)\n                        currentSurface = trimmedSurface;\n\n                } else if (surface2 === currentSurface) {\n                    const trimmedSurface = trimmer.trimSurface(currentSurface, intersection, false);\n                     if (trimmedSurface)\n                        currentSurface = trimmedSurface;\n                }\n            }\n             if(currentSurface){\n                 const newFace = new Face(currentSurface,face.getOuterLoop(),face.getInnerLoops())\n                trimmedFaces.push(newFace);\n             }\n        }\n\n\n        const newSolid = new Solid();\n        const newShell = new Shell(trimmedFaces);\n        newSolid.addShell(newShell);\n        return newSolid;\n    }\n    \n    \n    intersect(solid1, solid2) {\n        if (!solid1 || !solid2) {\n            return null;\n        }\n         const solid1Copy = solid1.copy();\n        const solid2Copy = solid2.copy();\n        const allFaces1 = solid1Copy.getFaces();\n        const allFaces2 = solid2Copy.getFaces();\n        const intersections = [];\n\n        for (const face1 of allFaces1) {\n            for (const face2 of allFaces2) {\n                const surface1 = face1.getSurface();\n                const surface2 = face2.getSurface();\n                 if (!surface1 || !surface2 || this._isCoincident(surface1, surface2)) {\n                    continue;\n                }\n                const surfaceIntersections = this.findSurfaceIntersections(surface1, surface2);\n                  if (surfaceIntersections && surfaceIntersections.length > 0) {\n                    intersections.push(...surfaceIntersections);\n                }\n            }\n        }\n         const allFaces = [\n            ...allFaces1,\n            ...allFaces2\n        ];\n        const trimmedFaces = [];\n         const trimmer = new SurfaceTrimmer();\n\n        for (const face of allFaces) {\n            let currentSurface = face.getSurface();\n             if (!currentSurface)\n                continue;\n            for (const intersection of intersections) {\n                const surface1 = intersection.getSurface1();\n                const surface2 = intersection.getSurface2();\n                if (surface1 === currentSurface) {\n                     const trimmedSurface = trimmer.trimSurface(currentSurface, intersection, true);\n                      if (trimmedSurface)\n                        currentSurface = trimmedSurface;\n                 } else if (surface2 === currentSurface) {\n                     const trimmedSurface = trimmer.trimSurface(currentSurface, intersection, true);\n                      if (trimmedSurface)\n                        currentSurface = trimmedSurface;\n                 }\n            }\n             if(currentSurface){\n                 const newFace = new Face(currentSurface,face.getOuterLoop(),face.getInnerLoops())\n                trimmedFaces.push(newFace);\n             }\n        }\n\n        const newSolid = new Solid();\n        const newShell = new Shell(trimmedFaces);\n        newSolid.addShell(newShell);\n        return newSolid;\n    }\n    \n      subtract(solid1, solid2) {\n        if (!solid1 || !solid2) {\n            return null;\n        }\n         const solid1Copy = solid1.copy();\n        const solid2Copy = solid2.copy();\n        const allFaces1 = solid1Copy.getFaces();\n        const allFaces2 = solid2Copy.getFaces();\n         const intersections = [];\n\n        for (const face1 of allFaces1) {\n            for (const face2 of allFaces2) {\n                const surface1 = face1.getSurface();\n                const surface2 = face2.getSurface();\n                 if (!surface1 || !surface2 || this._isCoincident(surface1, surface2)) {\n                    continue;\n                }\n                const surfaceIntersections = this.findSurfaceIntersections(surface1, surface2);\n                if (surfaceIntersections && surfaceIntersections.length > 0) {\n                    intersections.push(...surfaceIntersections);\n                }\n            }\n        }\n           const allFaces = [\n            ...allFaces1,\n            ...allFaces2\n        ];\n        const trimmedFaces = [];\n         const trimmer = new SurfaceTrimmer();\n        for (const face of allFaces) {\n            let currentSurface = face.getSurface();\n             if (!currentSurface)\n                continue;\n            for (const intersection of intersections) {\n                const surface1 = intersection.getSurface1();\n                const surface2 = intersection.getSurface2();\n\n                   if(allFaces1.includes(face) && surface1 === currentSurface)\n                  {\n                      const trimmedSurface = trimmer.trimSurface(currentSurface, intersection, true);\n                      if (trimmedSurface)\n                        currentSurface = trimmedSurface;\n                  }else if(allFaces2.includes(face) && surface2 === currentSurface)\n                  {\n                       const trimmedSurface = trimmer.trimSurface(currentSurface, intersection, false);\n                      if (trimmedSurface)\n                        currentSurface = trimmedSurface;\n                  }\n            }\n             if(currentSurface){\n                 const newFace = new Face(currentSurface,face.getOuterLoop(),face.getInnerLoops())\n                trimmedFaces.push(newFace);\n             }\n        }\n\n        const newSolid = new Solid();\n        const newShell = new Shell(trimmedFaces);\n        newSolid.addShell(newShell);\n        return newSolid;\n    }\n    \n    findSurfaceIntersections(surface1, surface2) {\n        if (!surface1 || !surface2) {\n            return null;\n        }\n        \n         const initialCurves = this._approximateIntersections(surface1, surface2);\n        if (!initialCurves || initialCurves.length === 0) {\n            return [];\n        }\n       \n          const refinedCurves = this._refineIntersections(surface1, surface2, initialCurves);\n           if (!refinedCurves || refinedCurves.length === 0) {\n            return [];\n        }\n        \n         const intersections = refinedCurves.map(curve => new Intersection(curve, surface1, surface2));\n        return intersections;\n    }\n    \n   \n  _findSurfaceIntersections(surface1, surface2) {\n        if (!surface1 || !surface2) {\n            return null;\n        }\n         const initialCurves = this._approximateIntersections(surface1, surface2);\n        if (!initialCurves || initialCurves.length === 0) {\n            return [];\n        }\n        \n        const refinedCurves = this._refineIntersections(surface1, surface2, initialCurves);\n           if (!refinedCurves || refinedCurves.length === 0) {\n            return [];\n        }\n        \n         const intersections = refinedCurves.map(curve => new Intersection(curve, surface1, surface2));\n        return intersections;\n    }\n     _approximateIntersections(surface1, surface2) {\n         if (!surface1 || !surface2) {\n            return null;\n        }\n        const uMin1 = surface1.getKnotsU()[0];\n        const uMax1 = surface1.getKnotsU()[surface1.getKnotsU().length - 1];\n        const vMin1 = surface1.getKnotsV()[0];\n        const vMax1 = surface1.getKnotsV()[surface1.getKnotsV().length - 1];\n\n        const uMin2 = surface2.getKnotsU()[0];\n        const uMax2 = surface2.getKnotsU()[surface2.getKnotsU().length - 1];\n        const vMin2 = surface2.getKnotsV()[0];\n        const vMax2 = surface2.getKnotsV()[surface2.getKnotsV().length - 1];\n        \n        const initialCurves = [];\n        this._recursiveSubdivision(surface1, surface2, uMin1, uMax1, vMin1, vMax1, uMin2, uMax2, vMin2, vMax2, initialCurves, 0);\n        return initialCurves;\n\n    }\n     _refineIntersections(surface1, surface2, initialCurves) {\n         if (!surface1 || !surface2 || !initialCurves || initialCurves.length === 0) {\n            return null;\n        }\n          const refinedCurves = [];\n        const tolerance = 0.001;\n        const maxIterations = 20;\n          for (const initialCurve of initialCurves) {\n            const refinedPoints = [];\n                for (const initialPoint of initialCurve) {\n                    const refinedPoint = this._refineIntersectionPoint(surface1, surface2, initialPoint, tolerance, maxIterations);\n                      if (refinedPoint) {\n                        refinedPoints.push(refinedPoint);\n                    }\n                }\n             if (refinedPoints.length > 1) {\n                const controlPoints = refinedPoints.map(point => surface1.evaluate(point.u1, point.v1));\n                 if(controlPoints && controlPoints.length > 1){\n                     const degree = 3;\n                     const knots = this._createUniformKnotVector(controlPoints.length, degree);\n                     const weights = Array(controlPoints.length).fill(1);\n                     const nurbsCurve = new NurbsCurve(degree, controlPoints, knots, weights);\n                     refinedCurves.push(nurbsCurve);\n                 }\n             }\n            }\n        return refinedCurves;\n    }\n    \n    _refineIntersectionPoint(surface1, surface2, initialPoint, tolerance, maxIterations) {\n        let u1 = initialPoint.u1;\n        let v1 = initialPoint.v1;\n        let u2 = initialPoint.u2;\n        let v2 = initialPoint.v2;\n\n\n        for (let i = 0; i < maxIterations; i++) {\n            const p1 = surface1.evaluate(u1, v1);\n            const p2 = surface2.evaluate(u2, v2);\n\n             if (!p1 || !p2) {\n                return null;\n            }\n            const diff = new Vector3D(p2.getX() - p1.getX(), p2.getY() - p1.getY(), p2.getZ() - p1.getZ());\n            if (diff.magnitude() < tolerance) {\n                return { u1: u1, v1: v1, u2: u2, v2: v2 };\n            }\n\n\n            const jacobian = this._calculateJacobianForIntersection(surface1, surface2, u1, v1, u2, v2);\n            if (!jacobian) {\n                return null;\n            }\n           const invJacobian = this._inverse4x4(jacobian);\n           if(!invJacobian){\n               return null;\n           }\n            const deltaU1 = invJacobian[0][0] * diff.getX() + invJacobian[0][1] * diff.getY() + invJacobian[0][2] * diff.getZ();\n            const deltaV1 = invJacobian[1][0] * diff.getX() + invJacobian[1][1] * diff.getY() + invJacobian[1][2] * diff.getZ();\n            const deltaU2 = invJacobian[2][0] * diff.getX() + invJacobian[2][1] * diff.getY() + invJacobian[2][2] * diff.getZ();\n             const deltaV2= invJacobian[3][0] * diff.getX() + invJacobian[3][1] * diff.getY() + invJacobian[3][2] * diff.getZ();\n            \n\n            u1 -= deltaU1;\n            v1 -= deltaV1;\n            u2 -= deltaU2;\n            v2 -= deltaV2;\n             const uMin1 = surface1.getKnotsU()[0];\n             const uMax1 = surface1.getKnotsU()[surface1.getKnotsU().length - 1];\n            const vMin1 = surface1.getKnotsV()[0];\n             const vMax1 = surface1.getKnotsV()[surface1.getKnotsV().length - 1];\n\n            const uMin2 = surface2.getKnotsU()[0];\n            const uMax2 = surface2.getKnotsU()[surface2.getKnotsU().length - 1];\n            const vMin2 = surface2.getKnotsV()[0];\n            const vMax2 = surface2.getKnotsV()[surface2.getKnotsV().length - 1];\n            \n            u1 = Math.max(uMin1, Math.min(u1, uMax1));\n            v1 = Math.max(vMin1, Math.min(v1, vMax1));\n            u2 = Math.max(uMin2, Math.min(u2, uMax2));\n            v2 = Math.max(vMin2, Math.min(v2, vMax2));\n        }\n        return null;\n    }\n    \n    _calculateJacobian(surface, u, v) {\n        const du = surface.evaluatePartialDerivative(u, v, 1, 0);\n        const dv = surface.evaluatePartialDerivative(u, v, 0, 1);\n\n        if (!du || !dv) {\n            return null;\n        }\n\n\n        return [\n            [du.getX(), du.getY(), du.getZ()],\n            [dv.getX(), dv.getY(), dv.getZ()]\n        ];\n    }\n    _createUniformKnotVector(numPoints, degree) {\n        if (numPoints <= degree + 1) {\n            return null;\n        }\n        const knots = [];\n        for (let i = 0; i <= degree; i++) {\n            knots.push(0);\n        }\n        for (let i = 1; i <= numPoints - degree - 1; i++) {\n            knots.push(i);\n        }\n        for (let i = 0; i <= degree; i++) {\n            knots.push(numPoints - degree - 1);\n        }\n        return knots;\n    }\n    \n    \n     _createEdgesFromIntersection(intersection, face1, face2) {\n         if (!intersection || !face1 || !face2) {\n            return null;\n        }\n        const curve = intersection.getCurve();\n\n        if (!curve || curve.getControlPoints().length < 2) {\n            return [];\n        }\n\n        const numSamples = 50;\n        const start = curve.getKnots()[0];\n        const end = curve.getKnots()[curve.getKnots().length - 1];\n        const step = (end - start) / numSamples;\n        const points = [];\n         for (let i = 0; i <= numSamples; i++) {\n            const u = start + i * step;\n            const point = curve.evaluate(u);\n              if (point) {\n                points.push(point);\n            }\n        }\n         if (points.length < 2) {\n            return [];\n        }\n         const edges = [];\n        for (let i = 0; i < points.length - 1; i++) {\n            const startPoint = points[i];\n            const endPoint = points[i+1];\n\n            const startVertex = this._findOrCreateVertex(startPoint);\n            const endVertex = this._findOrCreateVertex(endPoint);\n             if(startVertex === endVertex){\n                 continue;\n             }\n             const edgeCurve = new NurbsCurve(curve.getDegree(), [startPoint, endPoint], [0,1], [1,1]);\n              const edge = new Edge(startVertex, endVertex, edgeCurve);\n            edges.push(edge);\n        }\n\n        return edges;\n    }\n    _findOrCreateVertex(point) {\n        if (!this.vertices) {\n            this.vertices = [];\n        }\n        for (const vertex of this.vertices) {\n            if (vertex.getPoint().distanceTo(point) < 0.001) {\n                return vertex;\n            }\n        }\n        const newVertex = new Vertex(point);\n        this.vertices.push(newVertex);\n        return newVertex;\n    }\n    \n       _createLoopsFromEdges(edges) {\n         if (!edges || edges.length === 0) {\n            return [];\n        }\n         const loops = [];\n        let remainingEdges = [...edges];\n\n        while (remainingEdges.length > 0) {\n            const currentEdge = remainingEdges.shift();\n            const currentLoop = new Loop([currentEdge]);\n            let currentVertex = currentEdge.getEndVertex();\n             let loopComplete = false;\n              while (!loopComplete) {\n                    let nextEdgeIndex = -1;\n                 for(let i = 0; i< remainingEdges.length; i++){\n                     if(remainingEdges[i].getStartVertex() === currentVertex){\n                          nextEdgeIndex = i;\n                         break;\n                     }\n                 }\n                  if (nextEdgeIndex !== -1) {\n                    const nextEdge = remainingEdges.splice(nextEdgeIndex, 1)[0];\n                    currentLoop.addEdge(nextEdge);\n                     currentVertex = nextEdge.getEndVertex();\n                  } else {\n                        loopComplete = true;\n                    }\n                     if(currentLoop.isClosed()){\n                       loopComplete = true;\n                     }\n              }\n            loops.push(currentLoop);\n        }\n\n        return loops;\n    }\n    \n    \n    _isCoincident(surface1, surface2) {\n         if (!surface1 || !surface2) {\n            return false;\n        }\n        const uMin1 = surface1.getKnotsU()[0];\n        const uMax1 = surface1.getKnotsU()[surface1.getKnotsU().length - 1];\n        const vMin1 = surface1.getKnotsV()[0];\n        const vMax1 = surface1.getKnotsV()[surface1.getKnotsV().length - 1];\n\n        const uMin2 = surface2.getKnotsU()[0];\n        const uMax2 = surface2.getKnotsU()[surface2.getKnotsU().length - 1];\n        const vMin2 = surface2.getKnotsV()[0];\n        const vMax2 = surface2.getKnotsV()[surface2.getKnotsV().length - 1];\n        \n          //check for overlapping parameter domains\n          if (uMax1 < uMin2 || uMin1 > uMax2 || vMax1 < vMin2 || vMin1 > vMax2) {\n                return false;\n            }\n          const numSamplesU = 10;\n        const numSamplesV = 10;\n         const deltaU1 = (uMax1 - uMin1) / numSamplesU;\n        const deltaV1 = (vMax1 - vMin1) / numSamplesV;\n         const tolerance = 0.001;\n        for (let i = 0; i <= numSamplesU; i++) {\n            for (let j = 0; j <= numSamplesV; j++) {\n                 const u1 = uMin1 + i * deltaU1;\n                const v1 = vMin1 + j * deltaV1;\n                 const u2 = uMin2 + i * deltaU1;\n                const v2 = vMin2 + j * deltaV1;\n                  const point1 = surface1.evaluate(u1, v1);\n                 const point2 = surface2.evaluate(u2,v2);\n                  if(!point1 || !point2)\n                  {\n                      continue;\n                  }\n                    const dist = point1.distanceTo(point2);\n                if (dist > tolerance) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    \n      _isTangentIntersection(intersection, surface1, surface2) {\n         if (!intersection || !surface1 || !surface2) {\n            return false;\n        }\n           const curve = intersection.getCurve();\n           if(!curve){\n               return false;\n           }\n        const numSamples = 10;\n        const start = curve.getKnots()[0];\n        const end = curve.getKnots()[curve.getKnots().length - 1];\n        const step = (end - start) / numSamples;\n          for (let i = 0; i <= numSamples; i++) {\n            const u = start + i * step;\n            const point = curve.evaluate(u);\n               if(!point)\n                   continue;\n            const uv1 = this._findUVOnSurface(surface1, point);\n            const uv2 = this._findUVOnSurface(surface2, point);\n                if(!uv1 || !uv2)\n                    continue;\n              const normal1 = surface1.normal(uv1.u, uv1.v);\n                const normal2 = surface2.normal(uv2.u, uv2.v);\n                if(!normal1 || !normal2)\n                    continue;\n              const dotProduct = normal1.dot(normal2);\n                 if(Math.abs(dotProduct) > 0.99){\n                     return true;\n                 }\n\n        }\n        return false;\n    }\n    \n    \n    _recursiveSubdivision(surface1, surface2, uMin1, uMax1, vMin1, vMax1, uMin2, uMax2, vMin2, vMax2, initialCurves, depth) {\n          const maxDepth = 5;\n        if (depth > maxDepth) {\n            return;\n        }\n        const uMid1 = (uMin1 + uMax1) / 2;\n        const vMid1 = (vMin1 + vMax1) / 2;\n        const uMid2 = (uMin2 + uMax2) / 2;\n        const vMid2 = (vMin2 + vMax2) / 2;\n        const p1Min = surface1.evaluate(uMin1, vMin1);\n        const p1Max = surface1.evaluate(uMax1, vMax1);\n        const p1Mid = surface1.evaluate(uMid1, vMid1);\n          const p2Min = surface2.evaluate(uMin2, vMin2);\n         const p2Max = surface2.evaluate(uMax2, vMax2);\n        const p2Mid = surface2.evaluate(uMid2, vMid2);\n          if(!p1Min || !p1Max || !p1Mid || !p2Min || !p2Max || !p2Mid)\n              return;\n        const distMin = p1Min.distanceTo(p2Min);\n        const distMax = p1Max.distanceTo(p2Max);\n         const distMid = p1Mid.distanceTo(p2Mid);\n        const threshold = 0.1;\n        if (distMin < threshold && distMax < threshold && distMid < threshold) {\n            initialCurves.push([{ u1: uMid1, v1: vMid1, u2: uMid2, v2: vMid2 }]);\n            return;\n        }\n         this._recursiveSubdivision(surface1, surface2, uMin1, uMid1, vMin1, vMid1, uMin2, uMid2, vMin2, vMid2, initialCurves, depth + 1);\n        this._recursiveSubdivision(surface1, surface2, uMid1, uMax1, vMin1, vMid1, uMid2, uMax2, vMin2, vMid2, initialCurves, depth + 1);\n        this._recursiveSubdivision(surface1, surface2, uMin1, uMid1, vMid1, vMax1, uMin2, uMid2, vMid2, vMax2, initialCurves, depth + 1);\n         this._recursiveSubdivision(surface1, surface2, uMid1, uMax1, vMid1, vMax1, uMid2, uMax2, vMid2, vMax2, initialCurves, depth + 1);\n    }\n\n    _isFaceInside(surface1, surface2){\n      if(!surface1 || !surface2){\n          return false;\n      }\n        const numSamplesU = 5;\n        const numSamplesV = 5;\n        const uMin1 = surface1.getKnotsU()[0];\n        const uMax1 = surface1.getKnotsU()[surface1.getKnotsU().length - 1];\n        const vMin1 = surface1.getKnotsV()[0];\n        const vMax1 = surface1.getKnotsV()[surface1.getKnotsV().length - 1];\n\n        const uStep1 = (uMax1 - uMin1) / numSamplesU;\n        const vStep1 = (vMax1 - vMin1) / numSamplesV;\n\n        let allInside = true;\n          const trimmer = new SurfaceTrimmer();\n        for (let i = 0; i <= numSamplesU; i++) {\n            for (let j = 0; j <= numSamplesV; j++) {\n                const u1 = uMin1 + i * uStep1;\n                const v1 = vMin1 + j * vStep1;\n                  const point1 = surface1.evaluate(u1, v1);\n                  if(point1){\n                      if(!trimmer.isPointInside(surface2,point1)){\n                         allInside = false;\n                      }\n                  }\n            }\n        }\n        return allInside;\n    }\n    \n    _hasSelfIntersections(surface) {\n          if(!surface){\n              return false;\n          }\n          const uMin = surface.getKnotsU()[0];\n        const uMax = surface.getKnotsU()[surface.getKnotsU().length - 1];\n        const vMin = surface.getKnotsV()[0];\n        const vMax = surface.getKnotsV()[surface.getKnotsV().length - 1];\n        \n          const numSamplesU = 20;\n        const numSamplesV = 20;\n        const uStep = (uMax - uMin) / numSamplesU;\n        const vStep = (vMax - vMin) / numSamplesV;\n        const points = [];\n\n        for (let i = 0; i <= numSamplesU; i++) {\n            for (let j = 0; j <= numSamplesV; j++) {\n                const u = uMin + i * uStep;\n                const v = vMin + j * vStep;\n                const point = surface.evaluate(u, v);\n                if(point)\n                    points.push({u,v,point});\n            }\n        }\n         for (let i = 0; i < points.length; i++) {\n              for (let j = i+1; j < points.length; j++) {\n                    const point1 = points[i].point;\n                    const point2 = points[j].point;\n                     const dist = point1.distanceTo(point2);\n                  if(dist < 0.001){\n                      const u1 = points[i].u;\n                      const v1 = points[i].v;\n                       const u2 = points[j].u;\n                      const v2 = points[j].v;\n                      if(Math.abs(u1-u2) > 0.001 || Math.abs(v1-v2) > 0.001){\n                          return true;\n                      }\n                  }\n              }\n         }\n         return false;\n    }\n    _isCurveOnBoundary(curve, surface) {\n        if (!curve || !surface) {\n            return false;\n        }\n          const numSamples = 50;\n        const start = curve.getKnots()[0];\n        const end = curve.getKnots()[curve.getKnots().length - 1];\n        const step = (end - start) / numSamples;\n       for (let i = 0; i <= numSamples; i++) {\n            const u = start + i * step;\n            const point = curve.evaluate(u);\n            if(!point)\n                continue;\n              const uv = this._findUVOnSurface(surface, point);\n               if(!uv)\n                    return false;\n              const uMin = surface.getKnotsU()[0];\n             const uMax = surface.getKnotsU()[surface.getKnotsU().length - 1];\n             const vMin = surface.getKnotsV()[0];\n              const vMax = surface.getKnotsV()[surface.getKnotsV().length - 1];\n             const tolerance = 0.001;\n              if (Math.abs(uv.u - uMin) < tolerance || Math.abs(uv.u - uMax) < tolerance ||\n                Math.abs(uv.v - vMin) < tolerance || Math.abs(uv.v - vMax) < tolerance)\n               {\n                 continue;\n              }else{\n                return false;\n              }\n\n       }\n        return true;\n    }\n\n     _levenbergMarquardtRefinement(surface1, surface2, initialPoint, tolerance, maxIterations) {\n        let u1 = initialPoint.u1;\n        let v1 = initialPoint.v1;\n        let u2 = initialPoint.u2;\n        let v2 = initialPoint.v2;\n        let lambda = 0.01;\n        const dampingFactor = 10;\n        for (let i = 0; i < maxIterations; i++) {\n            const p1 = surface1.evaluate(u1, v1);\n            const p2 = surface2.evaluate(u2, v2);\n            if (!p1 || !p2) {\n                return null;\n            }\n            const diff = new Vector3D(p2.getX() - p1.getX(), p2.getY() - p1.getY(), p2.getZ() - p1.getZ());\n            if (diff.magnitude() < tolerance) {\n                 return { u1: u1, v1: v1, u2: u2, v2: v2 };\n            }\n\n              const jacobian = this._calculateJacobianForIntersection(surface1, surface2, u1, v1, u2, v2);\n             if (!jacobian) {\n                return null;\n            }\n            const JtJ = this._transposeMultiply(jacobian, jacobian);\n            const JtDiff = this._transposeMultiply(jacobian, [[diff.getX()],[diff.getY()],[diff.getZ()]]);\n            if(!JtJ || !JtDiff)\n            {\n                return null;\n            }\n            const augmentedJtJ = this._augmentMatrix(JtJ,lambda);\n              const delta = this._solveLinearSystem(augmentedJtJ, JtDiff);\n              if(!delta){\n                  lambda *= dampingFactor;\n                 continue;\n              }\n             u1 -= delta[0][0];\n             v1 -= delta[1][0];\n            u2 -= delta[2][0];\n             v2 -= delta[3][0];\n           const uMin1 = surface1.getKnotsU()[0];\n             const uMax1 = surface1.getKnotsU()[surface1.getKnotsU().length - 1];\n            const vMin1 = surface1.getKnotsV()[0];\n             const vMax1 = surface1.getKnotsV()[surface1.getKnotsV().length - 1];\n\n            const uMin2 = surface2.getKnotsU()[0];\n            const uMax2 = surface2.getKnotsU()[surface2.getKnotsU().length - 1];\n            const vMin2 = surface2.getKnotsV()[0];\n            const vMax2 = surface2.getKnotsV()[surface2.getKnotsV().length - 1];\n\n           u1 = Math.max(uMin1, Math.min(u1, uMax1));\n           v1 = Math.max(vMin1, Math.min(v1, vMax1));\n           u2 = Math.max(uMin2, Math.min(u2, uMax2));\n           v2 = Math.max(vMin2, Math.min(v2, vMax2));\n            if(isNaN(u1) || isNaN(v1) || isNaN(u2) || isNaN(v2))\n            {\n                return null;\n            }\n             if(delta[0][0] === 0 && delta[1][0] === 0 && delta[2][0] === 0 && delta[3][0] === 0)\n             {\n                  lambda *= 0.1;\n             }else{\n                 lambda *= 0.1;\n             }\n             if(lambda < 1e-10)\n             {\n                 lambda = 1e-10;",
      "hidden": false
    }
  ],
  "title": "Refining NURBS Boolean Operations",
  "id": "20250118_020648869Z",
  "targetFile": "./brep.js",
  "chatMode": "chat",
  "conversationNew": false,
  "lastModified": "2025-01-18T02:07:50.023Z"
}