{
  "messages": [
    {
      "role": "system",
      "content": "./.aiCoder/prompts/default-system-prompt.md",
      "filePath": "./.aiCoder/prompts/default-system-prompt.md",
      "description": "",
      "hidden": true
    },
    {
      "role": "user",
      "content": "./.aiCoder/prompts/default-plan-prompt.md",
      "filePath": "./.aiCoder/prompts/default-plan-prompt.md",
      "description": "",
      "hidden": true
    },
    {
      "role": "user",
      "content": "./brep.js",
      "filePath": "./brep.js",
      "description": "// Code file to be edited",
      "hidden": true
    },
    {
      "role": "system",
      "content": "./.aiCoder/prompts/snippet-production-prompt.md",
      "filePath": "./.aiCoder/prompts/snippet-production-prompt.md",
      "description": "",
      "hidden": true
    },
    {
      "role": "user",
      "content": "Look at the BooleanOperation class. Determine if we are missing any edge cases that need to be handled.\n\nAddress the first problem you find.\n\nRemember to only produce code snippets that follow the formatting rules.\nYou can include an explanation with your snippet. \n\nonly modify a few methods at a time. ",
      "hidden": false
    },
    {
      "role": "assistant",
      "content": "```javascript\nclass BooleanOperation {\n    constructor() {\n        this.vertices = [];\n    }\n    union(solid1, solid2) {\n        if (!solid1 || !solid2) {\n            return null;\n        }\n        const solid1Copy = solid1.copy();\n        const solid2Copy = solid2.copy();\n        const allFaces1 = solid1Copy.getFaces();\n        const allFaces2 = solid2Copy.getFaces();\n        let intersections = [];\n        //check for self intersections in each solid\n        for (const face of allFaces1) {\n            if (this._hasSelfIntersections(face.getSurface())) {\n                console.warn('Self intersection detected in solid 1');\n                return null;\n            }\n        }\n        for (const face of allFaces2) {\n            if (this._hasSelfIntersections(face.getSurface())) {\n                console.warn('Self intersection detected in solid 2');\n                return null;\n            }\n        }\n        for (const face1 of allFaces1) {\n            for (const face2 of allFaces2) {\n                const surface1 = face1.getSurface();\n                const surface2 = face2.getSurface();\n                if (!surface1 || !surface2) {\n                    continue;\n                }\n                if (this._isCoplanar(surface1, surface2)) {\n                   const trimmedSurface = this._handleCoplanarFaces(face1, face2, true);\n                    if (trimmedSurface) {\n                         const newFace = new Face(trimmedSurface, face1.getOuterLoop(), face1.getInnerLoops());\n                        intersections.push(newFace);\n                    }\n                    continue;\n                }\n                const surfaceIntersections = this.findSurfaceIntersections(surface1, surface2);\n                if (surfaceIntersections && surfaceIntersections.length > 0) {\n                    for (const intersection of surfaceIntersections) {\n                         if (!this._isCurveOnBoundary(intersection.getCurve(), surface1) && !this._isCurveOnBoundary(intersection.getCurve(), surface2)) {\n                            intersections.push(intersection);\n                        }\n                    }\n                }\n            }\n        }\n          // Handle cases where there are no intersections\n        if (intersections.length === 0) {\n            if (this._isSolidInside(solid1Copy, solid2Copy)) {\n                return solid2Copy;\n            } else if (this._isSolidInside(solid2Copy, solid1Copy)) {\n                return solid1Copy;\n            } else {\n                const newSolid = new Solid();\n                const allFaces = [\n                    ...allFaces1,\n                    ...allFaces2\n                ];\n                const newShell = new Shell(allFaces);\n                newSolid.addShell(newShell);\n                return newSolid;\n            }\n        }\n        let allFaces = [\n            ...allFaces1,\n            ...allFaces2\n        ];\n        const trimmer = new SurfaceTrimmer();\n         // Split surfaces based on intersections\n        for (const intersection of intersections) {\n             if (intersection instanceof Face) continue;\n            const surface1 = intersection.getSurface1();\n            const surface2 = intersection.getSurface2();\n             allFaces = allFaces.reduce((acc, face) => {\n                const surface = face.getSurface();\n                if (surface === surface1 || surface === surface2) {\n                    const splitSurfaces = trimmer.splitSurface(surface, intersection);\n                     if (splitSurfaces && splitSurfaces.length > 0) {\n                        splitSurfaces.forEach(splitSurface => {\n                            acc.push(new Face(splitSurface, face.getOuterLoop(), face.getInnerLoops()));\n                        });\n                    } else {\n                        acc.push(face);\n                    }\n                } else {\n                    acc.push(face);\n                }\n                 return acc;\n            }, []);\n        }\n\n        //remove any faces that have a surface with zero area\n         allFaces = allFaces.filter(face => {\n            const surface = face.getSurface();\n            if(!surface) return false;\n            const uMin = surface.getKnotsU()[0];\n            const uMax = surface.getKnotsU()[surface.getKnotsU().length - 1];\n            const vMin = surface.getKnotsV()[0];\n            const vMax = surface.getKnotsV()[surface.getKnotsV().length - 1];\n\n             const area = (uMax - uMin) * (vMax - vMin)\n            if(area <= 0){\n                return false;\n            }\n             return true;\n        })\n\n        const newSolid = new Solid();\n        const newShell = new Shell(allFaces);\n        newSolid.addShell(newShell);\n        return newSolid;\n    }\n    intersect(solid1, solid2) {\n       if (!solid1 || !solid2) {\n            return null;\n        }\n        const solid1Copy = solid1.copy();\n        const solid2Copy = solid2.copy();\n        const allFaces1 = solid1Copy.getFaces();\n        const allFaces2 = solid2Copy.getFaces();\n        const intersections = [];\n        for (const face1 of allFaces1) {\n            for (const face2 of allFaces2) {\n                const surface1 = face1.getSurface();\n                const surface2 = face2.getSurface();\n                 if (!surface1 || !surface2) {\n                    continue;\n                }\n                if (this._isCoplanar(surface1, surface2)) {\n                     const trimmedSurface = this._handleCoplanarFaces(face1, face2, true);\n                    if (trimmedSurface) {\n                        const newFace = new Face(trimmedSurface, face1.getOuterLoop(), face1.getInnerLoops());\n                        intersections.push(newFace);\n                    }\n                    continue;\n                }\n                const surfaceIntersections = this.findSurfaceIntersections(surface1, surface2);\n                if (surfaceIntersections && surfaceIntersections.length > 0) {\n                   intersections.push(...surfaceIntersections);\n                }\n            }\n        }\n        const allFaces = [\n            ...allFaces1,\n            ...allFaces2\n        ];\n        let trimmedFaces = [];\n        const trimmer = new SurfaceTrimmer();\n         for (const face of allFaces) {\n              let currentSurface = face.getSurface();\n                if(!currentSurface) continue;\n               let splitFaces = [face];\n             for (const intersection of intersections) {\n                   if (intersection instanceof Face) {\n                       if(intersection.getSurface() === currentSurface){\n                            splitFaces = [intersection];\n                           currentSurface = null;\n                           break;\n                       }\n                        continue;\n                   }\n                const surface1 = intersection.getSurface1();\n                const surface2 = intersection.getSurface2();\n                if (surface1 === currentSurface) {\n                      let newSplitFaces = [];\n                      for(const splitFace of splitFaces){\n                            const splitSurfaces = trimmer.splitSurface(splitFace.getSurface(), intersection);\n                         if (splitSurfaces && splitSurfaces.length > 0) {\n                                splitSurfaces.forEach(splitSurface => {\n                                    newSplitFaces.push(new Face(splitSurface, splitFace.getOuterLoop(), splitFace.getInnerLoops()));\n                                });\n                            } else {\n                                newSplitFaces.push(splitFace);\n                            }\n                      }\n                      splitFaces = newSplitFaces;\n                    if(splitFaces.length > 0)\n                    currentSurface = splitFaces[0].getSurface();\n                    else currentSurface = null;\n\n                } else if (surface2 === currentSurface) {\n                      let newSplitFaces = [];\n                      for(const splitFace of splitFaces){\n                         const splitSurfaces = trimmer.splitSurface(splitFace.getSurface(), intersection);\n                        if (splitSurfaces && splitSurfaces.length > 0) {\n                                splitSurfaces.forEach(splitSurface => {\n                                    newSplitFaces.push(new Face(splitSurface, splitFace.getOuterLoop(), splitFace.getInnerLoops()));\n                                });\n                            } else {\n                                newSplitFaces.push(splitFace);\n                            }\n                      }\n                       splitFaces = newSplitFaces;\n                       if(splitFaces.length > 0)\n                           currentSurface = splitFaces[0].getSurface();\n                    else currentSurface = null;\n                }\n            }\n              if(splitFaces && splitFaces.length > 0){\n                  trimmedFaces.push(...splitFaces)\n              }\n        }\n        const newSolid = new Solid();\n        const newShell = new Shell(trimmedFaces);\n        newSolid.addShell(newShell);\n        return newSolid;\n    }\n    subtract(solid1, solid2) {\n        if (!solid1 || !solid2) {\n            return null;\n        }\n        const solid1Copy = solid1.copy();\n        const solid2Copy = solid2.copy();\n        const allFaces1 = solid1Copy.getFaces();\n        const allFaces2 = solid2Copy.getFaces();\n          const intersections = [];\n        for (const face1 of allFaces1) {\n            for (const face2 of allFaces2) {\n                const surface1 = face1.getSurface();\n                const surface2 = face2.getSurface();\n                 if (!surface1 || !surface2) {\n                    continue;\n                }\n                 if (this._isCoplanar(surface1, surface2)) {\n                    const trimmedSurface = this._handleCoplanarFaces(face1, face2, false);\n                    if (trimmedSurface) {\n                         const newFace = new Face(trimmedSurface, face1.getOuterLoop(), face1.getInnerLoops());\n                        intersections.push(newFace);\n                    }\n                     continue;\n                }\n                const surfaceIntersections = this.findSurfaceIntersections(surface1, surface2);\n                if (surfaceIntersections && surfaceIntersections.length > 0) {\n                   intersections.push(...surfaceIntersections);\n                }\n            }\n        }\n          const allFaces = [\n            ...allFaces1,\n            ...allFaces2\n        ];\n          let trimmedFaces = [];\n         const trimmer = new SurfaceTrimmer();\n        for (const face of allFaces) {\n             let currentSurface = face.getSurface();\n                if(!currentSurface) continue;\n                let splitFaces = [face];\n              for (const intersection of intersections) {\n                   if (intersection instanceof Face) {\n                       if(intersection.getSurface() === currentSurface){\n                            splitFaces = [intersection];\n                           currentSurface = null;\n                           break;\n                       }\n                        continue;\n                   }\n                const surface1 = intersection.getSurface1();\n                const surface2 = intersection.getSurface2();\n\n                if (allFaces1.includes(face) && surface1 === currentSurface) {\n                      let newSplitFaces = [];\n                      for(const splitFace of splitFaces){\n                         const splitSurfaces = trimmer.splitSurface(splitFace.getSurface(), intersection);\n                        if (splitSurfaces && splitSurfaces.length > 0) {\n                                splitSurfaces.forEach(splitSurface => {\n                                    newSplitFaces.push(new Face(splitSurface, splitFace.getOuterLoop(), splitFace.getInnerLoops()));\n                                });\n                            } else {\n                                newSplitFaces.push(splitFace);\n                            }\n                      }\n                      splitFaces = newSplitFaces;\n                      if(splitFaces.length > 0)\n                           currentSurface = splitFaces[0].getSurface();\n                       else currentSurface = null;\n                } else  if (allFaces2.includes(face) && surface2 === currentSurface) {\n                       let newSplitFaces = [];\n                      for(const splitFace of splitFaces){\n                         const splitSurfaces = trimmer.splitSurface(splitFace.getSurface(), intersection);\n                         if (splitSurfaces && splitSurfaces.length > 0) {\n                                splitSurfaces.forEach(splitSurface => {\n                                    newSplitFaces.push(new Face(splitSurface, splitFace.getOuterLoop(), splitFace.getInnerLoops()));\n                                });\n                            } else {\n                                newSplitFaces.push(splitFace);\n                            }\n                      }\n                    splitFaces = newSplitFaces;\n                    if(splitFaces.length > 0)\n                      currentSurface = splitFaces[0].getSurface();\n                    else currentSurface = null;\n                }\n            }\n             if(splitFaces && splitFaces.length > 0){\n                  trimmedFaces.push(...splitFaces)\n              }\n        }\n        const newSolid = new Solid();\n        const newShell = new Shell(trimmedFaces);\n        newSolid.addShell(newShell);\n        return newSolid;\n    }\n     findSurfaceIntersections(surface1, surface2) {\n        if (!surface1 || !surface2) {\n            return null;\n        }\n        const initialCurves = this._approximateIntersections(surface1, surface2);\n        if (!initialCurves || initialCurves.length === 0) {\n            return [];\n        }\n         const refinedCurves = [];\n        const tolerance = 0.001;\n        const maxIterations = 20;\n         for (const initialCurve of initialCurves) {\n            const refinedPoints = [];\n            for(const initialPoint of initialCurve){\n               const refinedPoint =  this._refineIntersectionPoint(surface1, surface2, initialPoint, tolerance, maxIterations);\n                if(refinedPoint){\n                    refinedPoints.push(refinedPoint);\n                }\n            }\n           if(refinedPoints.length > 1){\n                const controlPoints = refinedPoints.map(point => surface1.evaluate(point.u1, point.v1));\n                if(controlPoints && controlPoints.length > 1){\n                     const degree = 3;\n                    const knots = this._createUniformKnotVector(controlPoints.length, degree);\n                    const weights = Array(controlPoints.length).fill(1);\n                     const nurbsCurve = new NurbsCurve(degree, controlPoints, knots, weights);\n                    refinedCurves.push(nurbsCurve);\n                }\n            }\n        }\n        const filteredCurves = refinedCurves.filter(curve => curve.length() > 0.01);\n         const intersections = filteredCurves.map(curve => new Intersection(curve, surface1, surface2));\n        return intersections;\n    }\n     _findSurfaceIntersections(surface1, surface2) {\n        if (!surface1 || !surface2) {\n            return null;\n        }\n        const initialCurves = this._approximateIntersections(surface1, surface2);\n        if (!initialCurves || initialCurves.length === 0) {\n            return [];\n        }\n        const refinedCurves = this._refineIntersections(surface1, surface2, initialCurves);\n        if (!refinedCurves || refinedCurves.length === 0) {\n             return [];\n        }\n        const intersections = refinedCurves.map(curve => new Intersection(curve, surface1, surface2));\n        return intersections;\n    }\n    _approximateIntersections(surface1, surface2) {\n         if (!surface1 || !surface2) {\n            return null;\n        }\n        const uMin1 = surface1.getKnotsU()[0];\n        const uMax1 = surface1.getKnotsU()[surface1.getKnotsU().length - 1];\n        const vMin1 = surface1.getKnotsV()[0];\n        const vMax1 = surface1.getKnotsV()[surface1.getKnotsV().length - 1];\n        const uMin2 = surface2.getKnotsU()[0];\n        const uMax2 = surface2.getKnotsU()[surface2.getKnotsU().length - 1];\n        const vMin2 = surface2.getKnotsV()[0];\n        const vMax2 = surface2.getKnotsV()[surface2.getKnotsV().length - 1];\n         const initialCurves = [];\n        this._recursiveSubdivision(surface1, surface2, uMin1, uMax1, vMin1, vMax1, uMin2, uMax2, vMin2, vMax2, initialCurves, 0);\n        return initialCurves;\n    }\n    _refineIntersections(surface1, surface2, initialCurves) {\n        if (!surface1 || !surface2 || !initialCurves || initialCurves.length === 0) {\n            return null;\n        }\n        const refinedCurves = [];\n        const tolerance = 0.001;\n        const maxIterations = 20;\n        for (const initialCurve of initialCurves) {\n              const refinedPoints = [];\n            for(const initialPoint of initialCurve){\n               const refinedPoint =  this._refineIntersectionPoint(surface1, surface2, initialPoint, tolerance, maxIterations);\n                if(refinedPoint){\n                    refinedPoints.push(refinedPoint);\n                }\n            }\n           if(refinedPoints.length > 1){\n                const controlPoints = refinedPoints.map(point => surface1.evaluate(point.u1, point.v1));\n                 if(controlPoints && controlPoints.length > 1){\n                     const degree = 3;\n                    const knots = this._createUniformKnotVector(controlPoints.length, degree);\n                    const weights = Array(controlPoints.length).fill(1);\n                     const nurbsCurve = new NurbsCurve(degree, controlPoints, knots, weights);\n                    refinedCurves.push(nurbsCurve);\n                }\n           }\n        }\n       return refinedCurves;\n    }\n     _refineIntersectionPoint(surface1, surface2, initialPoint, tolerance, maxIterations) {\n        let u1 = initialPoint.u1;\n        let v1 = initialPoint.v1;\n        let u2 = initialPoint.u2;\n        let v2 = initialPoint.v2;\n         const refinedPoint = this._levenbergMarquardtRefinement(surface1, surface2, {\n            u1,\n            v1,\n            u2,\n            v2\n        }, tolerance, maxIterations);\n       if(refinedPoint) return refinedPoint;\n        return null;\n    }\n    _calculateJacobian(surface, u, v) {\n        const du = surface.evaluatePartialDerivative(u, v, 1, 0);\n        const dv = surface.evaluatePartialDerivative(u, v, 0, 1);\n        if (!du || !dv) {\n            return null;\n        }\n        return [\n            [\n                du.getX(),\n                du.getY(),\n                du.getZ()\n            ],\n            [\n                dv.getX(),\n                dv.getY(),\n                dv.getZ()\n            ]\n        ];\n    }\n     _createUniformKnotVector(numPoints, degree) {\n          if (numPoints <= degree + 1) {\n            return null;\n        }\n        const knots = [];\n        for (let i = 0; i <= degree; i++) {\n            knots.push(0);\n        }\n        for (let i = 1; i <= numPoints - degree - 1; i++) {\n            knots.push(i);\n        }\n        for (let i = 0; i <= degree; i++) {\n            knots.push(numPoints - degree - 1);\n        }\n         return knots;\n    }\n    _createEdgesFromIntersection(intersection, face1, face2) {\n        if (!intersection || !face1 || !face2) {\n            return null;\n        }\n         let curve = intersection.getCurve();\n        if (!curve || curve.getControlPoints().length < 2) {\n            return [];\n        }\n        const edges = [];\n          const splitCurves = [];\n          // Split the curve at self-intersections\n        const numSamples = 50;\n        const start = curve.getKnots()[0];\n        const end = curve.getKnots()[curve.getKnots().length - 1];\n        const step = (end - start) / numSamples;\n        const points = [];\n         for (let i = 0; i <= numSamples; i++) {\n            const u = start + i * step;\n            const point = curve.evaluate(u);\n            if (point) {\n                points.push({point:point, u:u});\n            }\n        }\n         if(points.length < 2){\n            return [];\n        }\n          let currentCurve = curve;\n          for(let i = 0; i < points.length; i++){\n             for(let j = i + 1; j < points.length; j++){\n                 const p1 = points[i].point;\n                 const p2 = points[j].point;\n                 if(p1.distanceTo(p2) < 0.001){\n                     if(Math.abs(points[i].u - points[j].u) > 0.001){\n                          const splitResult = currentCurve.splitCurve(points[j].u);\n                           if(splitResult && splitResult.length === 2){\n                               splitCurves.push(splitResult[0]);\n                               currentCurve = splitResult[1];\n                            }\n                     }\n                 }\n             }\n         }\n         splitCurves.push(currentCurve)\n         for (const splitCurve of splitCurves) {\n               const numSamples = 50;\n                const start = splitCurve.getKnots()[0];\n                const end = splitCurve.getKnots()[splitCurve.getKnots().length - 1];\n                const step = (end - start) / numSamples;\n                const points = [];\n                 for (let i = 0; i <= numSamples; i++) {\n                    const u = start + i * step;\n                    const point = splitCurve.evaluate(u);\n                    if (point) {\n                        points.push(point);\n                    }\n                }\n                 if(points.length < 2){\n                    continue;\n                }\n               for (let i = 0; i < points.length - 1; i++) {\n                    const startPoint = points[i];\n                    const endPoint = points[i + 1];\n                     const startVertex = this._findOrCreateVertex(startPoint);\n                    const endVertex = this._findOrCreateVertex(endPoint);\n                     if (startVertex === endVertex) {\n                        continue;\n                    }\n                    const edgeCurve = new NurbsCurve(splitCurve.getDegree(), [\n                        startPoint,\n                        endPoint\n                    ], [\n                        0,\n                        1\n                    ], [\n                        1,\n                        1\n                    ]);\n                     const edge = new Edge(startVertex, endVertex, edgeCurve);\n                     if(edge.length() > 0.001){\n                          edges.push(edge);\n                     }\n                }\n         }\n        return edges;\n    }\n    _findOrCreateVertex(point) {\n          if(!this.vertices){\n            this.vertices = [];\n        }\n         for (const vertex of this.vertices) {\n            if (vertex.getPoint().distanceTo(point) < 0.001) {\n                return vertex;\n            }\n        }\n        const newVertex = new Vertex(point);\n        this.vertices.push(newVertex);\n         return newVertex;\n    }\n     _createLoopsFromEdges(edges) {\n        if (!edges || edges.length === 0) {\n            return [];\n        }\n        const loops = [];\n        let remainingEdges = [...edges];\n         while (remainingEdges.length > 0) {\n            const currentEdge = remainingEdges.shift();\n            const currentLoop = new Loop([currentEdge]);\n            let currentVertex = currentEdge.getEndVertex();\n            let loopComplete = false;\n             while (!loopComplete) {\n                 let nextEdgeIndex = -1;\n                let minDistance = Infinity;\n                 for (let i = 0; i < remainingEdges.length; i++) {\n                    const nextEdge = remainingEdges[i];\n                    const startVertex = nextEdge.getStartVertex();\n                    const distance = currentVertex.getPoint().distanceTo(startVertex.getPoint());\n                      if(distance < minDistance){\n                        minDistance = distance;\n                        nextEdgeIndex = i;\n                    }\n                }\n                if(nextEdgeIndex !== -1 && minDistance < 0.001){\n                     const nextEdge = remainingEdges.splice(nextEdgeIndex, 1)[0];\n                    currentLoop.addEdge(nextEdge);\n                    currentVertex = nextEdge.getEndVertex();\n                }else{\n                    let closingEdgeIndex = -1;\n                    for(let i = 0; i < currentLoop.getEdges().length; i++){\n                        if(currentLoop.getEdges()[i].getStartVertex() === currentVertex){\n                           closingEdgeIndex = i;\n                           break;\n                        }\n                    }\n                     if (closingEdgeIndex !== -1) {\n                         currentLoop.addEdge(currentLoop.getEdges()[closingEdgeIndex]);\n                    }\n                     loopComplete = true;\n                }\n                 if(currentLoop.isClosed()){\n                    loopComplete = true;\n                }\n            }\n            loops.push(currentLoop);\n        }\n          return loops;\n    }\n    _isCoincident(surface1, surface2) {\n        if (!surface1 || !surface2) {\n            return false;\n        }\n         const uMin1 = surface1.getKnotsU()[0];\n        const uMax1 = surface1.getKnotsU()[surface1.getKnotsU().length - 1];\n        const vMin1 = surface1.getKnotsV()[0];\n        const vMax1 = surface1.getKnotsV()[surface1.getKnotsV().length - 1];\n         const uMin2 = surface2.getKnotsU()[0];\n        const uMax2 = surface2.getKnotsU()[surface2.getKnotsU().length - 1];\n        const vMin2 = surface2.getKnotsV()[0];\n        const vMax2 = surface2.getKnotsV()[surface2.getKnotsV().length - 1];\n\n         //check for overlapping parameter domains\n        if (uMax1 < uMin2 || uMin1 > uMax2 || vMax1 < vMin2 || vMin1 > vMax2) {\n             return false;\n        }\n\n        const numSamplesU = 10;\n        const numSamplesV = 10;\n        const deltaU1 = (uMax1 - uMin1) / numSamplesU;\n        const deltaV1 = (vMax1 - vMin1) / numSamplesV;\n         const tolerance = 0.001;\n        for (let i = 0; i <= numSamplesU; i++) {\n            for (let j = 0; j <= numSamplesV; j++) {\n                const u1 = uMin1 + i * deltaU1;\n                const v1 = vMin1 + j * deltaV1;\n                 const point1 = surface1.evaluate(u1, v1);\n                 // Ensure the evaluation was successful before proceeding.\n                if(!point1) continue;\n\n                const u2 = uMin2 + i * deltaU1;\n                const v2 = vMin2 + j * deltaV1;\n                 const point2 = surface2.evaluate(u2, v2);\n                  // Ensure the evaluation was successful before proceeding.\n                if(!point2) continue;\n\n\n                const dist = point1.distanceTo(point2);\n                 if (dist > tolerance) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n     _isTangentIntersection(intersection, surface1, surface2) {\n        if (!intersection || !surface1 || !surface2) {\n            return false;\n        }\n        const curve = intersection.getCurve();\n        if (!curve) {\n            return false;\n        }\n         const numSamples = 10;\n        const start = curve.getKnots()[0];\n        const end = curve.getKnots()[curve.getKnots().length - 1];\n        const step = (end - start) / numSamples;\n        for (let i = 0; i <= numSamples; i++) {\n            const u = start + i * step;\n             const point = curve.evaluate(u);\n             if(!point) continue;\n             const uv1 = this._findUVOnSurface(surface1, point);\n             const uv2 = this._findUVOnSurface(surface2, point);\n              if(!uv1 || !uv2) continue;\n            const normal1 = surface1.normal(uv1.u, uv1.v);\n            const normal2 = surface2.normal(uv2.u, uv2.v);\n            if(!normal1 || !normal2) continue;\n           const dotProduct = normal1.dot(normal2);\n            if(Math.abs(dotProduct) > 0.99){\n                return true;\n            }\n        }\n         return false;\n    }\n    _recursiveSubdivision(surface1, surface2, uMin1, uMax1, vMin1, vMax1, uMin2, uMax2, vMin2, vMax2, initialCurves, depth) {\n         const maxDepth = 5;\n        if (depth > maxDepth) {\n            return;\n        }\n         const uMid1 = (uMin1 + uMax1) / 2;\n        const vMid1 = (vMin1 + vMax1) / 2;\n        const uMid2 = (uMin2 + uMax2) / 2;\n        const vMid2 = (vMin2 + vMax2) / 2;\n         const p1Min = surface1.evaluate(uMin1, vMin1);\n        const p1Max = surface1.evaluate(uMax1, vMax1);\n        const p1Mid = surface1.evaluate(uMid1, vMid1);\n        const p2Min = surface2.evaluate(uMin2, vMin2);\n        const p2Max = surface2.evaluate(uMax2, vMax2);\n        const p2Mid = surface2.evaluate(uMid2, vMid2);\n          if(!p1Min || !p1Max || !p1Mid || !p2Min || !p2Max || !p2Mid) return;\n\n         const bbox1 = this._getBoundingBox(surface1, uMin1, uMax1, vMin1, vMax1);\n        const bbox2 = this._getBoundingBox(surface2, uMin2, uMax2, vMin2, vMax2);\n        if(!this._doBoundingBoxesOverlap(bbox1, bbox2)){\n           return;\n        }\n        const distMin = p1Min.distanceTo(p2Min);\n        const distMax = p1Max.distanceTo(p2Max);\n        const distMid = p1Mid.distanceTo(p2Mid);\n        const threshold = 0.1;\n         if (distMin < threshold && distMax < threshold && distMid < threshold) {\n             initialCurves.push([{\n                    u1: uMid1,\n                    v1: vMid1,\n                    u2: uMid2,\n                    v2: vMid2\n                }]);\n            return;\n        }\n        this._recursiveSubdivision(surface1, surface2, uMin1, uMid1, vMin1, vMid1, uMin2, uMid2, vMin2, vMid2, initialCurves, depth + 1);\n        this._recursiveSubdivision(surface1, surface2, uMid1, uMax1, vMin1, vMid1, uMid2, uMax2, vMin2, vMid2, initialCurves, depth + 1);\n        this._recursiveSubdivision(surface1, surface2, uMin1, uMid1, vMid1, vMax1, uMin2, uMid2, vMid2, vMax2, initialCurves, depth + 1);\n        this._recursiveSubdivision(surface1, surface2, uMid1, uMax1, vMid1, vMax1, uMid2, uMax2, vMid2, vMax2, initialCurves, depth + 1);\n    }\n    _isFaceInside(surface1, surface2) {\n         if (!surface1 || !surface2) {\n            return false;\n        }\n           const numSamplesU = 5;\n        const numSamplesV = 5;\n        const uMin1 = surface1.getKnotsU()[0];\n        const uMax1 = surface1.getKnotsU()[surface1.getKnotsU().length - 1];\n        const vMin1 = surface1.getKnotsV()[0];\n        const vMax1 = surface1.getKnotsV()[surface1.getKnotsV().length - 1];\n         const uStep1 = (uMax1 - uMin1) / numSamplesU;\n        const vStep1 = (vMax1 - vMin1) / numSamplesV;\n        let allInside = true;\n         const trimmer = new SurfaceTrimmer();\n          for (let i = 0; i <= numSamplesU; i++) {\n            for (let j = 0; j <= numSamplesV; j++) {\n                const u1 = uMin1 + i * uStep1;\n                const v1 = vMin1 + j * vStep1;\n                  const point1 = surface1.evaluate(u1, v1);\n                  if(point1){\n                     if(!trimmer.isPointInside(surface2,point1)){\n                        allInside = false;\n                    }\n                  }\n            }\n        }\n          return allInside;\n    }\n     _hasSelfIntersections(surface) {\n         if (!surface) {\n            return false;\n        }\n        const uMin = surface.getKnotsU()[0];\n        const uMax = surface.getKnotsU()[surface.getKnotsU().length - 1];\n        const vMin = surface.getKnotsV()[0];\n        const vMax = surface.getKnotsV()[surface.getKnotsV().length - 1];\n        const numSamplesU = 20;\n        const numSamplesV = 20;\n        const uStep = (uMax - uMin) / numSamplesU;\n        const vStep = (vMax - vMin) / numSamplesV;\n         const points = [];\n           for (let i = 0; i <= numSamplesU; i++) {\n            for (let j = 0; j <= numSamplesV; j++) {\n                const u = uMin + i * uStep;\n                const v = vMin + j * vStep;\n                  const point = surface.evaluate(u, v);\n                  if(point)\n                    points.push({u,v, point});\n            }\n        }\n         for(let i = 0; i < points.length; i++){\n              for(let j = i + 1; j < points.length; j++){\n                  const point1 = points[i].point;\n                  const point2 = points[j].point;\n                    const dist = point1.distanceTo(point2);\n                   if (dist < 0.001",
      "hidden": false
    }
  ],
  "title": "NURBS Library Development",
  "id": "20250118_022102039Z",
  "targetFile": "./brep.js",
  "chatMode": "chat",
  "conversationNew": false,
  "lastModified": "2025-01-18T02:22:31.346Z"
}