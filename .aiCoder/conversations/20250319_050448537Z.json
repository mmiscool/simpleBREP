{
  "messages": [
    {
      "role": "system",
      "content": "\n\nYou are a highly skilled JavaScript engineer proficient in ES6+ standards, building efficient, clean, and modular code. Your task is to assist another engineer by providing full, ready-to-use code solutions for each request.\n\nRespond with complete, self-contained JavaScript code blocks that can be directly implemented, avoiding partial snippets or piecemeal modifications.\nUse ES6+ standards and best practices at all times, including modern JavaScript features like destructuring, arrow functions, async/await, and template literals.\nOptimize for readability and performance by structuring code clearly, minimizing dependencies, and anticipating potential optimizations.\nIncorporate robust error handling and edge case management in each solution to create resilient, production-ready code.\nExplain briefly and concisely if requested, focusing on clarity, simplicity, and relevance to the task.\nAnticipate the engineer’s needs and build code that is modular, maintainable, and adheres to JavaScript standards. Address any challenges related to cross-browser compatibility, asynchronous operations, or API integration effectively.\nYou will only only be providing javascript code snippets.\n\nYou are a self starter and can identify functionality that needs to be implemented.\n\nOnly generate javascript code. All code must be javascript. Make only javascript code. \n\n**You are permitted to discuss planning details and answer questions about the code if requested.**\n**You are permitted to generate html and css code if specifically asked otherwise always generate javascript**\n\nnever use the `#` character for private field notation.\n\nIf you are making a stub method do not include any thing inside the stub method. Leave it completely empty.",
      "filePath": "./.aiCoder/prompts/default-system-prompt.md",
      "description": "",
      "hidden": true
    },
    {
      "role": "assistant",
      "content": "I understand and will follow these instructions.",
      "hidden": false
    },
    {
      "role": "system",
      "content": "\n\n# Instructions for Producing Code Snippets\nDO NOT INCLUDE EXAMPLES OR TESTS IN YOUR CODE SNIPPETS.\nDO NOT INCLUDE EXAMPLES OR TESTS IN YOUR CODE SNIPPETS.\nDO NOT INCLUDE EXAMPLES OR TESTS IN YOUR CODE SNIPPETS.\n\n**you may generate javascript, css and html code**\n\n**Never make any global variables or functions. All functionality must be encapsulated in a class**\n\n**No Examples or Tests**: *Do not include any examples or test cases* in the code snippet. Only provide the requested implementation within the class.\n\n**No External Modifications**:  *Do not perform any monkey-patching* or modify any code outside the class definition.\n\n**Constructor Edits**: Avoid modifying class constructors unless it’s absolutely necessary for the task.\n\n**No Global Code**:  *Do not create global variables or functions*. All logic should remain encapsulated within a class.\n\n**All snippets must conform to the following example formatting**:\n```javascript\nclass exampleClass {\n   // ... existing methods\n   exampleMethod(){\n      //example code\n   }\n}\n```\n\nIf a class or function is exported you must include the export statement in your snippet. \n\nRemember that methods must be encapsulated in a class.\n\n**Do not include methods that are not being modified in the code snippets you produce**",
      "filePath": "./.aiCoder/prompts/snippet-production-prompt.md",
      "description": "",
      "hidden": true
    },
    {
      "role": "assistant",
      "content": "I understand and will follow these instructions.",
      "hidden": false
    },
    {
      "role": "user",
      "content": "\n\n<think>\nOkay, so I'm trying to figure out how to create a complete NURBS library in JavaScript based on the provided plan. Let me go through each section step by step and think about what needs to be done.\n\nFirst, looking at the introduction, it's clear that this library will serve as a foundation for a BREP kernel. That means all the classes and methods should be robust and ready to handle complex geometric constructs.\n\nStarting with the core concepts: control points, knots, weights, and degree. The point3d class needs to represent 3D points accurately. So I'll define it with x, y, z properties. Adding getters makes sense for easy access. For validation, each constructor parameter should be checked to ensure they are numbers.\n\nNext is the NurbsCurve class. It depends on NurbsBase which isn't defined yet, but maybe that's a placeholder. The key here is handling knots correctly—each knot can have multiplicity up to the degree plus one. I'll need to calculate the vector size dynamically based on the knots array length minus one.\n\nThe deBoor algorithm is crucial for evaluating curves and surfaces. Implementing it in a helper function will make sense, especially since derivative calculations rely on it as well. Each step of the algorithm needs to be carefully translated into JavaScript loops.\n\nWhen it comes to derivatives, calculating them via finite differences around a point makes sense. The step size should be small enough but non-zero to avoid division by zero errors. Maybe using an object for derivative orders will help manage different cases easily.\n\nFor the NurbsCurve class methods like insertKnot and removeKnot, I need to ensure that adding or removing knots doesn't cause issues with the knot vector's properties. The functions should handle duplicates correctly and recalculate the control points if necessary after modifications.\n\nThe length function is more complex, involving an integral approximation using a specified number of intervals. Adaptive quadrature might be overkill for now, but implementing Simpson's rule could provide a good balance between accuracy and performance.\n\nTangent vectors are straightforward once you have the derivative at a point. The normal vector requires both tangents in u and v directions if it's a surface, so that calculation will involve cross products or normalization after computing derivatives.\n\nSplitting curves into two seems like applying deBoor with an adjusted knot value. Handling surfaces would require splitting along both U and V directions independently.\n\nError handling is important throughout all these methods to catch invalid inputs before they cause unexpected behavior. Maybe adding try-catch blocks in JavaScript will help, but also validating each parameter as it's set or used.\n\nDocumentation is another key area. Each method should have clear comments explaining what it does, any assumptions, and edge cases to consider. This will make the library more usable by others who might integrate it later.\n\nI'm also thinking about efficiency since high-degree curves and surfaces can be computationally intensive. Perhaps memoizing certain calculations or avoiding redundant computations where possible could help speed things up without major overhauls.\n\nPutting all this together, each class needs to follow a similar structure with proper validation and clear interfaces for external code to interact with. The utility functions in the Utils class should be reliable, handling edge cases like invalid degrees or knots correctly.\n\nI might need to test each method incrementally. For example, start by ensuring that point3d works as expected before moving on to more complex classes. Checking error messages when inputs are wrong could help identify where things are going south.\n\nOverall, it's a big project, but breaking it down into manageable parts with careful implementation and testing will make it feasible. Each class builds upon the previous ones, so ensuring that each step is solid before proceeding is crucial.\n</think>\n\nTo create a complete NURBS library in JavaScript, follow these steps:\n\n### 1. Define Point3D Class\nCreate a class to represent 3D points with methods for validation and accessors.\n\n```javascript\nclass Point3D {\n    constructor(x = null, y = null, z = null) {\n        this.x = x === null ? Number(x) : Number(x);\n        this.y = y === null ? Number(y) : Number(y);\n        this.z = z === null ? Number(z) : Number(z);\n\n        if (!this.x || !this.y || !this.z) {\n            throw new Error(\"Point3D constructor arguments cannot be null or undefined\");\n        }\n    }\n\n    getX() { return this.x; }\n    getY() { return this.y; }\n    getZ() { return this.z; }\n\n    validate(value) {\n        if (value === null || value === undefined) {\n            throw new Error(\"Point3D argument cannot be null or undefined\");\n        }\n    }\n}\n```\n\n### 2. Implement NurbsBase Class\nCreate a base class for NURBS objects that handles knots, control points, and weights.\n\n```javascript\nclass NurbsBase {\n    constructor(degreeU = null, degreeV = null) {\n        if (degreeU === null || degreeV === null) {\n            throw new Error(\"NurbsBase requires degree parameters\");\n        }\n        this.degreeU = degreeU;\n        this.degreeV = degreeV;\n        this.controlPoints = [];\n        this.knotsU = [];\n        this.knotsV = [];\n        this.weights = [];\n    }\n\n    validateKnots(knots) {\n        if (knots.length === 0) {\n            throw new Error(\"NurbsBase requires knots array\");\n        }\n        // Additional knot validation logic as needed\n    }\n\n    getNumControlPoints() { return this.controlPoints.length; }\n}\n```\n\n### 3. Implement NurbsCurve Class\nExtend the base class to handle curves, including knot vectors and control points.\n\n```javascript\nclass NurbsCurve extends NurbsBase {\n    constructor(...args) {\n        super.apply(args);\n    }\n\n    getNumKnots() { return this.knotsU.length; }\n}\n```\n\n### 4. Implement deBoor Function\nCreate a helper function to compute the NURBS basis functions.\n\n```javascript\nfunction deBoor(p, u, knots) {\n    const n = knots.length - 1;\n    let i, k;\n\n    if (p < 0 || p >= n + 1)\n        return [Point3D.create(), ...Array(n).fill(Point3D.create())];\n\n    for (i = n; --i > p; )\n        if (knots[i] === u)\n            break;\n    else {\n        const result = new Array(p + 2);\n        i++;\n        while (i < n) {\n            const j = i - k;\n            if (u >= knots[j])\n                j++;\n            else\n                k++;\n            result[k] = Point3D.create();\n            for (let l = p; --l > 0; )\n                result[k].x += result[l].x * (knots[i] - u) / (knots[j + l] - knots[j]);\n        }\n        return result;\n    }\n\n    const result = new Array(p + 1);\n    i = 0;\n    for (; i <= p; )\n        if (result.length < p)\n            break;\n        else\n            const j = n >= i ? n : Number.NEGATIVE_INFINITY;\n        while (j > p && knots[j] !== u) {\n            j--;\n            if (j === p - 1)\n                return result;\n        }\n    }\n\n    // Add additional logic for calculating the basis function vector\n}\n```\n\n### 5. Implement NurbsSurface Class\nExtend the base class to handle surfaces, including knot vectors in both directions.\n\n```javascript\nclass NurbsSurface extends NurbsBase {\n    constructor(...args) {\n        super.apply(args);\n    }\n\n    getNumKnotsU() { return this.knotsU.length; }\n    getNumKnotsV() { return this.knotsV.length; }\n}\n```\n\n### 6. Implement Length Function\nCalculate the length of a curve using an approximation method.\n\n```javascript\nfunction calculateLength(nurbsCurve, intervals = 100) {\n    let total = 0;\n    const step = (nurbsCurve.knotsU[1] - nurbsCurve.knotsU[0]) / intervals;\n\n    for (let i = 0; i < intervals; i++) {\n        const t = (i * step + nurbsCurve.knotsU[0]);\n        total += Math.sqrt(\n            Math.pow(nurbsCurve.controlPoints[i + 1].x - \n                    nurbsCurve.controlPoints[i].x, 2) +\n            Math.pow(nurbsCurve.controlPoints[i + 1].y -\n                    nurbsCurve.controlPoints[i].y, 2) +\n            Math.pow(nurbsCurve.controlPoints[i + 1].z -\n                    nurbsCurve.controlPoints[i].z, 2)\n        );\n    }\n\n    return total * (nurbsCurve.knotsU[1] - nurbsCurve.knotsU[0]) / intervals;\n}\n```\n\n### 7. Implement Derivative Functions\nCalculate derivatives for curves and surfaces.\n\n```javascript\nfunction derivativeCurves(nurbs, order) {\n    let result = [nurbs.controlPoints.slice(0)];\n    const knots = [...nurbs.knotsU];\n\n    while (order > 0) {\n        const newControlPoints = [];\n        const degree = order;\n        for (let i = 0; i < knots.length - 2 * degree; i++) {\n            const leftWeighted = result[i].x * (knots[i + 1] - knots[i]) +\n                                result[i].y * (knots[i + 1] - knots[i]) +\n                                result[i].z * (knots[i + 1] - knots[i]);\n            newControlPoints.push(leftWeighted);\n        }\n        result = newControlPoints;\n        order--;\n    }\n\n    return result;\n}\n```\n\n### 8. Update NurbsCurve and NurbsSurface Methods\nIntegrate the helper functions into the curve and surface classes.\n\n```javascript\nNurbsCurve.prototype.insertKnot = function(knot, multiplicity) {\n    // Implementation logic for inserting knots\n};\n\nNurbsCurve.prototype.removeKnot = function(knot) {\n    // Implementation logic for removing knots\n};\n```\n\n### 9. Add Surface Functions\nImplement methods specific to surfaces.\n\n```javascript\nNurbsSurface.prototype.calculateDerivativeU = function(order) {\n    // U direction derivative calculation\n};\n```\n\nThis implementation provides a foundation for working with NURBS curves and surfaces in JavaScript, including knot insertion, removal, basis function computation, length approximation, and derivatives.",
      "filePath": "./.aiCoder/prompts/default-plan-prompt.md",
      "description": "",
      "hidden": true
    },
    {
      "role": "assistant",
      "content": "I understand and will follow these instructions.",
      "hidden": false
    },
    {
      "role": "user",
      "content": "// Code file to be edited\n\n\nexport class Point {\n    constructor(x, y, z) {\n        this.x = x || 0;\n        // Default to 0 if not provided\n        this.y = y || 0;\n        this.z = z || 0;\n    }\n    add(point) {\n        return new Point(this.x + point.x, this.y + point.y, this.z + point.z);\n    }\n    subtract(point) {\n        return new Point(this.x - point.x, this.y - point.y, this.z - point.z);\n    }\n    scale(scalar) {\n        return new Point(this.x * scalar, this.y * scalar, this.z * scalar);\n    }\n    distanceTo(point) {\n        const dx = this.x - point.x;\n        const dy = this.y - point.y;\n        const dz = this.z - point.z;\n        return Math.sqrt(dx * dx + dy * dy + dz * dz);\n    }\n    equals(point, tolerance = 0.000001) {\n        return this.distanceTo(point) < tolerance;\n    }\n    clone() {\n        return new Point(this.x, this.y, this.z);\n    }\n    toString() {\n        return `Point(${ this.x }, ${ this.y }, ${ this.z })`;\n    }\n}\nexport class Vector {\n    constructor(x, y, z) {\n        this.x = x || 0;\n        // Default to 0 if not provided\n        this.y = y || 0;\n        this.z = z || 0;\n    }\n    add(vector) {\n        return new Vector(this.x + vector.x, this.y + vector.y, this.z + vector.z);\n    }\n    subtract(vector) {\n        return new Vector(this.x - vector.x, this.y - vector.y, this.z - vector.z);\n    }\n    scale(scalar) {\n        return new Vector(this.x * scalar, this.y * scalar, this.z * scalar);\n    }\n    magnitude() {\n        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n    }\n    normalize() {\n        const mag = this.magnitude();\n        if (mag === 0) {\n            throw new Error('Cannot normalize a zero-length vector');\n        }\n        return this.scale(1 / mag);\n    }\n    dot(vector) {\n        return this.x * vector.x + this.y * vector.y + this.z * vector.z;\n    }\n    cross(vector) {\n        return new Vector(this.y * vector.z - this.z * vector.y, this.z * vector.x - this.x * vector.z, this.x * vector.y - this.y * vector.x);\n    }\n    equals(vector, tolerance = 0.000001) {\n        const diff = this.subtract(vector);\n        return diff.magnitude() < tolerance;\n    }\n    clone() {\n        return new Vector(this.x, this.y, this.z);\n    }\n    toString() {\n        return `Vector(${ this.x }, ${ this.y }, ${ this.z })`;\n    }\n}\nexport class NURBSCurve {\n    constructor(degree, controlPoints, knots, weights) {\n        if (!Number.isInteger(degree) || degree < 1) {\n            throw new Error('Degree must be a positive integer');\n        }\n        if (!Array.isArray(controlPoints) || controlPoints.length < degree + 1) {\n            throw new Error('Must have at least degree + 1 control points');\n        }\n        if (!Array.isArray(knots) || knots.length !== controlPoints.length + degree + 1) {\n            throw new Error('Knot vector length must be controlPoints.length + degree + 1');\n        }\n        if (!Array.isArray(weights) || weights.length !== controlPoints.length) {\n            throw new Error('Weights array must match controlPoints length');\n        }\n        if (!knots.every((k, i) => i === 0 || k >= knots[i - 1])) {\n            throw new Error('Knots must be non-decreasing');\n        }\n        this.degree = degree;\n        this.controlPoints = controlPoints.map(p => p.clone());\n        this.knots = [...knots];\n        this.weights = [...weights];\n        this.n = controlPoints.length - 1;\n        this._basisCache = new Map();\n        this._derivativeCache = new Map();\n    }\n    evaluate(t) {\n        const span = this._findKnotSpan(t);\n        const basis = this._getCachedBasis(span, t);\n        let x = 0, y = 0, z = 0, w = 0;\n        for (let i = 0; i <= this.degree; i++) {\n            const idx = span - this.degree + i;\n            const b = basis[i] * this.weights[idx];\n            x += this.controlPoints[idx].x * b;\n            y += this.controlPoints[idx].y * b;\n            z += this.controlPoints[idx].z * b;\n            w += b;\n        }\n        return new Point(x / w, y / w, z / w);\n    }\n    _findKnotSpan(t) {\n        if (t < this.knots[0] || t > this.knots[this.knots.length - 1]) {\n            throw new Error(`Parameter t=${ t } is outside knot range [${ this.knots[0] }, ${ this.knots[this.knots.length - 1] }]`);\n        }\n        if (t === this.knots[this.knots.length - 1]) {\n            return this.n;\n        }\n        let low = this.degree;\n        let high = this.n + 1;\n        let mid = Math.floor((low + high) / 2);\n        while (t < this.knots[mid] || t >= this.knots[mid + 1]) {\n            if (t < this.knots[mid])\n                high = mid;\n            else\n                low = mid;\n            mid = Math.floor((low + high) / 2);\n        }\n        return mid;\n    }\n    _basisFunctions(span, t) {\n        const N = [1];\n        const left = [];\n        const right = [];\n        for (let j = 1; j <= this.degree; j++) {\n            left[j] = t - this.knots[span + 1 - j];\n            right[j] = this.knots[span + j] - t;\n            let saved = 0;\n            for (let r = 0; r < j; r++) {\n                const temp = N[r] / (right[r + 1] + left[j - r]);\n                N[r] = saved + right[r + 1] * temp;\n                saved = left[j - r] * temp;\n            }\n            N[j] = saved;\n        }\n        return N;\n    }\n    getDomain() {\n        return [\n            this.knots[this.degree],\n            this.knots[this.n + 1]\n        ];\n    }\n    toString() {\n        return `NURBSCurve(degree=${ this.degree }, n=${ this.n }, knots=[${ this.knots.join(', ') }])`;\n    }\n    derivative(t, order = 1) {\n        if (order < 1 || !Number.isInteger(order)) {\n            throw new Error('Derivative order must be a positive integer');\n        }\n        if (order > this.degree) {\n            return new Vector(0, 0, 0);\n        }\n        const span = this._findKnotSpan(t);\n        const ders = this._getCachedDerivatives(span, t, order);\n        const Aders = [];\n        const wders = [];\n        for (let k = 0; k <= order; k++) {\n            let x = 0, y = 0, z = 0, w = 0;\n            for (let i = 0; i <= this.degree; i++) {\n                const idx = span - this.degree + i;\n                const b = ders[k][i] * this.weights[idx];\n                x += this.controlPoints[idx].x * b;\n                y += this.controlPoints[idx].y * b;\n                z += this.controlPoints[idx].z * b;\n                w += ders[k][i] * this.weights[idx];\n            }\n            Aders[k] = new Point(x, y, z);\n            wders[k] = w;\n        }\n        const result = new Vector(0, 0, 0);\n        const w = wders[0];\n        const wInv = 1 / w;\n        const wInv2 = wInv * wInv;\n        if (order === 1) {\n            const A1 = Aders[1];\n            const w1 = wders[1];\n            result.x = (A1.x - w1 * Aders[0].x) * wInv2;\n            result.y = (A1.y - w1 * Aders[0].y) * wInv2;\n            result.z = (A1.z - w1 * Aders[0].z) * wInv2;\n        } else {\n            for (let k = 0; k <= order; k++) {\n                const coef = this._binomial(order, k);\n                const sign = (order - k) % 2 === 0 ? 1 : -1;\n                let term = Aders[k].clone();\n                for (let i = 0; i < order - k; i++) {\n                    term = term.scale(wInv);\n                }\n                const wTerm = wders[order - k] * coef * sign;\n                result.x += (term.x - Aders[0].x * wTerm) * wInv2;\n                result.y += (term.y - Aders[0].y * wTerm) * wInv2;\n                result.z += (term.z - Aders[0].z * wTerm) * wInv2;\n            }\n        }\n        return result;\n    }\n    _basisDerivatives(span, t, n) {\n        const ders = Array(n + 1).fill().map(() => Array(this.degree + 1).fill(0));\n        const ndu = Array(this.degree + 1).fill().map(() => Array(this.degree + 1).fill(0));\n        const left = Array(this.degree + 1).fill(0);\n        const right = Array(this.degree + 1).fill(0);\n        ndu[0][0] = 1;\n        for (let j = 1; j <= this.degree; j++) {\n            left[j] = t - this.knots[span + 1 - j];\n            right[j] = this.knots[span + j] - t;\n            let saved = 0;\n            for (let r = 0; r < j; r++) {\n                ndu[j][r] = right[r + 1] + left[j - r];\n                const temp = ndu[r][j - 1] / ndu[j][r];\n                ndu[r][j] = saved + right[r + 1] * temp;\n                saved = left[j - r] * temp;\n            }\n            ndu[j][j] = saved;\n        }\n        for (let j = 0; j <= this.degree; j++) {\n            ders[0][j] = ndu[j][this.degree];\n        }\n        for (let r = 0; r <= this.degree; r++) {\n            let s1 = 0, s2 = 1;\n            const a = Array(this.degree + 1).fill().map(() => Array(this.degree + 1).fill(0));\n            a[0][0] = 1;\n            for (let k = 1; k <= n; k++) {\n                let d = 0;\n                const rk = r - k;\n                const pk = this.degree - k;\n                if (r >= k) {\n                    a[s2][0] = a[s1][0] / ndu[pk + 1][rk];\n                    d = a[s2][0] * ndu[rk][pk];\n                }\n                const j1 = rk >= -1 ? 1 : -rk;\n                const j2 = r - 1 <= pk ? k - 1 : this.degree - r;\n                for (let j = j1; j <= j2; j++) {\n                    a[s2][j] = (a[s1][j] - a[s1][j - 1]) / ndu[pk + 1][rk + j];\n                    d += a[s2][j] * ndu[rk + j][pk];\n                }\n                if (r <= pk) {\n                    a[s2][k] = -a[s1][k - 1] / ndu[pk + 1][r];\n                    d += a[s2][k] * ndu[r][pk];\n                }\n                ders[k][r] = d;\n                [s1, s2] = [\n                    s2,\n                    s1\n                ];\n            }\n        }\n        let r = this.degree;\n        for (let k = 1; k <= n; k++) {\n            for (let j = 0; j <= this.degree; j++) {\n                ders[k][j] *= r;\n            }\n            r *= this.degree - k;\n        }\n        return ders;\n    }\n    closestParameter(point, tolerance = 0.000001, maxIterations = 100) {\n        const [tMin, tMax] = this.getDomain();\n        let t = (tMin + tMax) / 2;\n        let iteration = 0;\n        while (iteration < maxIterations) {\n            const P = this.evaluate(t);\n            const dP = this.derivative(t, 1);\n            const V = P.subtract(point);\n            const dot = V.dot(dP);\n            const dPmag2 = dP.dot(dP);\n            if (dPmag2 < tolerance)\n                break;\n            const deltaT = -dot / dPmag2;\n            t += deltaT;\n            if (t < tMin)\n                t = tMin;\n            if (t > tMax)\n                t = tMax;\n            if (Math.abs(deltaT) < tolerance)\n                break;\n            iteration++;\n        }\n        return t;\n    }\n    length(samples = 100) {\n        const [tMin, tMax] = this.getDomain();\n        const dt = (tMax - tMin) / (samples - 1);\n        let totalLength = 0;\n        let prevPoint = this.evaluate(tMin);\n        for (let i = 1; i < samples; i++) {\n            const t = tMin + i * dt;\n            const currPoint = this.evaluate(t);\n            totalLength += prevPoint.distanceTo(currPoint);\n            prevPoint = currPoint;\n        }\n        return totalLength;\n    }\n    _binomial(n, k) {\n        if (k < 0 || k > n)\n            return 0;\n        let result = 1;\n        for (let i = 0; i < k; i++) {\n            result *= (n - i) / (i + 1);\n        }\n        return result;\n    }\n    split(t) {\n        const [tMin, tMax] = this.getDomain();\n        if (t <= tMin || t >= tMax) {\n            throw new Error(`Split parameter t=${ t } must be within domain (${ tMin }, ${ tMax })`);\n        }\n        let span = this._findKnotSpan(t);\n        let multiplicity = 0;\n        for (let i = span; i >= 0 && Math.abs(this.knots[i] - t) < 0.000001; i--) {\n            multiplicity++;\n        }\n        const insertsNeeded = this.degree - multiplicity;\n        let newKnots = [...this.knots];\n        let newPoints = this.controlPoints.map(p => p.clone());\n        let newWeights = [...this.weights];\n        for (let i = 0; i < insertsNeeded; i++) {\n            ({\n                knots: newKnots,\n                points: newPoints,\n                weights: newWeights\n            } = this._insertKnot(t, newKnots, newPoints, newWeights));\n        }\n        let splitIdx = 0;\n        for (let i = 0; i < newKnots.length; i++) {\n            if (newKnots[i] >= t - 0.000001) {\n                splitIdx = i - this.degree;\n                break;\n            }\n        }\n        const knots1 = newKnots.slice(0, splitIdx + this.degree + 1);\n        const points1 = newPoints.slice(0, splitIdx + 1);\n        const weights1 = newWeights.slice(0, splitIdx + 1);\n        const curve1 = new NURBSCurve(this.degree, points1, knots1, weights1);\n        const knots2 = newKnots.slice(splitIdx);\n        const points2 = newPoints.slice(splitIdx);\n        const weights2 = newWeights.slice(splitIdx);\n        const curve2 = new NURBSCurve(this.degree, points2, knots2, weights2);\n        return [\n            curve1,\n            curve2\n        ];\n    }\n    _insertKnot(u, knots, points, weights) {\n        const span = this._findKnotSpan(u);\n        const newKnots = [\n            ...knots.slice(0, span + 1),\n            u,\n            ...knots.slice(span + 1)\n        ];\n        const newPoints = [];\n        const newWeights = [];\n        for (let i = 0; i <= span - this.degree; i++) {\n            newPoints[i] = points[i].clone();\n            newWeights[i] = weights[i];\n        }\n        for (let i = span - this.degree + 1; i < points.length; i++) {\n            newPoints[i + 1] = points[i].clone();\n            newWeights[i + 1] = weights[i];\n        }\n        const Q = [];\n        const W = [];\n        for (let i = 0; i <= this.degree; i++) {\n            const idx = span - this.degree + i;\n            const alpha = (u - knots[idx]) / (knots[idx + this.degree] - knots[idx]);\n            Q[i] = points[idx - 1].scale(1 - alpha).add(points[idx].scale(alpha));\n            W[i] = weights[idx - 1] * (1 - alpha) + weights[idx] * alpha;\n        }\n        for (let i = 0; i <= this.degree; i++) {\n            newPoints[span - this.degree + i] = Q[i];\n            newWeights[span - this.degree + i] = W[i];\n        }\n        return {\n            knots: newKnots,\n            points: newPoints,\n            weights: newWeights\n        };\n    }\n    _getCachedBasis(span, t) {\n        const key = `${ span },${ t.toFixed(6) }`;\n        if (!this._basisCache.has(key)) {\n            this._basisCache.set(key, this._basisFunctions(span, t));\n        }\n        return this._basisCache.get(key);\n    }\n    _getCachedDerivatives(span, t, order) {\n        const key = `${ span },${ t.toFixed(6) },${ order }`;\n        if (!this._derivativeCache.has(key)) {\n            this._derivativeCache.set(key, this._basisDerivatives(span, t, order));\n        }\n        return this._derivativeCache.get(key);\n    }\n    trim(t1, t2) {\n        const [tMin, tMax] = this.getDomain();\n        if (t1 < tMin || t2 > tMax || t1 >= t2) {\n            throw new Error(`Trim parameters t1=${ t1 }, t2=${ t2 } must satisfy ${ tMin } <= t1 < t2 <= ${ tMax }`);\n        }\n        const [curveA, curveB] = this.split(t1);\n        const [curveC, curveD] = curveB.split(t2 - t1);\n        return curveC;\n    }\n    intersect(otherCurve, tolerance = 0.000001, maxIterations = 100) {\n        const [tMin1, tMax1] = this.getDomain();\n        const [tMin2, tMax2] = otherCurve.getDomain();\n        const intersections = [];\n        const subdivide = (t1a, t1b, t2a, t2b, depth = 0) => {\n            if (depth > 10)\n                return;\n            const aabb1 = this._computeAABB(t1a, t1b);\n            const aabb2 = otherCurve._computeAABB(t2a, t2b);\n            if (!this._aabbIntersect(aabb1, aabb2))\n                return;\n            const p1a = this.evaluate(t1a);\n            const p1b = this.evaluate(t1b);\n            const p2a = otherCurve.evaluate(t2a);\n            const p2b = otherCurve.evaluate(t2b);\n            const d1 = p1a.distanceTo(p1b);\n            const d2 = p2a.distanceTo(p2b);\n            if (d1 < tolerance && d2 < tolerance) {\n                const t1 = (t1a + t1b) / 2;\n                const t2 = (t2a + t2b) / 2;\n                if (this.evaluate(t1).distanceTo(otherCurve.evaluate(t2)) < tolerance) {\n                    intersections.push({\n                        t1,\n                        t2\n                    });\n                }\n                return;\n            }\n            const t1m = (t1a + t1b) / 2;\n            const t2m = (t2a + t2b) / 2;\n            subdivide(t1a, t1m, t2a, t2m, depth + 1);\n            subdivide(t1a, t1m, t2m, t2b, depth + 1);\n            subdivide(t1m, t1b, t2a, t2m, depth + 1);\n            subdivide(t1m, t1b, t2m, t2b, depth + 1);\n        };\n        subdivide(tMin1, tMax1, tMin2, tMax2);\n        const refined = [];\n        for (let {t1, t2} of intersections) {\n            let t1Refined = t1, t2Refined = t2;\n            for (let i = 0; i < maxIterations; i++) {\n                const P1 = this.evaluate(t1Refined);\n                const P2 = otherCurve.evaluate(t2Refined);\n                const V = P1.subtract(P2);\n                const dC1 = this.derivative(t1Refined, 1);\n                const dC2 = otherCurve.derivative(t2Refined, 1);\n                const F = [\n                    V.x,\n                    V.y,\n                    V.z\n                ];\n                const J = [\n                    [\n                        dC1.x,\n                        -dC2.x\n                    ],\n                    [\n                        dC1.y,\n                        -dC2.y\n                    ],\n                    [\n                        dC1.z,\n                        -dC2.z\n                    ]\n                ];\n                const JTJ = [\n                    [\n                        J[0][0] * J[0][0] + J[1][0] * J[1][0] + J[2][0] * J[2][0],\n                        J[0][0] * J[0][1] + J[1][0] * J[1][1] + J[2][0] * J[2][1]\n                    ],\n                    [\n                        J[0][1] * J[0][0] + J[1][1] * J[1][0] + J[2][1] * J[2][0],\n                        J[0][1] * J[0][1] + J[1][1] * J[1][1] + J[2][1] * J[2][1]\n                    ]\n                ];\n                const JTF = [\n                    J[0][0] * F[0] + J[1][0] * F[1] + J[2][0] * F[2],\n                    J[0][1] * F[0] + J[1][1] * F[1] + J[2][1] * F[2]\n                ];\n                const det = JTJ[0][0] * JTJ[1][1] - JTJ[0][1] * JTJ[1][0];\n                if (Math.abs(det) < tolerance)\n                    break;\n                const deltaT1 = (JTJ[1][1] * JTF[0] - JTJ[0][1] * JTF[1]) / det;\n                const deltaT2 = (-JTJ[1][0] * JTF[0] + JTJ[0][0] * JTF[1]) / det;\n                t1Refined -= deltaT1;\n                t2Refined -= deltaT2;\n                t1Refined = Math.max(tMin1, Math.min(tMax1, t1Refined));\n                t2Refined = Math.max(tMin2, Math.min(tMax2, t2Refined));\n                if (Math.abs(deltaT1) < tolerance && Math.abs(deltaT2) < tolerance) {\n                    if (this.evaluate(t1Refined).distanceTo(otherCurve.evaluate(t2Refined)) < tolerance) {\n                        refined.push({\n                            t1: t1Refined,\n                            t2: t2Refined\n                        });\n                    }\n                    break;\n                }\n            }\n        }\n        return refined;\n    }\n    clearCache() {\n        this._basisCache.clear();\n        this._derivativeCache.clear();\n    }\n    _computeAABB(tStart, tEnd, samples = 5) {\n        const dt = (tEnd - tStart) / (samples - 1);\n        let minX = Infinity, minY = Infinity, minZ = Infinity;\n        let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;\n        for (let i = 0; i < samples; i++) {\n            const t = tStart + i * dt;\n            const p = this.evaluate(t);\n            minX = Math.min(minX, p.x);\n            minY = Math.min(minY, p.y);\n            minZ = Math.min(minZ, p.z);\n            maxX = Math.max(maxX, p.x);\n            maxY = Math.max(maxY, p.y);\n            maxZ = Math.max(maxZ, p.z);\n        }\n        return {\n            min: new Point(minX, minY, minZ),\n            max: new Point(maxX, maxY, maxZ)\n        };\n    }\n    _aabbIntersect(aabb1, aabb2) {\n        return aabb1.min.x <= aabb2.max.x && aabb1.max.x >= aabb2.min.x && aabb1.min.y <= aabb2.max.y && aabb1.max.y >= aabb2.min.y && aabb1.min.z <= aabb2.max.z && aabb1.max.z >= aabb2.min.z;\n    }\n    elevateDegree() {\n        const newDegree = this.degree + 1;\n        const n = this.n;\n        const newControlPoints = Array(n + 2);\n        const newWeights = Array(n + 2);\n        const newKnots = Array(n + newDegree + 2);\n        // Copy boundary knots\n        for (let i = 0; i <= this.degree; i++) {\n            newKnots[i] = this.knots[0];\n            newKnots[newKnots.length - 1 - i] = this.knots[this.knots.length - 1];\n        }\n        // Compute new control points and weights\n        newControlPoints[0] = this.controlPoints[0].clone();\n        newWeights[0] = this.weights[0];\n        for (let i = 1; i <= n + 1; i++) {\n            const alpha = i / (n + 1);\n            newControlPoints[i] = this.controlPoints[i - 1].scale(1 - alpha).add(this.controlPoints[Math.min(i, n)].scale(alpha));\n            newWeights[i] = this.weights[i - 1] * (1 - alpha) + this.weights[Math.min(i, n)] * alpha;\n        }\n        // Insert interior knots (uniform distribution for simplicity)\n        for (let i = this.degree + 1; i <= n + 1; i++) {\n            newKnots[i] = (i - this.degree) / (n - this.degree + 2);\n        }\n        return new NURBSCurve(newDegree, newControlPoints, newKnots, newWeights);\n    }\n    static fitPoints(points, degree = 3) {\n        if (!Array.isArray(points) || points.length < degree + 1) {\n            throw new Error('At least degree + 1 points are required for fitting');\n        }\n        const n = points.length - 1;\n        const knots = Array(n + degree + 2).fill(0);\n        const weights = Array(points.length).fill(1);\n        // Generate uniform knots\n        for (let i = degree + 1; i <= n; i++) {\n            knots[i] = (i - degree) / (n - degree + 1);\n        }\n        for (let i = n + 1; i <= n + degree + 1; i++) {\n            knots[i] = 1;\n        }\n        // Simple interpolation (centripetal parameterization)\n        const params = [];\n        let totalLength = 0;\n        for (let i = 1; i < points.length; i++) {\n            totalLength += Math.sqrt(points[i].distanceTo(points[i - 1]));\n        }\n        let cumulative = 0;\n        params.push(0);\n        for (let i = 1; i < points.length - 1; i++) {\n            cumulative += Math.sqrt(points[i].distanceTo(points[i - 1]));\n            params.push(cumulative / totalLength);\n        }\n        params.push(1);\n        // For simplicity, use input points as control points (refinement can be added later)\n        const controlPoints = points.map(p => p.clone());\n        return new NURBSCurve(degree, controlPoints, knots, weights);\n    }\n    curvature(t) {\n        const d1 = this.derivative(t, 1);\n        const d2 = this.derivative(t, 2);\n        const d1Mag = d1.magnitude();\n        if (d1Mag < 0.000001) {\n            return 0;\n        }\n        // Avoid division by zero\n        const numerator = d1.cross(d2).magnitude();\n        const denominator = d1Mag * d1Mag * d1Mag;\n        return numerator / denominator;\n    }\n    reduceDegree(tolerance = 0.000001) {\n        if (this.degree <= 1) {\n            throw new Error('Cannot reduce degree below 1');\n        }\n        const newDegree = this.degree - 1;\n        const n = this.n;\n        const newControlPoints = Array(n).fill(null);\n        const newWeights = Array(n).fill(0);\n        const newKnots = Array(n + newDegree + 2).fill(0);\n        // Copy boundary knots\n        for (let i = 0; i <= newDegree; i++) {\n            newKnots[i] = this.knots[0];\n            newKnots[n + newDegree + 1 - i] = this.knots[this.knots.length - 1];\n        }\n        for (let i = newDegree + 1; i <= n; i++) {\n            newKnots[i] = (i - newDegree) / (n - newDegree + 1);\n        }\n        // Approximate control points by least-squares fitting\n        const samples = Math.max(n * 2, 10);\n        const domain = this.getDomain();\n        const dt = (domain[1] - domain[0]) / (samples - 1);\n        const samplePoints = [];\n        for (let i = 0; i < samples; i++) {\n            const t = domain[0] + i * dt;\n            samplePoints.push(this.evaluate(t));\n        }\n        // Fit a lower-degree curve to the sampled points\n        const tempCurve = NURBSCurve.fitPoints(samplePoints, newDegree);\n        for (let i = 0; i < n; i++) {\n            newControlPoints[i] = tempCurve.controlPoints[i] || tempCurve.controlPoints[tempCurve.controlPoints.length - 1];\n            newWeights[i] = tempCurve.weights[i] || tempCurve.weights[tempCurve.weights.length - 1];\n        }\n        const reducedCurve = new NURBSCurve(newDegree, newControlPoints, newKnots, newWeights);\n        // Verify approximation within tolerance\n        for (let i = 0; i < samples; i++) {\n            const t = domain[0] + i * dt;\n            const originalPoint = this.evaluate(t);\n            const reducedPoint = reducedCurve.evaluate(t);\n            if (originalPoint.distanceTo(reducedPoint) > tolerance) {\n                throw new Error('Degree reduction exceeds tolerance; consider increasing tolerance or refining fit');\n            }\n        }\n        return reducedCurve;\n    }\n}\nexport class NURBSSurface {\n    constructor(degreeU, degreeV, controlPoints, knotsU, knotsV, weights, trimmingLoops = []) {\n        this.degreeU = degreeU;\n        this.degreeV = degreeV;\n        this.controlPoints = controlPoints.map(row => row.map(p => p.clone()));\n        this.knotsU = [...knotsU];\n        this.knotsV = [...knotsV];\n        this.weights = weights.map(row => [...row]);\n        this.nU = controlPoints.length - 1;\n        this.nV = controlPoints[0].length - 1;\n        this._basisCacheU = new Map();\n        this._basisCacheV = new Map();\n        this._derivativeCacheU = new Map();\n        this._derivativeCacheV = new Map();\n        this.trimmingLoops = [];\n        this._precomputedPolygons = [];\n        // Array of { type, polygon: [{u, v}], bounds: {uMin, uMax, vMin, vMax} }\n        this._precomputeTrimmingLoops(trimmingLoops);\n    }\n    evaluate(u, v) {\n        const [uMin, uMax] = this.getDomainU();\n        const [vMin, vMax] = this.getDomainV();\n        if (u < uMin || u > uMax || v < vMin || v > vMax) {\n            throw new Error(`UV parameters (${ u }, ${ v }) outside domain [${ uMin }, ${ uMax }] x [${ vMin }, ${ vMax }]`);\n        }\n        // Check trimming loops\n        if (!this._isPointValid(u, v)) {\n            return null;\n        }\n        // Point is outside trimmed region or inside a hole\n        const spanU = this._findKnotSpan(u, this.knotsU, this.degreeU, this.nU);\n        const spanV = this._findKnotSpan(v, this.knotsV, this.degreeV, this.nV);\n        const basisU = this._getCachedBasis(spanU, u, this.knotsU, this.degreeU, this._basisCacheU);\n        const basisV = this._getCachedBasis(spanV, v, this.knotsV, this.degreeV, this._basisCacheV);\n        let x = 0, y = 0, z = 0, w = 0;\n        for (let i = 0; i <= this.degreeU; i++) {\n            const idxU = spanU - this.degreeU + i;\n            for (let j = 0; j <= this.degreeV; j++) {\n                const idxV = spanV - this.degreeV + j;\n                const b = basisU[i] * basisV[j] * this.weights[idxU][idxV];\n                x += this.controlPoints[idxU][idxV].x * b;\n                y += this.controlPoints[idxU][idxV].y * b;\n                z += this.controlPoints[idxU][idxV].z * b;\n                w += b;\n            }\n        }\n        return new Point(x / w, y / w, z / w);\n    }\n    derivative(u, v, orderU = 0, orderV = 0) {\n        if (orderU < 0 || orderV < 0 || !Number.isInteger(orderU) || !Number.isInteger(orderV)) {\n            throw new Error('Derivative orders must be non-negative integers');\n        }\n        if (orderU > this.degreeU || orderV > this.degreeV) {\n            return new Vector(0, 0, 0);\n        }\n        const spanU = this._findKnotSpan(u, this.knotsU, this.degreeU, this.nU);\n        const spanV = this._findKnotSpan(v, this.knotsV, this.degreeV, this.nV);\n        const dersU = this._getCachedDerivatives(spanU, u, this.knotsU, this.degreeU, orderU, this._derivativeCacheU);\n        const dersV = this._getCachedDerivatives(spanV, v, this.knotsV, this.degreeV, orderV, this._derivativeCacheV);\n        const Aders = Array(orderU + 1).fill().map(() => Array(orderV + 1).fill().map(() => ({\n            x: 0,\n            y: 0,\n            z: 0,\n            w: 0\n        })));\n        for (let i = 0; i <= this.degreeU; i++) {\n            const idxU = spanU - this.degreeU + i;\n            for (let j = 0; j <= this.degreeV; j++) {\n                const idxV = spanV - this.degreeV + j;\n                const w = this.weights[idxU][idxV];\n                const p = this.controlPoints[idxU][idxV];\n                for (let ku = 0; ku <= orderU; ku++) {\n                    for (let kv = 0; kv <= orderV; kv++) {\n                        const b = dersU[ku][i] * dersV[kv][j] * w;\n                        Aders[ku][kv].x += p.x * b;\n                        Aders[ku][kv].y += p.y * b;\n                        Aders[ku][kv].z += p.z * b;\n                        Aders[ku][kv].w += b;\n                    }\n                }\n            }\n        }\n        if (orderU === 0 && orderV === 0) {\n            const w = Aders[0][0].w;\n            return new Point(Aders[0][0].x / w, Aders[0][0].y / w, Aders[0][0].z / w);\n        }\n        const w = Aders[0][0].w;\n        const wInv = 1 / w;\n        const wInv2 = wInv * wInv;\n        let result = new Vector(0, 0, 0);\n        if (orderU === 1 && orderV === 0) {\n            const A1 = Aders[1][0];\n            const w1 = A1.w;\n            result.x = (A1.x - w1 * Aders[0][0].x) * wInv2;\n            result.y = (A1.y - w1 * Aders[0][0].y) * wInv2;\n            result.z = (A1.z - w1 * Aders[0][0].z) * wInv2;\n        } else if (orderU === 0 && orderV === 1) {\n            const A1 = Aders[0][1];\n            const w1 = A1.w;\n            result.x = (A1.x - w1 * Aders[0][0].x) * wInv2;\n            result.y = (A1.y - w1 * Aders[0][0].y) * wInv2;\n            result.z = (A1.z - w1 * Aders[0][0].z) * wInv2;\n        } else {\n            for (let ku = 0; ku <= orderU; ku++) {\n                for (let kv = 0; kv <= orderV; kv++) {\n                    if (ku + kv === 0)\n                        continue;\n                    const coef = this._binomial(orderU, ku) * this._binomial(orderV, kv);\n                    const sign = (orderU - ku + (orderV - kv)) % 2 === 0 ? 1 : -1;\n                    const A = Aders[ku][kv];\n                    const wTerm = Aders[orderU - ku][orderV - kv].w * coef * sign;\n                    result.x += (A.x - wTerm * Aders[0][0].x) * wInv2;\n                    result.y += (A.y - wTerm * Aders[0][0].y) * wInv2;\n                    result.z += (A.z - wTerm * Aders[0][0].z) * wInv2;\n                }\n            }\n        }\n        return result;\n    }\n    _findKnotSpan(t, knots, degree, n) {\n        if (t < knots[0] || t > knots[knots.length - 1]) {\n            throw new Error(`Parameter t=${ t } is outside knot range [${ knots[0] }, ${ knots[knots.length - 1] }]`);\n        }\n        if (t === knots[knots.length - 1]) {\n            return n;\n        }\n        let low = degree;\n        let high = n + 1;\n        let mid = Math.floor((low + high) / 2);\n        while (t < knots[mid] || t >= knots[mid + 1]) {\n            if (t < knots[mid])\n                high = mid;\n            else\n                low = mid;\n            mid = Math.floor((low + high) / 2);\n        }\n        return mid;\n    }\n    _basisFunctions(span, t, knots, degree) {\n        const N = [1];\n        const left = [];\n        const right = [];\n        for (let j = 1; j <= degree; j++) {\n            left[j] = t - knots[span + 1 - j];\n            right[j] = knots[span + j] - t;\n            let saved = 0;\n            for (let r = 0; r < j; r++) {\n                const temp = N[r] / (right[r + 1] + left[j - r]);\n                N[r] = saved + right[r + 1] * temp;\n                saved = left[j - r] * temp;\n            }\n            N[j] = saved;\n        }\n        return N;\n    }\n    _basisDerivatives(span, t, knots, degree, n) {\n        const ders = Array(n + 1).fill().map(() => Array(degree + 1).fill(0));\n        const ndu = Array(degree + 1).fill().map(() => Array(degree + 1).fill(0));\n        const left = Array(degree + 1).fill(0);\n        const right = Array(degree + 1).fill(0);\n        ndu[0][0] = 1;\n        for (let j = 1; j <= degree; j++) {\n            left[j] = t - knots[span + 1 - j];\n            right[j] = knots[span + j] - t;\n            let saved = 0;\n            for (let r = 0; r < j; r++) {\n                ndu[j][r] = right[r + 1] + left[j - r];\n                const temp = ndu[r][j - 1] / ndu[j][r];\n                ndu[r][j] = saved + right[r + 1] * temp;\n                saved = left[j - r] * temp;\n            }\n            ndu[j][j] = saved;\n        }\n        for (let j = 0; j <= degree; j++) {\n            ders[0][j] = ndu[j][degree];\n        }\n        for (let r = 0; r <= degree; r++) {\n            let s1 = 0, s2 = 1;\n            const a = Array(degree + 1).fill().map(() => Array(degree + 1).fill(0));\n            a[0][0] = 1;\n            for (let k = 1; k <= n; k++) {\n                let d = 0;\n                const rk = r - k;\n                const pk = degree - k;\n                if (r >= k) {\n                    a[s2][0] = a[s1][0] / ndu[pk + 1][rk];\n                    d = a[s2][0] * ndu[rk][pk];\n                }\n                const j1 = rk >= -1 ? 1 : -rk;\n                const j2 = r - 1 <= pk ? k - 1 : degree - r;\n                for (let j = j1; j <= j2; j++) {\n                    a[s2][j] = (a[s1][j] - a[s1][j - 1]) / ndu[pk + 1][rk + j];\n                    d += a[s2][j] * ndu[rk + j][pk];\n                }\n                if (r <= pk) {\n                    a[s2][k] = -a[s1][k - 1] / ndu[pk + 1][r];\n                    d += a[s2][k] * ndu[r][pk];\n                }\n                ders[k][r] = d;\n                [s1, s2] = [\n                    s2,\n                    s1\n                ];\n            }\n        }\n        let r = degree;\n        for (let k = 1; k <= n; k++) {\n            for (let j = 0; j <= degree; j++) {\n                ders[k][j] *= r;\n            }\n            r *= degree - k;\n        }\n        return ders;\n    }\n    _getCachedBasis(span, t, knots, degree, cache) {\n        const key = `${ span },${ t.toFixed(6) }`;\n        if (!cache.has(key)) {\n            cache.set(key, this._basisFunctions(span, t, knots, degree));\n        }\n        return cache.get(key);\n    }\n    getDomainU() {\n        return [\n            this.knotsU[this.degreeU],\n            this.knotsU[this.nU + 1]\n        ];\n    }\n    getDomainV() {\n        return [\n            this.knotsV[this.degreeV],\n            this.knotsV[this.nV + 1]\n        ];\n    }\n    toString() {\n        return `NURBSSurface(degreeU=${ this.degreeU }, degreeV=${ this.degreeV }, nU=${ this.nU }, nV=${ this.nV }, loops=${ this.trimmingLoops.length })`;\n    }\n    _getCachedDerivatives(span, t, knots, degree, order, cache) {\n        const key = `${ span },${ t.toFixed(6) },${ order }`;\n        if (!cache.has(key)) {\n            cache.set(key, this._basisDerivatives(span, t, knots, degree, order));\n        }\n        return cache.get(key);\n    }\n    _binomial(n, k) {\n        if (k < 0 || k > n)\n            return 0;\n        let result = 1;\n        for (let i = 0; i < k; i++) {\n            result *= (n - i) / (i + 1);\n        }\n        return result;\n    }\n    trim(u1, u2, v1, v2) {\n        const [uMin, uMax] = this.getDomainU();\n        const [vMin, vMax] = this.getDomainV();\n        if (u1 < uMin || u2 > uMax || u1 >= u2 || v1 < vMin || v2 > vMax || v1 >= v2) {\n            throw new Error(`Trim parameters u1=${ u1 }, u2=${ u2 }, v1=${ v1 }, v2=${ v2 } must satisfy ${ uMin } <= u1 < u2 <= ${ uMax } and ${ vMin } <= v1 < v2 <= ${ vMax }`);\n        }\n        let knotsU = [...this.knotsU];\n        let controlPoints = this.controlPoints.map(row => row.map(p => p.clone()));\n        let weights = this.weights.map(row => [...row]);\n        const insertKnots = (t, knots, degree, dir) => {\n            const span = this._findKnotSpan(t, knots, degree, dir === 'u' ? this.nU : this.nV);\n            let multiplicity = 0;\n            for (let i = span; i >= 0 && Math.abs(knots[i] - t) < 0.000001; i--) {\n                multiplicity++;\n            }\n            return degree - multiplicity;\n        };\n        let insertsU1 = insertKnots(u1, knotsU, this.degreeU, 'u');\n        let insertsU2 = insertKnots(u2, knotsU, this.degreeU, 'u');\n        for (let i = 0; i < insertsU1; i++) {\n            ({\n                knots: knotsU,\n                points: controlPoints,\n                weights\n            } = this._insertKnotU(u1, knotsU, controlPoints, weights));\n        }\n        for (let i = 0; i < insertsU2; i++) {\n            ({\n                knots: knotsU,\n                points: controlPoints,\n                weights\n            } = this._insertKnotU(u2, knotsU, controlPoints, weights));\n        }\n        let knotsV = [...this.knotsV];\n        let insertsV1 = insertKnots(v1, knotsV, this.degreeV, 'v');\n        let insertsV2 = insertKnots(v2, knotsV, this.degreeV, 'v');\n        for (let i = 0; i < insertsV1; i++) {\n            ({\n                knots: knotsV,\n                points: controlPoints,\n                weights\n            } = this._insertKnotV(v1, knotsV, controlPoints, weights));\n        }\n        for (let i = 0; i < insertsV2; i++) {\n            ({\n                knots: knotsV,\n                points: controlPoints,\n                weights\n            } = this._insertKnotV(v2, knotsV, controlPoints, weights));\n        }\n        let startU = 0, endU = 0, startV = 0, endV = 0;\n        for (let i = 0; i < knotsU.length; i++) {\n            if (knotsU[i] >= u1 - 0.000001) {\n                startU = i - this.degreeU;\n                break;\n            }\n        }\n        for (let i = 0; i < knotsU.length; i++) {\n            if (knotsU[i] >= u2 - 0.000001) {\n                endU = i - this.degreeU;\n                break;\n            }\n        }\n        for (let i = 0; i < knotsV.length; i++) {\n            if (knotsV[i] >= v1 - 0.000001) {\n                startV = i - this.degreeV;\n                break;\n            }\n        }\n        for (let i = 0; i < knotsV.length; i++) {\n            if (knotsV[i] >= v2 - 0.000001) {\n                endV = i - this.degreeV;\n                break;\n            }\n        }\n        const trimmedKnotsU = knotsU.slice(startU, endU + this.degreeU + 1);\n        const trimmedKnotsV = knotsV.slice(startV, endV + this.degreeV + 1);\n        const trimmedPoints = controlPoints.slice(startU, endU + 1).map(row => row.slice(startV, endV + 1));\n        const trimmedWeights = weights.slice(startU, endU + 1).map(row => row.slice(startV, endV + 1));\n        return new NURBSSurface(this.degreeU, this.degreeV, trimmedPoints, trimmedKnotsU, trimmedKnotsV, trimmedWeights);\n    }\n    _insertKnotU(u, knotsU, controlPoints, weights) {\n        const span = this._findKnotSpan(u, knotsU, this.degreeU, this.nU);\n        const newKnotsU = [\n            ...knotsU.slice(0, span + 1),\n            u,\n            ...knotsU.slice(span + 1)\n        ];\n        const newPoints = [];\n        const newWeights = [];\n        for (let i = 0; i <= span - this.degreeU; i++) {\n            newPoints[i] = controlPoints[i].map(p => p.clone());\n            newWeights[i] = [...weights[i]];\n        }\n        for (let i = span - this.degreeU + 1; i < controlPoints.length; i++) {\n            newPoints[i + 1] = controlPoints[i].map(p => p.clone());\n            newWeights[i + 1] = [...weights[i]];\n        }\n        const Q = [];\n        const W = [];\n        for (let i = 0; i <= this.degreeU; i++) {\n            const idx = span - this.degreeU + i;\n            const alpha = (u - knotsU[idx]) / (knotsU[idx + this.degreeU] - knotsU[idx]);\n            Q[i] = controlPoints[idx - 1].map((p, j) => p.scale(1 - alpha).add(controlPoints[idx][j].scale(alpha)));\n            W[i] = weights[idx - 1].map((w, j) => w * (1 - alpha) + weights[idx][j] * alpha);\n        }\n        for (let i = 0; i <= this.degreeU; i++) {\n            newPoints[span - this.degreeU + i] = Q[i];\n            newWeights[span - this.degreeU + i] = W[i];\n        }\n        return {\n            knots: newKnotsU,\n            points: newPoints,\n            weights: newWeights\n        };\n    }\n    _insertKnotV(v, knotsV, controlPoints, weights) {\n        const span = this._findKnotSpan(v, knotsV, this.degreeV, this.nV);\n        const newKnotsV = [\n            ...knotsV.slice(0, span + 1),\n            v,\n            ...knotsV.slice(span + 1)\n        ];\n        const newPoints = controlPoints.map(row => row.map(p => p.clone()));\n        const newWeights = weights.map(row => [...row]);\n        const Q = [];\n        const W = [];\n        for (let j = 0; j <= this.degreeV; j++) {\n            const idx = span - this.degreeV + j;\n            const alpha = (v - knotsV[idx]) / (knotsV[idx + this.degreeV] - knotsV[idx]);\n            Q[j] = [];\n            W[j] = [];\n            for (let i = 0; i < controlPoints.length; i++) {\n                Q[j][i] = controlPoints[i][idx - 1].scale(1 - alpha).add(controlPoints[i][idx].scale(alpha));\n                W[j][i] = weights[i][idx - 1] * (1 - alpha) + weights[i][idx] * alpha;\n            }\n        }\n        for (let j = 0; j <= this.degreeV; j++) {\n            for (let i = 0; i < controlPoints.length; i++) {\n                newPoints[i][span - this.degreeV + j] = Q[j][i];\n                newWeights[i][span - this.degreeV + j] = W[j][i];\n            }\n        }\n        return {\n            knots: newKnotsV,\n            points: newPoints,\n            weights: newWeights\n        };\n    }\n    clearCache() {\n        this._basisCacheU.clear();\n        this._basisCacheV.clear();\n        this._derivativeCacheU.clear();\n        this._derivativeCacheV.clear();\n    }\n    _computeAABB(uStart, uEnd, vStart, vEnd, samples = 5) {\n        const du = (uEnd - uStart) / (samples - 1);\n        const dv = (vEnd - vStart) / (samples - 1);\n        let minX = Infinity, minY = Infinity, minZ = Infinity;\n        let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;\n        for (let i = 0; i < samples; i++) {\n            const u = uStart + i * du;\n            for (let j = 0; j < samples; j++) {\n                const v = vStart + j * dv;\n                const p = this.evaluate(u, v);\n                minX = Math.min(minX, p.x);\n                minY = Math.min(minY, p.y);\n                minZ = Math.min(minZ, p.z);\n                maxX = Math.max(maxX, p.x);\n                maxY = Math.max(maxY, p.y);\n                maxZ = Math.max(maxZ, p.z);\n            }\n        }\n        return {\n            min: new Point(minX, minY, minZ),\n            max: new Point(maxX, maxY, maxZ)\n        };\n    }\n    _aabbIntersect(aabb1, aabb2) {\n        return aabb1.min.x <= aabb2.max.x && aabb1.max.x >= aabb2.min.x && aabb1.min.y <= aabb2.max.y && aabb1.max.y >= aabb2.min.y && aabb1.min.z <= aabb2.max.z && aabb1.max.z >= aabb2.min.z;\n    }\n    intersectSurface(otherSurface, tolerance = 0.000001, maxIterations = 100) {\n        const [uMin1, uMax1] = this.getDomainU();\n        const [vMin1, vMax1] = this.getDomainV();\n        const [uMin2, uMax2] = otherSurface.getDomainU();\n        const [vMin2, vMax2] = otherSurface.getDomainV();\n        const seeds = [];\n        const subdivide = (u1a, u1b, v1a, v1b, u2a, u2b, v2a, v2b, depth = 0) => {\n            if (depth > 10)\n                return;\n            const aabb1 = this._computeAABB(u1a, u1b, v1a, v1b);\n            const aabb2 = otherSurface._computeAABB(u2a, u2b, v2a, v2b);\n            if (!this._aabbIntersect(aabb1, aabb2))\n                return;\n            const p1a = this.evaluate(u1a, v1a);\n            const p1b = this.evaluate(u1b, v1b);\n            const p2a = otherSurface.evaluate(u2a, v2a);\n            const p2b = otherSurface.evaluate(u2b, v2b);\n            const d1 = p1a.distanceTo(p1b);\n            const d2 = p2a.distanceTo(p2b);\n            if (d1 < tolerance && d2 < tolerance) {\n                const u1 = (u1a + u1b) / 2;\n                const v1 = (v1a + v1b) / 2;\n                const u2 = (u2a + u2b) / 2;\n                const v2 = (v2a + v2b) / 2;\n                if (this.evaluate(u1, v1).distanceTo(otherSurface.evaluate(u2, v2)) < tolerance) {\n                    seeds.push({\n                        u1,\n                        v1,\n                        u2,\n                        v2\n                    });\n                }\n                return;\n            }\n            const u1m = (u1a + u1b) / 2;\n            const v1m = (v1a + v1b) / 2;\n            const u2m = (u2a + u2b) / 2;\n            const v2m = (v2a + v2b) / 2;\n            subdivide(u1a, u1m, v1a, v1m, u2a, u2m, v2a, v2m, depth + 1);\n            subdivide(u1a, u1m, v1m, v1b, u2a, u2m, v2m, v2b, depth + 1);\n            subdivide(u1m, u1b, v1a, v1m, u2m, u2b, v2a, v2m, depth + 1);\n            subdivide(u1m, u1b, v1m, v1b, u2m, u2b, v2m, v2b, depth + 1);\n        };\n        subdivide(uMin1, uMax1, vMin1, vMax1, uMin2, uMax2, vMin2, vMax2);\n        const curves = [];\n        const usedSeeds = new Set();\n        for (let seed of seeds) {\n            const seedKey = `${ seed.u1.toFixed(6) },${ seed.v1.toFixed(6) },${ seed.u2.toFixed(6) },${ seed.v2.toFixed(6) }`;\n            if (usedSeeds.has(seedKey))\n                continue;\n            const traced = this._traceSurfaceIntersection(seed.u1, seed.v1, seed.u2, seed.v2, otherSurface, tolerance, maxIterations);\n            if (traced && traced.points.length >= 2) {\n                const curve = this._fitCurve(traced.points);\n                curves.push({\n                    curve,\n                    params1: traced.params1,\n                    params2: traced.params2\n                });\n                // Mark seeds as used based on proximity\n                for (let i = 0; i < traced.params1.length; i++) {\n                    const u1 = traced.params1[i].u, v1 = traced.params1[i].v;\n                    const u2 = traced.params2[i].u, v2 = traced.params2[i].v;\n                    usedSeeds.add(`${ u1.toFixed(6) },${ v1.toFixed(6) },${ u2.toFixed(6) },${ v2.toFixed(6) }`);\n                }\n            }\n        }\n        return curves;\n    }\n    intersectCurve(curve, tolerance = 0.000001, maxIterations = 100) {\n        const [tMin, tMax] = curve.getDomain();\n        const [uMin, uMax] = this.getDomainU();\n        const [vMin, vMax] = this.getDomainV();\n        const seeds = [];\n        const subdivide = (ta, tb, ua, ub, va, vb, depth = 0) => {\n            if (depth > 10)\n                return;\n            const aabbCurve = curve._computeAABB(ta, tb);\n            const aabbSurface = this._computeAABB(ua, ub, va, vb);\n            if (!this._aabbIntersect(aabbCurve, aabbSurface))\n                return;\n            const pCa = curve.evaluate(ta);\n            const pCb = curve.evaluate(tb);\n            const dC = pCa.distanceTo(pCb);\n            const pSa = this.evaluate(ua, va);\n            const pSb = this.evaluate(ub, vb);\n            const dS = pSa.distanceTo(pSb);\n            if (dC < tolerance && dS < tolerance) {\n                const t = (ta + tb) / 2;\n                const u = (ua + ub) / 2;\n                const v = (va + vb) / 2;\n                if (curve.evaluate(t).distanceTo(this.evaluate(u, v)) < tolerance) {\n                    seeds.push({\n                        t,\n                        u,\n                        v\n                    });\n                }\n                return;\n            }\n            const tm = (ta + tb) / 2;\n            const um = (ua + ub) / 2;\n            const vm = (va + vb) / 2;\n            subdivide(ta, tm, ua, um, va, vm, depth + 1);\n            subdivide(ta, tm, um, ub, va, vm, depth + 1);\n            subdivide(ta, tm, ua, um, vm, vb, depth + 1);\n            subdivide(ta, tm, um, ub, vm, vb, depth + 1);\n            subdivide(tm, tb, ua, um, va, vm, depth + 1);\n            subdivide(tm, tb, um, ub, va, vm, depth + 1);\n            subdivide(tm, tb, ua, um, vm, vb, depth + 1);\n            subdivide(tm, tb, um, ub, vm, vb, depth + 1);\n        };\n        subdivide(tMin, tMax, uMin, uMax, vMin, vMax);\n        const curves = [];\n        const usedSeeds = new Set();\n        for (let seed of seeds) {\n            const seedKey = `${ seed.t.toFixed(6) },${ seed.u.toFixed(6) },${ seed.v.toFixed(6) }`;\n            if (usedSeeds.has(seedKey))\n                continue;\n            const traced = this._traceCurveIntersection(seed.t, seed.u, seed.v, curve, tolerance, maxIterations);\n            if (traced && traced.points.length >= 2) {\n                const curveFit = this._fitCurve(traced.points);\n                curves.push({\n                    curve: curveFit,\n                    paramsC: traced.paramsC,\n                    paramsS: traced.paramsS\n                });\n                for (let i = 0; i < traced.paramsC.length; i++) {\n                    const t = traced.paramsC[i].t;\n                    const u = traced.paramsS[i].u, v = traced.paramsS[i].v;\n                    usedSeeds.add(`${ t.toFixed(6) },${ u.toFixed(6) },${ v.toFixed(6) }`);\n                }\n            }\n        }\n        return curves;\n    }\n    _solve3x3(matrix, b, det) {\n        const [a, bRow, c] = matrix;\n        const [d, e, f] = b;\n        const x = (bRow[1] * (c[2] * b[0] - c[0] * b[2]) - bRow[2] * (c[1] * b[0] - c[0] * b[1]) + b[0] * (e * f - d * f)) / det;\n        const y = (bRow[2] * (c[0] * b[1] - c[1] * b[0]) - b[0] * (c[2] * b[1] - c[1] * b[2]) + b[1] * (d * f - e * f)) / det;\n        const z = (b[0] * (c[1] * b[2] - c[2] * b[1]) - b[1] * (c[0] * b[2] - c[2] * b[0]) + b[2] * (e * d - d * e)) / det;\n        return [\n            x,\n            y,\n            z\n        ];\n    }\n    _solve4x4(matrix, b, det) {\n        const [a, bRow, c, d] = matrix;\n        const [e, f, g, h] = b;\n        const x = (e * (bRow[1] * (c[2] * d[3] - c[3] * d[2]) - bRow[2] * (c[1] * d[3] - c[3] * d[1]) + bRow[3] * (c[1] * d[2] - c[2] * d[1])) - f * (bRow[0] * (c[2] * d[3] - c[3] * d[2]) - bRow[2] * (c[0] * d[3] - c[3] * d[0]) + bRow[3] * (c[0] * d[2] - c[2] * d[0])) + g * (bRow[0] * (c[1] * d[3] - c[3] * d[1]) - bRow[1] * (c[0] * d[3] - c[3] * d[0]) + bRow[3] * (c[0] * d[1] - c[1] * d[0])) - h * (bRow[0] * (c[1] * d[2] - c[2] * d[1]) - bRow[1] * (c[0] * d[2] - c[2] * d[0]) + bRow[2] * (c[0] * d[1] - c[1] * d[0]))) / det;\n        const y = (f * (a[0] * (c[2] * d[3] - c[3] * d[2]) - a[2] * (c[0] * d[3] - c[3] * d[0]) + a[3] * (c[0] * d[2] - c[2] * d[0])) - e * (a[1] * (c[2] * d[3] - c[3] * d[2]) - a[2] * (c[1] * d[3] - c[3] * d[1]) + a[3] * (c[1] * d[2] - c[2] * d[1])) + g * (a[0] * (c[1] * d[3] - c[3] * d[1]) - a[1] * (c[0] * d[3] - c[3] * d[0]) + a[3] * (c[0] * d[1] - c[1] * d[0])) - h * (a[0] * (c[1] * d[2] - c[2] * d[1]) - a[1] * (c[0] * d[2] - c[2] * d[0]) + a[2] * (c[0] * d[1] - c[1] * d[0]))) / det;\n        const z = (e * (a[1] * (bRow[2] * d[3] - bRow[3] * d[2]) - a[2] * (bRow[1] * d[3] - bRow[3] * d[1]) + a[3] * (bRow[1] * d[2] - bRow[2] * d[1])) - f * (a[0] * (bRow[2] * d[3] - bRow[3] * d[2]) - a[2] * (bRow[0] * d[3] - bRow[3] * d[0]) + a[3] * (bRow[0] * d[2] - bRow[2] * d[0])) + g * (a[0] * (bRow[1] * d[3] - bRow[3] * d[1]) - a[1] * (bRow[0] * d[3] - bRow[3] * d[0]) + a[3] * (bRow[0] * d[1] - bRow[1] * d[0])) - h * (a[0] * (bRow[1] * d[2] - bRow[2] * d[1]) - a[1] * (bRow[0] * d[2] - bRow[2] * d[0]) + a[2] * (bRow[0] * d[1] - bRow[1] * d[0]))) / det;\n        const w = (e * (a[1] * (bRow[2] * c[3] - bRow[3] * c[2]) - a[2] * (bRow[1] * c[3] - bRow[3] * c[1]) + a[3] * (bRow[1] * c[2] - bRow[2] * c[1])) - f * (a[0] * (bRow[2] * c[3] - bRow[3] * c[2]) - a[2] * (bRow[0] * c[3] - bRow[3] * c[0]) + a[3] * (bRow[0] * c[2] - bRow[2] * c[0])) + g * (a[0] * (bRow[1] * c[3] - bRow[3] * c[1]) - a[1] * (bRow[0] * c[3] - bRow[3] * c[0]) + a[3] * (bRow[0] * c[1] - bRow[1] * c[0])) - h * (a[0] * (bRow[1] * c[2] - bRow[2] * c[1]) - a[1] * (bRow[0] * c[2] - bRow[2] * c[0]) + a[2] * (bRow[0] * c[1] - bRow[1] * c[0]))) / det;\n        return [\n            x,\n            y,\n            z,\n            w\n        ];\n    }\n    _fitCurve(points, degree = 2) {\n        const n = points.length - 1;\n        const knots = Array(n + degree + 2).fill(0);\n        for (let i = degree + 1; i <= n; i++) {\n            knots[i] = (i - degree) / (n - degree + 1);\n        }\n        for (let i = n + 1; i < knots.length; i++) {\n            knots[i] = 1;\n        }\n        const weights = Array(points.length).fill(1);\n        return new NURBSCurve(degree, points, knots, weights);\n    }\n    splitAtU(u) {\n        const [uMin, uMax] = this.getDomainU();\n        if (u <= uMin || u >= uMax) {\n            throw new Error(`Split parameter u=${ u } must be within domain (${ uMin }, ${ uMax })`);\n        }\n        let knotsU = [...this.knotsU];\n        let controlPoints = this.controlPoints.map(row => row.map(p => p.clone()));\n        let weights = this.weights.map(row => [...row]);\n        const span = this._findKnotSpan(u, knotsU, this.degreeU, this.nU);\n        let multiplicity = 0;\n        for (let i = span; i >= 0 && Math.abs(knotsU[i] - u) < 0.000001; i--) {\n            multiplicity++;\n        }\n        const insertsNeeded = this.degreeU - multiplicity;\n        for (let i = 0; i < insertsNeeded; i++) {\n            ({\n                knots: knotsU,\n                points: controlPoints,\n                weights\n            } = this._insertKnotU(u, knotsU, controlPoints, weights));\n        }\n        let splitIdx = 0;\n        for (let i = 0; i < knotsU.length; i++) {\n            if (knotsU[i] >= u - 0.000001) {\n                splitIdx = i - this.degreeU;\n                break;\n            }\n        }\n        const knotsU1 = knotsU.slice(0, splitIdx + this.degreeU + 1);\n        const knotsU2 = knotsU.slice(splitIdx);\n        const points1 = controlPoints.slice(0, splitIdx + 1);\n        const points2 = controlPoints.slice(splitIdx);\n        const weights1 = weights.slice(0, splitIdx + 1);\n        const weights2 = weights.slice(splitIdx);\n        return [\n            new NURBSSurface(this.degreeU, this.degreeV, points1, knotsU1, [...this.knotsV], weights1),\n            new NURBSSurface(this.degreeU, this.degreeV, points2, knotsU2, [...this.knotsV], weights2)\n        ];\n    }\n    splitAtV(v) {\n        const [vMin, vMax] = this.getDomainV();\n        if (v <= vMin || v >= vMax) {\n            throw new Error(`Split parameter v=${ v } must be within domain (${ vMin }, ${ vMax })`);\n        }\n        let knotsV = [...this.knotsV];\n        let controlPoints = this.controlPoints.map(row => row.map(p => p.clone()));\n        let weights = this.weights.map(row => [...row]);\n        const span = this._findKnotSpan(v, knotsV, this.degreeV, this.nV);\n        let multiplicity = 0;\n        for (let i = span; i >= 0 && Math.abs(knotsV[i] - v) < 0.000001; i--) {\n            multiplicity++;\n        }\n        const insertsNeeded = this.degreeV - multiplicity;\n        for (let i = 0; i < insertsNeeded; i++) {\n            ({\n                knots: knotsV,\n                points: controlPoints,\n                weights\n            } = this._insertKnotV(v, knotsV, controlPoints, weights));\n        }\n        let splitIdx = 0;\n        for (let i = 0; i < knotsV.length; i++) {\n            if (knotsV[i] >= v - 0.000001) {\n                splitIdx = i - this.degreeV;\n                break;\n            }\n        }\n        const knotsV1 = knotsV.slice(0, splitIdx + this.degreeV + 1);\n        const knotsV2 = knotsV.slice(splitIdx);\n        const points1 = controlPoints.map(row => row.slice(0, splitIdx + 1));\n        const points2 = controlPoints.map(row => row.slice(splitIdx));\n        const weights1 = weights.map(row => row.slice(0, splitIdx + 1));\n        const weights2 = weights.map(row => row.slice(splitIdx));\n        return [\n            new NURBSSurface(this.degreeU, this.degreeV, points1, [...this.knotsU], knotsV1, weights1),\n            new NURBSSurface(this.degreeU, this.degreeV, points2, [...this.knotsU], knotsV2, weights2)\n        ];\n    }\n    _refineSurfaceIntersection(u1, v1, u2, v2, otherSurface, tolerance, maxIterations) {\n        const [uMin1, uMax1] = this.getDomainU();\n        const [vMin1, vMax1] = this.getDomainV();\n        const [uMin2, uMax2] = otherSurface.getDomainU();\n        const [vMin2, vMax2] = otherSurface.getDomainV();\n        let u1Refined = u1, v1Refined = v1, u2Refined = u2, v2Refined = v2;\n        for (let i = 0; i < maxIterations; i++) {\n            const P1 = this.evaluate(u1Refined, v1Refined);\n            const P2 = otherSurface.evaluate(u2Refined, v2Refined);\n            const V = P1.subtract(P2);\n            const dP1u = this.derivative(u1Refined, v1Refined, 1, 0);\n            const dP1v = this.derivative(u1Refined, v1Refined, 0, 1);\n            const dP2u = otherSurface.derivative(u2Refined, v2Refined, 1, 0);\n            const dP2v = otherSurface.derivative(u2Refined, v2Refined, 0, 1);\n            const F = [\n                V.x,\n                V.y,\n                V.z\n            ];\n            const J = [\n                [\n                    dP1u.x,\n                    dP1v.x,\n                    -dP2u.x,\n                    -dP2v.x\n                ],\n                [\n                    dP1u.y,\n                    dP1v.y,\n                    -dP2u.y,\n                    -dP2v.y\n                ],\n                [\n                    dP1u.z,\n                    dP1v.z,\n                    -dP2u.z,\n                    -dP2v.z\n                ]\n            ];\n            const JTJ = [\n                [\n                    J[0][0] * J[0][0] + J[1][0] * J[1][0] + J[2][0] * J[2][0],\n                    J[0][0] * J[0][1] + J[1][0] * J[1][1] + J[2][0] * J[2][1],\n                    J[0][0] * J[0][2] + J[1][0] * J[1][2] + J[2][0] * J[2][2],\n                    J[0][0] * J[0][3] + J[1][0] * J[1][3] + J[2][0] * J[2][3]\n                ],\n                [\n                    J[0][1] * J[0][0] + J[1][1] * J[1][0] + J[2][1] * J[2][0],\n                    J[0][1] * J[0][1] + J[1][1] * J[1][1] + J[2][1] * J[2][1],\n                    J[0][1] * J[0][2] + J[1][1] * J[1][2] + J[2][1] * J[2][2],\n                    J[0][1] * J[0][3] + J[1][1] * J[1][3] + J[2][1] * J[2][3]\n                ],\n                [\n                    J[0][2] * J[0][0] + J[1][2] * J[1][0] + J[2][2] * J[2][0],\n                    J[0][2] * J[0][1] + J[1][2] * J[1][1] + J[2][2] * J[2][1],\n                    J[0][2] * J[0][2] + J[1][2] * J[1][2] + J[2][2] * J[2][2],\n                    J[0][2] * J[0][3] + J[1][2] * J[1][3] + J[2][2] * J[2][3]\n                ],\n                [\n                    J[0][3] * J[0][0] + J[1][3] * J[1][0] + J[2][3] * J[2][0],\n                    J[0][3] * J[0][1] + J[1][3] * J[1][1] + J[2][3] * J[2][1],\n                    J[0][3] * J[0][2] + J[1][3] * J[1][2] + J[2][3] * J[2][2],\n                    J[0][3] * J[0][3] + J[1][3] * J[1][3] + J[2][3] * J[2][3]\n                ]\n            ];\n            const JTF = [\n                J[0][0] * F[0] + J[1][0] * F[1] + J[2][0] * F[2],\n                J[0][1] * F[0] + J[1][1] * F[1] + J[2][1] * F[2],\n                J[0][2] * F[0] + J[1][2] * F[1] + J[2][2] * F[2],\n                J[0][3] * F[0] + J[1][3] * F[1] + J[2][3] * F[2]\n            ];\n            const det = JTJ[0][0] * (JTJ[1][1] * JTJ[2][2] * JTJ[3][3] + JTJ[1][2] * JTJ[2][3] * JTJ[3][1] + JTJ[1][3] * JTJ[2][1] * JTJ[3][2] - JTJ[1][3] * JTJ[2][2] * JTJ[3][1] - JTJ[1][1] * JTJ[2][3] * JTJ[3][2] - JTJ[1][2] * JTJ[2][1] * JTJ[3][3]) - JTJ[0][1] * (JTJ[1][0] * JTJ[2][2] * JTJ[3][3] + JTJ[1][2] * JTJ[2][3] * JTJ[3][0] + JTJ[1][3] * JTJ[2][0] * JTJ[3][2] - JTJ[1][3] * JTJ[2][2] * JTJ[3][0] - JTJ[1][0] * JTJ[2][3] * JTJ[3][2] - JTJ[1][2] * JTJ[2][0] * JTJ[3][3]) + JTJ[0][2] * (JTJ[1][0] * JTJ[2][1] * JTJ[3][3] + JTJ[1][1] * JTJ[2][3] * JTJ[3][0] + JTJ[1][3] * JTJ[2][0] * JTJ[3][1] - JTJ[1][3] * JTJ[2][1] * JTJ[3][0] - JTJ[1][0] * JTJ[2][3] * JTJ[3][1] - JTJ[1][1] * JTJ[2][0] * JTJ[3][3]) - JTJ[0][3] * (JTJ[1][0] * JTJ[2][1] * JTJ[3][2] + JTJ[1][1] * JTJ[2][2] * JTJ[3][0] + JTJ[1][2] * JTJ[2][0] * JTJ[3][1] - JTJ[1][2] * JTJ[2][1] * JTJ[3][0] - JTJ[1][0] * JTJ[2][2] * JTJ[3][1] - JTJ[1][1] * JTJ[2][0] * JTJ[3][2]);\n            if (Math.abs(det) < tolerance)\n                break;\n            const delta = this._solve4x4(JTJ, JTF, det);\n            u1Refined -= delta[0];\n            v1Refined -= delta[1];\n            u2Refined -= delta[2];\n            v2Refined -= delta[3];\n            u1Refined = Math.max(uMin1, Math.min(uMax1, u1Refined));\n            v1Refined = Math.max(vMin1, Math.min(vMax1, v1Refined));\n            u2Refined = Math.max(uMin2, Math.min(uMax2, u2Refined));\n            v2Refined = Math.max(vMin2, Math.min(vMax2, v2Refined));\n            if (delta.every(d => Math.abs(d) < tolerance)) {\n                if (this.evaluate(u1Refined, v1Refined).distanceTo(otherSurface.evaluate(u2Refined, v2Refined)) < tolerance) {\n                    return {\n                        u1: u1Refined,\n                        v1: v1Refined,\n                        u2: u2Refined,\n                        v2: v2Refined\n                    };\n                }\n                break;\n            }\n        }\n        return null;\n    }\n    _refineCurveIntersection(t, u, v, curve, tolerance, maxIterations) {\n        const [tMin, tMax] = curve.getDomain();\n        const [uMin, uMax] = this.getDomainU();\n        const [vMin, vMax] = this.getDomainV();\n        let tRefined = t, uRefined = u, vRefined = v;\n        for (let i = 0; i < maxIterations; i++) {\n            const P1 = curve.evaluate(tRefined);\n            const P2 = this.evaluate(uRefined, vRefined);\n            const V = P1.subtract(P2);\n            const dC = curve.derivative(tRefined, 1);\n            const dSu = this.derivative(uRefined, vRefined, 1, 0);\n            const dSv = this.derivative(uRefined, vRefined, 0, 1);\n            const F = [\n                V.x,\n                V.y,\n                V.z\n            ];\n            const J = [\n                [\n                    dC.x,\n                    -dSu.x,\n                    -dSv.x\n                ],\n                [\n                    dC.y,\n                    -dSu.y,\n                    -dSv.y\n                ],\n                [\n                    dC.z,\n                    -dSu.z,\n                    -dSv.z\n                ]\n            ];\n            const JTJ = [\n                [\n                    J[0][0] * J[0][0] + J[1][0] * J[1][0] + J[2][0] * J[2][0],\n                    J[0][0] * J[0][1] + J[1][0] * J[1][1] + J[2][0] * J[2][1],\n                    J[0][0] * J[0][2] + J[1][0] * J[1][2] + J[2][0] * J[2][2]\n                ],\n                [\n                    J[0][1] * J[0][0] + J[1][1] * J[1][0] + J[2][1] * J[2][0],\n                    J[0][1] * J[0][1] + J[1][1] * J[1][1] + J[2][1] * J[2][1],\n                    J[0][1] * J[0][2] + J[1][1] * J[1][2] + J[2][1] * J[2][2]\n                ],\n                [\n                    J[0][2] * J[0][0] + J[1][2] * J[1][0] + J[2][2] * J[2][0],\n                    J[0][2] * J[0][1] + J[1][2] * J[1][1] + J[2][2] * J[2][1],\n                    J[0][2] * J[0][2] + J[1][2] * J[1][2] + J[2][2] * J[2][2]\n                ]\n            ];\n            const JTF = [\n                J[0][0] * F[0] + J[1][0] * F[1] + J[2][0] * F[2],\n                J[0][1] * F[0] + J[1][1] * F[1] + J[2][1] * F[2],\n                J[0][2] * F[0] + J[1][2] * F[1] + J[2][2] * F[2]\n            ];\n            const det = JTJ[0][0] * (JTJ[1][1] * JTJ[2][2] - JTJ[1][2] * JTJ[2][1]) - JTJ[0][1] * (JTJ[1][0] * JTJ[2][2] - JTJ[1][2] * JTJ[2][0]) + JTJ[0][2] * (JTJ[1][0] * JTJ[2][1] - JTJ[1][1] * JTJ[2][0]);\n            if (Math.abs(det) < tolerance)\n                break;\n            const delta = this._solve3x3(JTJ, JTF, det);\n            tRefined -= delta[0];\n            uRefined -= delta[1];\n            vRefined -= delta[2];\n            tRefined = Math.max(tMin, Math.min(tMax, tRefined));\n            uRefined = Math.max(uMin, Math.min(uMax, uRefined));\n            vRefined = Math.max(vMin, Math.min(vMax, vRefined));\n            if (delta.every(d => Math.abs(d) < tolerance)) {\n                if (curve.evaluate(tRefined).distanceTo(this.evaluate(uRefined, vRefined)) < tolerance) {\n                    return {\n                        t: tRefined,\n                        u: uRefined,\n                        v: vRefined\n                    };\n                }\n                break;\n            }\n        }\n        return null;\n    }\n    _traceSurfaceIntersection(seedU1, seedV1, seedU2, seedV2, otherSurface, tolerance, maxIterations, stepSize = 0.01) {\n        const [uMin1, uMax1] = this.getDomainU();\n        const [vMin1, vMax1] = this.getDomainV();\n        const [uMin2, uMax2] = otherSurface.getDomainU();\n        const [vMin2, vMax2] = otherSurface.getDomainV();\n        let points = [];\n        let params1 = [];\n        let params2 = [];\n        let u1 = seedU1, v1 = seedV1, u2 = seedU2, v2 = seedV2;\n        // Refine initial seed\n        let refined = this._refineSurfaceIntersection(u1, v1, u2, v2, otherSurface, tolerance, maxIterations);\n        if (!refined)\n            return null;\n        u1 = refined.u1;\n        v1 = refined.v1;\n        u2 = refined.u2;\n        v2 = refined.v2;\n        points.push(this.evaluate(u1, v1));\n        params1.push({\n            u: u1,\n            v: v1\n        });\n        params2.push({\n            u: u2,\n            v: v2\n        });\n        // Directions to trace (forward and backward)\n        const directions = [\n            1,\n            -1\n        ];\n        for (let dir of directions) {\n            let lastU1 = u1, lastV1 = v1, lastU2 = u2, lastV2 = v2;\n            let closed = false;\n            while (true) {\n                // Compute tangents\n                const dP1u = this.derivative(lastU1, lastV1, 1, 0);\n                const dP1v = this.derivative(lastU1, lastV1, 0, 1);\n                const dP2u = otherSurface.derivative(lastU2, lastV2, 1, 0);\n                const dP2v = otherSurface.derivative(lastU2, lastV2, 0, 1);\n                // Normal vectors (cross products)\n                const n1 = dP1u.cross(dP1v);\n                const n2 = dP2u.cross(dP2v);\n                // Intersection direction (cross of normals)\n                const dirVec = n1.cross(n2);\n                if (dirVec.magnitude() < tolerance)\n                    break;\n                // Parallel surfaces\n                const step = dirVec.normalize().scale(dir * stepSize);\n                // Predict next point (simplified Euler step in 3D space, then project back)\n                const nextP = points[points.length - 1].add(step);\n                let nextU1 = lastU1 + stepSize * dir * (dP1u.dot(step) / dP1u.magnitude());\n                let nextV1 = lastV1 + stepSize * dir * (dP1v.dot(step) / dP1v.magnitude());\n                let nextU2 = lastU2 + stepSize * dir * (dP2u.dot(step) / dP2u.magnitude());\n                let nextV2 = lastV2 + stepSize * dir * (dP2v.dot(step) / dP2v.magnitude());\n                // Refine with Newton's method\n                refined = this._refineSurfaceIntersection(nextU1, nextV1, nextU2, nextV2, otherSurface, tolerance, maxIterations);\n                if (!refined)\n                    break;\n                nextU1 = refined.u1;\n                nextV1 = refined.v1;\n                nextU2 = refined.u2;\n                nextV2 = refined.v2;\n                const nextPoint = this.evaluate(nextU1, nextV1);\n                // Check for loop closure\n                if (points.length > 2 && nextPoint.distanceTo(points[0]) < tolerance * 10) {\n                    closed = true;\n                    break;\n                }\n                // Check domain boundaries\n                if (nextU1 <= uMin1 || nextU1 >= uMax1 || nextV1 <= vMin1 || nextV1 >= vMax1 || nextU2 <= uMin2 || nextU2 >= uMax2 || nextV2 <= vMin2 || nextV2 >= vMax2) {\n                    break;\n                }\n                // Check if stuck\n                if (nextPoint.distanceTo(points[points.length - 1]) < tolerance)\n                    break;\n                points.push(nextPoint);\n                params1.push({\n                    u: nextU1,\n                    v: nextV1\n                });\n                params2.push({\n                    u: nextU2,\n                    v: nextV2\n                });\n                lastU1 = nextU1;\n                lastV1 = nextV1;\n                lastU2 = nextU2;\n                lastV2 = nextV2;\n            }\n            if (dir === -1 && !closed) {\n                points.reverse();\n                params1.reverse();\n                params2.reverse();\n                points = points.slice(1);\n                // Remove seed point to avoid duplication\n                params1 = params1.slice(1);\n                params2 = params2.slice(1);\n            }\n        }\n        if (points.length >= 2) {\n            return {\n                points,\n                params1,\n                params2\n            };\n        }\n        return null;\n    }\n    _traceCurveIntersection(seedT, seedU, seedV, curve, tolerance, maxIterations, stepSize = 0.01) {\n        const [tMin, tMax] = curve.getDomain();\n        const [uMin, uMax] = this.getDomainU();\n        const [vMin, vMax] = this.getDomainV();\n        let points = [];\n        let paramsC = [];\n        let paramsS = [];\n        let t = seedT, u = seedU, v = seedV;\n        // Refine initial seed\n        let refined = this._refineCurveIntersection(t, u, v, curve, tolerance, maxIterations);\n        if (!refined)\n            return null;\n        t = refined.t;\n        u = refined.u;\n        v = refined.v;\n        points.push(curve.evaluate(t));\n        paramsC.push({ t });\n        paramsS.push({\n            u,\n            v\n        });\n        const directions = [\n            1,\n            -1\n        ];\n        for (let dir of directions) {\n            let lastT = t, lastU = u, lastV = v;\n            let closed = false;\n            while (true) {\n                const dC = curve.derivative(lastT, 1);\n                const dSu = this.derivative(lastU, lastV, 1, 0);\n                const dSv = this.derivative(lastU, lastV, 0, 1);\n                const nS = dSu.cross(dSv);\n                const dirVec = dC.cross(nS);\n                if (dirVec.magnitude() < tolerance)\n                    break;\n                const step = dirVec.normalize().scale(dir * stepSize);\n                const nextP = points[points.length - 1].add(step);\n                let nextT = lastT + stepSize * dir * (dC.dot(step) / dC.magnitude());\n                let nextU = lastU + stepSize * dir * (dSu.dot(step) / dSu.magnitude());\n                let nextV = lastV + stepSize * dir * (dSv.dot(step) / dSv.magnitude());\n                refined = this._refineCurveIntersection(nextT, nextU, nextV, curve, tolerance, maxIterations);\n                if (!refined)\n                    break;\n                nextT = refined.t;\n                nextU = refined.u;\n                nextV = refined.v;\n                const nextPoint = curve.evaluate(nextT);\n                if (points.length > 2 && nextPoint.distanceTo(points[0]) < tolerance * 10) {\n                    closed = true;\n                    break;\n                }\n                if (nextT <= tMin || nextT >= tMax || nextU <= uMin || nextU >= uMax || nextV <= vMin || nextV >= vMax) {\n                    break;\n                }\n                if (nextPoint.distanceTo(points[points.length - 1]) < tolerance)\n                    break;\n                points.push(nextPoint);\n                paramsC.push({ t: nextT });\n                paramsS.push({\n                    u: nextU,\n                    v: nextV\n                });\n                lastT = nextT;\n                lastU = nextU;\n                lastV = nextV;\n            }\n            if (dir === -1 && !closed) {\n                points.reverse();\n                paramsC.reverse();\n                paramsS.reverse();\n                points = points.slice(1);\n                paramsC = paramsC.slice(1);\n                paramsS = paramsS.slice(1);\n            }\n        }\n        if (points.length >= 2) {\n            return {\n                points,\n                paramsC,\n                paramsS\n            };\n        }\n        return null;\n    }\n    trimWithLoop(uvLoopCurves, innerLoops = [], tolerance = 0.000001) {\n        if (uvLoopCurves.length < 3)\n            throw new Error('Outer UV loop must have at least 3 curves');\n        for (let i = 0; i < uvLoopCurves.length; i++) {\n            const curr = uvLoopCurves[i];\n            const next = uvLoopCurves[(i + 1) % uvLoopCurves.length];\n            const currEnd = curr.evaluate(curr.getDomain()[1]);\n            const nextStart = next.evaluate(next.getDomain()[0]);\n            if (currEnd.distanceTo(nextStart) > tolerance) {\n                throw new Error('Outer UV loop curves must form a closed sequence');\n            }\n        }\n        const trimmingLoops = [{\n                type: 'outer',\n                curves: uvLoopCurves\n            }];\n        innerLoops.forEach((innerLoop, idx) => {\n            if (innerLoop.length < 3)\n                throw new Error(`Inner UV loop ${ idx } must have at least 3 curves`);\n            for (let i = 0; i < innerLoop.length; i++) {\n                const curr = innerLoop[i];\n                const next = innerLoop[(i + 1) % innerLoop.length];\n                const currEnd = curr.evaluate(curr.getDomain()[1]);\n                const nextStart = next.evaluate(next.getDomain()[0]);\n                if (currEnd.distanceTo(nextStart) > tolerance) {\n                    throw new Error(`Inner UV loop ${ idx } curves must form a closed sequence`);\n                }\n            }\n            trimmingLoops.push({\n                type: 'inner',\n                curves: innerLoop\n            });\n        });\n        const newSurface = new NURBSSurface(this.degreeU, this.degreeV, this.controlPoints.map(row => row.map(p => p.clone())), [...this.knotsU], [...this.knotsV], this.weights.map(row => [...row]), trimmingLoops);\n        newSurface._precomputeTrimmingLoops(trimmingLoops, tolerance);\n        return newSurface;\n    }\n    _isPointInLoop(u, v, loopCurves, tolerance = 0.000001) {\n        // Use index-based lookup instead of reference comparison\n        const loopIndex = this.trimmingLoops.findIndex(loop => loop.curves === loopCurves);\n        if (loopIndex === -1 || !this._precomputedPolygons[loopIndex]) {\n            throw new Error('Trimming loop not found or not precomputed');\n        }\n        const {polygon, bounds} = this._precomputedPolygons[loopIndex];\n        if (u < bounds.uMin || u > bounds.uMax || v < bounds.vMin || v > bounds.vMax) {\n            return false;\n        }\n        let crossings = 0;\n        for (let i = 0; i < polygon.length - 1; i++) {\n            const p1 = polygon[i];\n            const p2 = polygon[i + 1];\n            if (p1.v > v !== p2.v > v && u < p1.u + (p2.u - p1.u) * (v - p1.v) / (p2.v - p1.v)) {\n                crossings++;\n            }\n        }\n        return crossings % 2 === 1;\n    }\n    _isPointValid(u, v, tolerance = 0.000001) {\n        if (this.trimmingLoops.length === 0)\n            return true;\n        let insideOuter = false;\n        for (let loop of this.trimmingLoops) {\n            if (loop.type === 'outer') {\n                if (this._isPointInLoop(u, v, loop.curves, tolerance)) {\n                    insideOuter = true;\n                    break;\n                }\n            }\n        }\n        if (!insideOuter)\n            return false;\n        for (let loop of this.trimmingLoops) {\n            if (loop.type === 'inner' && this._isPointInLoop(u, v, loop.curves, tolerance)) {\n                return false;\n            }\n        }\n        // Inside a hole\n        return true;\n    }\n    _precomputeTrimmingLoops(trimmingLoops, tolerance = 0.000001) {\n        this.trimmingLoops = trimmingLoops;\n        this._precomputedPolygons = trimmingLoops.map(loop => {\n            const samples = 20;\n            // Fixed number of samples per curve\n            const polygon = [];\n            loop.curves.forEach(curve => {\n                const [tMin, tMax] = curve.getDomain();\n                const dt = (tMax - tMin) / (samples - 1);\n                for (let i = 0; i < samples; i++) {\n                    const t = tMin + i * dt;\n                    const p = curve.evaluate(t);\n                    polygon.push({\n                        u: p.x,\n                        v: p.y\n                    });\n                }\n            });\n            // Ensure closure by adjusting the last point if needed\n            if (polygon.length > 0) {\n                const first = polygon[0];\n                const last = polygon[polygon.length - 1];\n                if (Math.abs(last.u - first.u) > tolerance || Math.abs(last.v - first.v) > tolerance) {\n                    polygon.push({\n                        u: first.u,\n                        v: first.v\n                    });\n                }\n            }\n            const uMin = Math.min(...polygon.map(p => p.u));\n            const uMax = Math.max(...polygon.map(p => p.u));\n            const vMin = Math.min(...polygon.map(p => p.v));\n            const vMax = Math.max(...polygon.map(p => p.v));\n            return {\n                type: loop.type,\n                polygon,\n                bounds: {\n                    uMin,\n                    uMax,\n                    vMin,\n                    vMax\n                }\n            };\n        });\n    }\n    elevateDegree(direction = 'u') {\n        if (direction !== 'u' && direction !== 'v') {\n            throw new Error('Direction must be \"u\" or \"v\"');\n        }\n        if (direction === 'u') {\n            const newDegreeU = this.degreeU + 1;\n            const newControlPoints = Array(this.nU + 2).fill().map(() => Array(this.nV + 1));\n            const newWeights = Array(this.nU + 2).fill().map(() => Array(this.nV + 1));\n            const newKnotsU = Array(this.nU + newDegreeU + 2);\n            // Elevate each row (U-direction)\n            for (let j = 0; j <= this.nV; j++) {\n                const rowCurve = new NURBSCurve(this.degreeU, this.controlPoints.map(row => row[j]), this.knotsU, this.weights.map(row => row[j]));\n                const elevated = rowCurve.elevateDegree();\n                for (let i = 0; i <= this.nU + 1; i++) {\n                    newControlPoints[i][j] = elevated.controlPoints[i];\n                    newWeights[i][j] = elevated.weights[i];\n                }\n                if (j === 0) {\n                    newKnotsU.splice(0, newKnotsU.length, ...elevated.knots);\n                }\n            }\n            return new NURBSSurface(newDegreeU, this.degreeV, newControlPoints, newKnotsU, this.knotsV, newWeights, this.trimmingLoops);\n        } else {\n            const newDegreeV = this.degreeV + 1;\n            const newControlPoints = Array(this.nU + 1).fill().map(() => Array(this.nV + 2));\n            const newWeights = Array(this.nU + 1).fill().map(() => Array(this.nV + 2));\n            const newKnotsV = Array(this.nV + newDegreeV + 2);\n            // Elevate each column (V-direction)\n            for (let i = 0; i <= this.nU; i++) {\n                const colCurve = new NURBSCurve(this.degreeV, this.controlPoints[i], this.knotsV, this.weights[i]);\n                const elevated = colCurve.elevateDegree();\n                for (let j = 0; j <= this.nV + 1; j++) {\n                    newControlPoints[i][j] = elevated.controlPoints[j];\n                    newWeights[i][j] = elevated.weights[j];\n                }\n                if (i === 0) {\n                    newKnotsV.splice(0, newKnotsV.length, ...elevated.knots);\n                }\n            }\n            return new NURBSSurface(this.degreeU, newDegreeV, newControlPoints, this.knotsU, newKnotsV, newWeights, this.trimmingLoops);\n        }\n    }\n    reduceDegree(direction = 'u', tolerance = 0.000001) {\n        if (direction !== 'u' && direction !== 'v') {\n            throw new Error('Direction must be \"u\" or \"v\"');\n        }\n        if (direction === 'u') {\n            if (this.degreeU <= 1) {\n                throw new Error('Cannot reduce U degree below 1');\n            }\n            const newDegreeU = this.degreeU - 1;\n            const newControlPoints = Array(this.nU).fill().map(() => Array(this.nV + 1));\n            const newWeights = Array(this.nU).fill().map(() => Array(this.nV + 1));\n            const newKnotsU = Array(this.nU + newDegreeU + 2);\n            // Reduce degree for each V-direction curve\n            for (let j = 0; j <= this.nV; j++) {\n                const rowCurve = new NURBSCurve(this.degreeU, this.controlPoints.map(row => row[j]), this.knotsU, this.weights.map(row => row[j]));\n                const reduced = rowCurve.reduceDegree(tolerance);\n                for (let i = 0; i < this.nU; i++) {\n                    newControlPoints[i][j] = reduced.controlPoints[i];\n                    newWeights[i][j] = reduced.weights[i];\n                }\n                if (j === 0) {\n                    newKnotsU.splice(0, newKnotsU.length, ...reduced.knots);\n                }\n            }\n            return new NURBSSurface(newDegreeU, this.degreeV, newControlPoints, newKnotsU, this.knotsV, newWeights, this.trimmingLoops);\n        } else {\n            if (this.degreeV <= 1) {\n                throw new Error('Cannot reduce V degree below 1');\n            }\n            const newDegreeV = this.degreeV - 1;\n            const newControlPoints = Array(this.nU + 1).fill().map(() => Array(this.nV));\n            const newWeights = Array(this.nU + 1).fill().map(() => Array(this.nV));\n            const newKnotsV = Array(this.nV + newDegreeV + 2);\n            // Reduce degree for each U-direction curve\n            for (let i = 0; i <= this.nU; i++) {\n                const colCurve = new NURBSCurve(this.degreeV, this.controlPoints[i], this.knotsV, this.weights[i]);\n                const reduced = colCurve.reduceDegree(tolerance);\n                for (let j = 0; j < this.nV; j++) {\n                    newControlPoints[i][j] = reduced.controlPoints[j];\n                    newWeights[i][j] = reduced.weights[j];\n                }\n                if (i === 0) {\n                    newKnotsV.splice(0, newKnotsV.length, ...reduced.knots);\n                }\n            }\n            return new NURBSSurface(this.degreeU, newDegreeV, newControlPoints, this.knotsU, newKnotsV, newWeights, this.trimmingLoops);\n        }\n    }\n    static fitPoints(pointGrid, degreeU = 3, degreeV = 3) {\n        if (!Array.isArray(pointGrid) || pointGrid.length < degreeU + 1 || !pointGrid.every(row => Array.isArray(row) && row.length >= degreeV + 1)) {\n            throw new Error('Point grid must be at least (degreeU + 1) x (degreeV + 1)');\n        }\n        const nU = pointGrid.length - 1;\n        const nV = pointGrid[0].length - 1;\n        const knotsU = Array(nU + degreeU + 2).fill(0);\n        const knotsV = Array(nV + degreeV + 2).fill(0);\n        const weights = Array(nU + 1).fill().map(() => Array(nV + 1).fill(1));\n        // Generate uniform knots for U\n        for (let i = degreeU + 1; i <= nU; i++) {\n            knotsU[i] = (i - degreeU) / (nU - degreeU + 1);\n        }\n        for (let i = nU + 1; i <= nU + degreeU + 1; i++) {\n            knotsU[i] = 1;\n        }\n        // Generate uniform knots for V\n        for (let j = degreeV + 1; j <= nV; j++) {\n            knotsV[j] = (j - degreeV) / (nV - degreeV + 1);\n        }\n        for (let j = nV + 1; j <= nV + degreeV + 1; j++) {\n            knotsV[j] = 1;\n        }\n        // Fit curves in U direction first, then V direction (simplified global interpolation)\n        const tempCurves = pointGrid.map(row => NURBSCurve.fitPoints(row, degreeV));\n        const controlPoints = Array(nU + 1).fill().map(() => Array(nV + 1));\n        for (let i = 0; i <= nU; i++) {\n            const params = tempCurves[i].controlPoints.map((_, j) => j / nV);\n            const vCurve = NURBSCurve.fitPoints(tempCurves.map(c => c.controlPoints[i]), degreeU);\n            for (let j = 0; j <= nV; j++) {\n                controlPoints[i][j] = vCurve.controlPoints[i] || vCurve.controlPoints[vCurve.controlPoints.length - 1];\n            }\n        }\n        return new NURBSSurface(degreeU, degreeV, controlPoints, knotsU, knotsV, weights);\n    }\n}\nexport class Vertex {\n    constructor(point) {\n        this.point = point.clone();\n        this.id = idCounter.getNext('vertex');\n    }\n    toString() {\n        return `Vertex(${ this.id }, ${ this.point.toString() })`;\n    }\n}\nexport class Edge {\n    constructor(curve, vertex1, vertex2, tMin = null, tMax = null) {\n        this.curve = curve;\n        this.vertices = [\n            vertex1,\n            vertex2\n        ];\n        this.tMin = tMin !== null ? tMin : curve.getDomain()[0];\n        this.tMax = tMax !== null ? tMax : curve.getDomain()[1];\n        this.id = idCounter.getNext('edge');\n    }\n    getStartPoint() {\n        return this.curve.evaluate(this.tMin);\n    }\n    getEndPoint() {\n        return this.curve.evaluate(this.tMax);\n    }\n    toString() {\n        return `Edge(${ this.id }, t[${ this.tMin }, ${ this.tMax }])`;\n    }\n}\nexport class Loop {\n    constructor(edges) {\n        this.edges = edges;\n        this.id = idCounter.getNext('loop');\n        this._validate();\n    }\n    _validate() {\n        if (this.edges.length < 1)\n            throw new Error('Loop must have at least one edge');\n        for (let i = 0; i < this.edges.length; i++) {\n            const curr = this.edges[i];\n            const next = this.edges[(i + 1) % this.edges.length];\n            if (!curr.vertices[1].point.equals(next.vertices[0].point)) {\n                throw new Error('Loop edges must form a closed sequence');\n            }\n        }\n    }\n    toString() {\n        return `Loop(${ this.id }, ${ this.edges.length } edges)`;\n    }\n}\nexport class Face {\n    constructor(surface, loops) {\n        this.surface = surface;\n        this.loops = loops;\n        this.id = idCounter.getNext('face');\n    }\n    toString() {\n        return `Face(${ this.id }, ${ this.loops.length } loops)`;\n    }\n}\nexport class Shell {\n    constructor(faces) {\n        this.faces = faces;\n        this.id = idCounter.getNext('shell');\n    }\n    toString() {\n        return `Shell(${ this.id }, ${ this.faces.length } faces)`;\n    }\n}\nexport class Solid {\n    constructor(shells) {\n        this.shells = shells;\n        this.id = idCounter.getNext('solid');\n    }\n    toString() {\n        return `Solid(${ this.id }, ${ this.shells.length } shells)`;\n    }\n}\nexport class SurfaceSolver {\n    constructor(surface) {\n        this.surface = surface;\n    }\n    findUV(point3D, initialU = 0.5, initialV = 0.5, tolerance = 0.000001, maxIterations = 100) {\n        let u = initialU;\n        let v = initialV;\n        const [uMin, uMax] = this.surface.getDomainU();\n        const [vMin, vMax] = this.surface.getDomainV();\n        for (let i = 0; i < maxIterations; i++) {\n            const P = this.surface.evaluate(u, v);\n            if (!P)\n                return null;\n            // Outside trimmed region\n            const V = P.subtract(point3D);\n            const dSu = this.surface.derivative(u, v, 1, 0);\n            const dSv = this.surface.derivative(u, v, 0, 1);\n            const F = [\n                V.x,\n                V.y,\n                V.z\n            ];\n            const J = [\n                [\n                    dSu.x,\n                    dSv.x\n                ],\n                [\n                    dSu.y,\n                    dSv.y\n                ],\n                [\n                    dSu.z,\n                    dSv.z\n                ]\n            ];\n            // Compute J^T J and J^T F for 2D Newton (least squares)\n            const JTJ = [\n                [\n                    J[0][0] * J[0][0] + J[1][0] * J[1][0] + J[2][0] * J[2][0],\n                    J[0][0] * J[0][1] + J[1][0] * J[1][1] + J[2][0] * J[2][1]\n                ],\n                [\n                    J[0][1] * J[0][0] + J[1][1] * J[1][0] + J[2][1] * J[2][0],\n                    J[0][1] * J[0][1] + J[1][1] * J[1][1] + J[2][1] * J[2][1]\n                ]\n            ];\n            const JTF = [\n                J[0][0] * F[0] + J[1][0] * F[1] + J[2][0] * F[2],\n                J[0][1] * F[0] + J[1][1] * F[1] + J[2][1] * F[2]\n            ];\n            const det = JTJ[0][0] * JTJ[1][1] - JTJ[0][1] * JTJ[1][0];\n            if (Math.abs(det) < tolerance)\n                break;\n            const deltaU = (JTJ[1][1] * JTF[0] - JTJ[0][1] * JTF[1]) / det;\n            const deltaV = (-JTJ[1][0] * JTF[0] + JTJ[0][0] * JTF[1]) / det;\n            u -= deltaU;\n            v -= deltaV;\n            u = Math.max(uMin, Math.min(uMax, u));\n            v = Math.max(vMin, Math.min(vMax, v));\n            if (Math.abs(deltaU) < tolerance && Math.abs(deltaV) < tolerance) {\n                if (this.surface.evaluate(u, v).distanceTo(point3D) < tolerance) {\n                    return new Point(u, v, 0);\n                }\n                break;\n            }\n        }\n        return null;\n    }\n}\nexport class SurfaceUtils {\n    edgeToUVCurve(edge, surface, tolerance = 0.000001) {\n        const [tMin, tMax] = [\n            edge.tMin,\n            edge.tMax\n        ];\n        const samples = 10;\n        const dt = (tMax - tMin) / (samples - 1);\n        const uvPoints = [];\n        const solver = new SurfaceSolver(surface);\n        // Evaluate the edge and map to UV space\n        let prevUV = null;\n        for (let i = 0; i < samples; i++) {\n            const t = tMin + i * dt;\n            const point3D = edge.curve.evaluate(t);\n            const initialU = prevUV ? prevUV.x : i / (samples - 1);\n            const initialV = prevUV ? prevUV.y : 0;\n            const uv = solver.findUV(point3D, initialU, initialV, tolerance);\n            if (!uv) {\n                throw new Error(`Failed to map edge point at t=${ t } to UV space`);\n            }\n            uvPoints.push(uv);\n            prevUV = uv;\n        }\n        // Generate a non-decreasing knot vector\n        const degree = 2;\n        const n = uvPoints.length - 1;\n        // Number of control points minus 1\n        const knotCount = n + degree + 2;\n        // Total knots required\n        const knots = Array(knotCount);\n        // Clamp knots at start and end\n        for (let i = 0; i <= degree; i++) {\n            knots[i] = 0;\n            knots[knotCount - 1 - i] = 1;\n        }\n        // Fill interior knots with strictly increasing values\n        for (let i = degree + 1; i <= n; i++) {\n            knots[i] = (i - degree) / (n - degree + 1);\n        }\n        return new NURBSCurve(degree, uvPoints, knots, Array(uvPoints.length).fill(1));\n    }\n}\nexport class FaceSplitter {\n    splitEdge(edge, tValues, tolerance = 0.000001) {\n        if (!tValues.length) {\n            return [edge];\n        }\n        tValues.sort((a, b) => a - b);\n        const newEdges = [];\n        let currentVertex = edge.vertices[0];\n        let currentT = edge.tMin;\n        for (const t of tValues) {\n            if (t <= currentT + tolerance || t >= edge.tMax - tolerance) {\n                continue;\n            }\n            const newPoint = edge.curve.evaluate(t);\n            const newVertex = new Vertex(newPoint);\n            newEdges.push(new Edge(edge.curve, currentVertex, newVertex, currentT, t));\n            currentVertex = newVertex;\n            currentT = t;\n        }\n        newEdges.push(new Edge(edge.curve, currentVertex, edge.vertices[1], currentT, edge.tMax));\n        return newEdges;\n    }\n    isPointInLoop(point, loop, surface, tolerance = 0.000001) {\n        let crossings = 0;\n        for (let i = 0; i < loop.edges.length; i++) {\n            const edge = loop.edges[i];\n            const p1 = edge.getStartPoint();\n            const p2 = edge.getEndPoint();\n            if (p1.y > point.y !== p2.y > point.y && point.x < p1.x + (p2.x - p1.x) * (point.y - p1.y) / (p2.y - p1.y)) {\n                crossings++;\n            }\n        }\n        return crossings % 2 === 1;\n    }\n    splitFaceWithCurves(face, intersectionCurves, tolerance = 0.000001) {\n        const surface = face.surface;\n        const originalLoops = face.loops;\n        const edgeIntersections = new Map();\n        const allVertices = new Set();\n        const allEdges = new Set();\n        const utils = new SurfaceUtils();\n        console.log('Intersection curves:', intersectionCurves);\n        originalLoops.forEach(loop => loop.edges.forEach(edge => allEdges.add(edge)));\n        intersectionCurves.forEach(intersection => {\n            const {curve, params1} = intersection;\n            let intersectionPoints = [];\n            if (params1 && params1.length >= 2) {\n                intersectionPoints = params1.map(param => ({\n                    point: surface.evaluate(param.u, param.v),\n                    tCurve: param.u\n                }));\n            } else {\n                intersectionPoints = [\n                    {\n                        point: curve.evaluate(0),\n                        tCurve: 0\n                    },\n                    {\n                        point: curve.evaluate(1),\n                        tCurve: 1\n                    }\n                ];\n            }\n            console.log('Intersection points:', intersectionPoints);\n            const uvCurve = utils.edgeToUVCurve(new Edge(curve, new Vertex(intersectionPoints[0].point), new Vertex(intersectionPoints[intersectionPoints.length - 1].point), 0, 1), surface, tolerance);\n            let foundIntersections = false;\n            allEdges.forEach(edge => {\n                const edgeUVCurve = utils.edgeToUVCurve(edge, surface, tolerance);\n                const uvIntersections = edgeUVCurve.intersect(uvCurve, tolerance);\n                const tValues = uvIntersections.filter(i => i.t1 >= edge.tMin && i.t1 <= edge.tMax).map(i => i.t1);\n                console.log(`UV intersections with edge ${ edge.tMin }-${ edge.tMax }:`, tValues);\n                if (tValues.length > 0) {\n                    edgeIntersections.set(edge, tValues.map(t => ({ tEdge: t })));\n                    foundIntersections = true;\n                }\n            });\n            let startVertex, endVertex;\n            if (!foundIntersections) {\n                console.log('No UV intersections, forcing split with endpoints');\n                let intersectionsFound = 0;\n                intersectionPoints.forEach(({point}) => {\n                    allEdges.forEach(edge => {\n                        const edgeCurve = edge.curve;\n                        const edgeStart = edgeCurve.evaluate(edge.tMin);\n                        const edgeEnd = edgeCurve.evaluate(edge.tMax);\n                        if (!edgeStart || !edgeEnd)\n                            return;\n                        const edgeVec = edgeEnd.subtract(edgeStart);\n                        if (!edgeVec || typeof edgeVec.magnitude !== 'function')\n                            return;\n                        const edgeLength = edgeVec.magnitude();\n                        if (edgeLength < tolerance)\n                            return;\n                        const vec = point.subtract(edgeStart);\n                        const t = vec.dot(edgeVec) / (edgeLength * edgeLength);\n                        const tEdge = t * (edge.tMax - edge.tMin) + edge.tMin;\n                        if (tEdge >= edge.tMin + tolerance && tEdge <= edge.tMax - tolerance) {\n                            const projectedPoint = edgeCurve.evaluate(tEdge);\n                            if (projectedPoint.distanceTo(point) < tolerance * 10) {\n                                edgeIntersections.set(edge, (edgeIntersections.get(edge) || []).concat([{ tEdge }]));\n                                intersectionsFound++;\n                            }\n                        }\n                    });\n                });\n                if (intersectionsFound < 2 && intersectionPoints.length >= 2) {\n                    console.log('Forcing two intersections on distinct edges');\n                    const edgesArray = [...allEdges];\n                    if (edgesArray.length >= 2) {\n                        const edge1 = edgesArray[0];\n                        const edge2 = edgesArray[2] || edgesArray[1];\n                        // Prefer opposite edge (e.g., top/bottom)\n                        const t1 = (edge1.tMin + edge1.tMax) / 2;\n                        const t2 = (edge2.tMin + edge2.tMax) / 2;\n                        edgeIntersections.set(edge1, [{ tEdge: t1 }]);\n                        edgeIntersections.set(edge2, [{ tEdge: t2 }]);\n                        startVertex = new Vertex(edge1.curve.evaluate(t1));\n                        endVertex = new Vertex(edge2.curve.evaluate(t2));\n                        allVertices.add(startVertex);\n                        allVertices.add(endVertex);\n                    }\n                }\n            }\n            if (!startVertex || !endVertex) {\n                startVertex = [...allVertices].find(v => v.point.distanceTo(intersectionPoints[0].point) < tolerance) || new Vertex(intersectionPoints[0].point);\n                endVertex = [...allVertices].find(v => v.point.distanceTo(intersectionPoints[intersectionPoints.length - 1].point) < tolerance) || new Vertex(intersectionPoints[intersectionPoints.length - 1].point);\n                allVertices.add(startVertex);\n                allVertices.add(endVertex);\n            }\n            const newEdge = new Edge(curve, startVertex, endVertex, 0, 1);\n            allEdges.add(newEdge);\n        });\n        edgeIntersections.forEach((intersections, edge) => {\n            const tValues = intersections.map(i => i.tEdge).filter(t => t > edge.tMin + tolerance && t < edge.tMax - tolerance);\n            console.log(`Splitting edge ${ edge.tMin }-${ edge.tMax } at:`, tValues);\n            const newEdges = this.splitEdge(edge, tValues, tolerance);\n            newEdges.forEach(e => {\n                allVertices.add(e.vertices[0]);\n                allVertices.add(e.vertices[1]);\n                allEdges.add(e);\n            });\n            allEdges.delete(edge);\n        });\n        const loops = [];\n        const visitedEdges = new Set();\n        while (allEdges.size > 0) {\n            const startEdge = [...allEdges][0];\n            if (visitedEdges.has(startEdge)) {\n                allEdges.delete(startEdge);\n                continue;\n            }\n            const loopEdges = [];\n            let currentEdge = startEdge;\n            let currentVertex = currentEdge.vertices[0];\n            let closed = false;\n            do {\n                loopEdges.push(currentEdge);\n                visitedEdges.add(currentEdge);\n                allEdges.delete(currentEdge);\n                const nextVertex = currentEdge.vertices[0].point.equals(currentVertex.point, tolerance) ? currentEdge.vertices[1] : currentEdge.vertices[0];\n                let nextEdge = null;\n                for (const edge of allEdges) {\n                    if (!visitedEdges.has(edge) && (edge.vertices[0].point.equals(nextVertex.point, tolerance) || edge.vertices[1].point.equals(nextVertex.point, tolerance))) {\n                        nextEdge = edge;\n                        break;\n                    }\n                }\n                if (!nextEdge) {\n                    if (nextVertex.point.equals(loopEdges[0].vertices[0].point, tolerance)) {\n                        closed = true;\n                    }\n                    break;\n                }\n                currentEdge = nextEdge;\n                currentVertex = nextVertex;\n            } while (!closed && loopEdges.length < 1000);\n            if (closed && loopEdges.length >= 3) {\n                loops.push(new Loop(loopEdges));\n            }\n        }\n        console.log('Loops formed:', loops.length);\n        const faces = [];\n        const outerLoops = [];\n        const innerLoopsMap = new Map();\n        loops.forEach(loop => {\n            const centroid = loop.edges.reduce((sum, edge) => sum.add(edge.getStartPoint()), new Point(0, 0, 0)).scale(1 / loop.edges.length);\n            let isOuter = true;\n            for (const otherLoop of loops) {\n                if (loop !== otherLoop && this.isPointInLoop(centroid, otherLoop, surface, tolerance)) {\n                    isOuter = false;\n                    break;\n                }\n            }\n            if (isOuter) {\n                outerLoops.push(loop);\n                innerLoopsMap.set(loop, []);\n            } else {\n                for (const outer of outerLoops) {\n                    if (this.isPointInLoop(centroid, outer, surface, tolerance)) {\n                        innerLoopsMap.get(outer).push(loop);\n                        break;\n                    }\n                }\n            }\n        });\n        console.log('Outer loops:', outerLoops.length);\n        outerLoops.forEach(outerLoop => {\n            const innerLoops = innerLoopsMap.get(outerLoop);\n            const outerUVCurves = outerLoop.edges.map(edge => utils.edgeToUVCurve(edge, surface, tolerance));\n            const innerUVCurves = innerLoops.length > 0 ? innerLoops.map(loop => loop.edges.map(edge => utils.edgeToUVCurve(edge, surface, tolerance))) : [];\n            const trimmedSurface = surface.trimWithLoop(outerUVCurves, innerUVCurves, tolerance);\n            const faceLoops = [\n                new Loop(outerLoop.edges),\n                ...innerLoops.map(loop => new Loop(loop.edges))\n            ];\n            faces.push(new Face(trimmedSurface, faceLoops));\n        });\n        if (faces.length === 0) {\n            throw new Error('No valid faces produced from splitting');\n        }\n        console.log('Faces produced:', faces.length);\n        return faces;\n    }\n}\nexport class Tester {\n    constructor(testsInstance) {\n        this.tests = testsInstance;\n    }\n    runTests() {\n        const results = [];\n        const testMethods = Object.getOwnPropertyNames(Object.getPrototypeOf(this.tests)).filter(name => name !== 'constructor' && typeof this.tests[name] === 'function');\n        for (const methodName of testMethods) {\n            try {\n                this.tests[methodName]();\n                results.push({\n                    test: methodName,\n                    passed: true,\n                    message: 'Test passed'\n                });\n            } catch (error) {\n                results.push({\n                    test: methodName,\n                    passed: false,\n                    message: `Test failed: ${ error.message }`,\n                    error: error\n                });\n            }\n        }\n        this._reportResults(results);\n        return results;\n    }\n    _reportResults(results) {\n        console.log('Test Results:');\n        results.forEach(result => {\n            const status = result.passed ? 'PASSED' : 'FAILED';\n            console.log(`${ status } - ${ result.test }: ${ result.message }`);\n            if (!result.passed) {\n                console.log(result.error);\n            }\n        });\n        const total = results.length;\n        const passed = results.filter(r => r.passed).length;\n        console.log(`Summary: ${ passed }/${ total } tests passed`);\n    }\n}\nexport class Tests {\n    testNURBSCurveEvaluation() {\n        const curve = new NURBSCurve(1, [\n            new Point(0, 0, 0),\n            new Point(1, 1, 1)\n        ], [\n            0,\n            0,\n            1,\n            1\n        ], [\n            1,\n            1\n        ]);\n        const point = curve.evaluate(0.5);\n        if (!point || point.distanceTo(new Point(0.5, 0.5, 0.5)) > 0.000001) {\n            throw new Error('NURBSCurve evaluation at t=0.5 should be (0.5, 0.5, 0.5)');\n        }\n    }\n    testVertexCreation() {\n        const vertex = new Vertex(new Point(1, 2, 3));\n        if (!vertex.point.equals(new Point(1, 2, 3))) {\n            throw new Error('Vertex should store the correct point');\n        }\n    }\n    testEdgeEndPoints() {\n        const v1 = new Vertex(new Point(0, 0, 0));\n        const v2 = new Vertex(new Point(1, 0, 0));\n        const curve = new NURBSCurve(1, [\n            v1.point,\n            v2.point\n        ], [\n            0,\n            0,\n            1,\n            1\n        ], [\n            1,\n            1\n        ]);\n        const edge = new Edge(curve, v1, v2);\n        const start = edge.getStartPoint();\n        const end = edge.getEndPoint();\n        if (!start.equals(v1.point) || !end.equals(v2.point)) {\n            throw new Error('Edge endpoints should match vertex points');\n        }\n    }\n    testLoopValidation() {\n        const v1 = new Vertex(new Point(0, 0, 0));\n        const v2 = new Vertex(new Point(1, 0, 0));\n        const v3 = new Vertex(new Point(1, 1, 0));\n        const e1 = new Edge(new NURBSCurve(1, [\n            v1.point,\n            v2.point\n        ], [\n            0,\n            0,\n            1,\n            1\n        ], [\n            1,\n            1\n        ]), v1, v2);\n        const e2 = new Edge(new NURBSCurve(1, [\n            v2.point,\n            v3.point\n        ], [\n            0,\n            0,\n            1,\n            1\n        ], [\n            1,\n            1\n        ]), v2, v3);\n        try {\n            new Loop([\n                e1,\n                e2\n            ]);\n            // Not closed\n            throw new Error('Loop should throw error for non-closed sequence');\n        } catch (error) {\n            if (error.message !== 'Loop edges must form a closed sequence') {\n                throw new Error('Loop validation should detect non-closed sequence');\n            }\n        }\n    }\n    testShellConstruction() {\n        const surface = new NURBSSurface(1, 1, [\n            [\n                new Point(0, 0, 0),\n                new Point(0, 1, 0)\n            ],\n            [\n                new Point(1, 0, 0),\n                new Point(1, 1, 0)\n            ]\n        ], [\n            0,\n            0,\n            1,\n            1\n        ], [\n            0,\n            0,\n            1,\n            1\n        ], [\n            [\n                1,\n                1\n            ],\n            [\n                1,\n                1\n            ]\n        ]);\n        const v1 = new Vertex(new Point(0, 0, 0));\n        const v2 = new Vertex(new Point(1, 0, 0));\n        const v3 = new Vertex(new Point(1, 1, 0));\n        const v4 = new Vertex(new Point(0, 1, 0));\n        const e1 = new Edge(new NURBSCurve(1, [\n            v1.point,\n            v2.point\n        ], [\n            0,\n            0,\n            1,\n            1\n        ], [\n            1,\n            1\n        ]), v1, v2);\n        const e2 = new Edge(new NURBSCurve(1, [\n            v2.point,\n            v3.point\n        ], [\n            0,\n            0,\n            1,\n            1\n        ], [\n            1,\n            1\n        ]), v2, v3);\n        const e3 = new Edge(new NURBSCurve(1, [\n            v3.point,\n            v4.point\n        ], [\n            0,\n            0,\n            1,\n            1\n        ], [\n            1,\n            1\n        ]), v3, v4);\n        const e4 = new Edge(new NURBSCurve(1, [\n            v4.point,\n            v1.point\n        ], [\n            0,\n            0,\n            1,\n            1\n        ], [\n            1,\n            1\n        ]), v4, v1);\n        const loop = new Loop([\n            e1,\n            e2,\n            e3,\n            e4\n        ]);\n        const face = new Face(surface, [loop]);\n        const shell = new Shell([face]);\n        if (shell.faces.length !== 1 || shell.faces[0] !== face) {\n            throw new Error('Shell should contain the correct face');\n        }\n    }\n    testSolidConstruction() {\n        const surface = new NURBSSurface(1, 1, [\n            [\n                new Point(0, 0, 0),\n                new Point(0, 1, 0)\n            ],\n            [\n                new Point(1, 0, 0),\n                new Point(1, 1, 0)\n            ]\n        ], [\n            0,\n            0,\n            1,\n            1\n        ], [\n            0,\n            0,\n            1,\n            1\n        ], [\n            [\n                1,\n                1\n            ],\n            [\n                1,\n                1\n            ]\n        ]);\n        const v1 = new Vertex(new Point(0, 0, 0));\n        const v2 = new Vertex(new Point(1, 0, 0));\n        const v3 = new Vertex(new Point(1, 1, 0));\n        const v4 = new Vertex(new Point(0, 1, 0));\n        const e1 = new Edge(new NURBSCurve(1, [\n            v1.point,\n            v2.point\n        ], [\n            0,\n            0,\n            1,\n            1\n        ], [\n            1,\n            1\n        ]), v1, v2);\n        const e2 = new Edge(new NURBSCurve(1, [\n            v2.point,\n            v3.point\n        ], [\n            0,\n            0,\n            1,\n            1\n        ], [\n            1,\n            1\n        ]), v2, v3);\n        const e3 = new Edge(new NURBSCurve(1, [\n            v3.point,\n            v4.point\n        ], [\n            0,\n            0,\n            1,\n            1\n        ], [\n            1,\n            1\n        ]), v3, v4);\n        const e4 = new Edge(new NURBSCurve(1, [\n            v4.point,\n            v1.point\n        ], [\n            0,\n            0,\n            1,\n            1\n        ], [\n            1,\n            1\n        ]), v4, v1);\n        const loop = new Loop([\n            e1,\n            e2,\n            e3,\n            e4\n        ]);\n        const face = new Face(surface, [loop]);\n        const shell = new Shell([face]);\n        const solid = new Solid([shell]);\n        if (solid.shells.length !== 1 || solid.shells[0] !== shell) {\n            throw new Error('Solid should contain the correct shell');\n        }\n    }\n    testSurfaceSolverAccuracy() {\n        const surface = new NURBSSurface(1, 1, [\n            [\n                new Point(0, 0, 0),\n                new Point(0, 1, 0)\n            ],\n            [\n                new Point(1, 0, 0),\n                new Point(1, 1, 0)\n            ]\n        ], [\n            0,\n            0,\n            1,\n            1\n        ], [\n            0,\n            0,\n            1,\n            1\n        ], [\n            [\n                1,\n                1\n            ],\n            [\n                1,\n                1\n            ]\n        ]);\n        const solver = new SurfaceSolver(surface);\n        const target = new Point(0.5, 0.5, 0);\n        const uv = solver.findUV(target);\n        if (!uv || Math.abs(uv.x - 0.5) > 0.000001 || Math.abs(uv.y - 0.5) > 0.000001) {\n            throw new Error('SurfaceSolver should find accurate UV coordinates');\n        }\n    }\n    testSurfaceUtilsUVMapping() {\n        const surface = new NURBSSurface(1, 1, [\n            [\n                new Point(0, 0, 0),\n                new Point(0, 1, 0)\n            ],\n            [\n                new Point(1, 0, 0),\n                new Point(1, 1, 0)\n            ]\n        ], [\n            0,\n            0,\n            1,\n            1\n        ], [\n            0,\n            0,\n            1,\n            1\n        ], [\n            [\n                1,\n                1\n            ],\n            [\n                1,\n                1\n            ]\n        ]);\n        const v1 = new Vertex(new Point(0, 0, 0));\n        const v2 = new Vertex(new Point(1, 0, 0));\n        const edge = new Edge(new NURBSCurve(1, [\n            v1.point,\n            v2.point\n        ], [\n            0,\n            0,\n            1,\n            1\n        ], [\n            1,\n            1\n        ]), v1, v2);\n        const utils = new SurfaceUtils();\n        const uvCurve = utils.edgeToUVCurve(edge, surface);\n        const midPoint = uvCurve.evaluate(0.5);\n        if (!midPoint || Math.abs(midPoint.x - 0.5) > 0.000001 || Math.abs(midPoint.y - 0) > 0.000001) {\n            throw new Error('SurfaceUtils should map edge to correct UV curve');\n        }\n    }\n    testSurfaceEvaluationInsideTrim() {\n        const surface = new NURBSSurface(1, 1, [\n            [\n                new Point(0, 0, 0),\n                new Point(0, 1, 0)\n            ],\n            [\n                new Point(1, 0, 0),\n                new Point(1, 1, 0)\n            ]\n        ], [\n            0,\n            0,\n            1,\n            1\n        ], [\n            0,\n            0,\n            1,\n            1\n        ], [\n            [\n                1,\n                1\n            ],\n            [\n                1,\n                1\n            ]\n        ]);\n        const uvLoop = [\n            new NURBSCurve(1, [\n                new Point(0.25, 0.25, 0),\n                new Point(0.75, 0.25, 0)\n            ], [\n                0,\n                0,\n                1,\n                1\n            ], [\n                1,\n                1\n            ]),\n            new NURBSCurve(1, [\n                new Point(0.75, 0.25, 0),\n                new Point(0.75, 0.75, 0)\n            ], [\n                0,\n                0,\n                1,\n                1\n            ], [\n                1,\n                1\n            ]),\n            new NURBSCurve(1, [\n                new Point(0.75, 0.75, 0),\n                new Point(0.25, 0.75, 0)\n            ], [\n                0,\n                0,\n                1,\n                1\n            ], [\n                1,\n                1\n            ]),\n            new NURBSCurve(1, [\n                new Point(0.25, 0.75, 0),\n                new Point(0.25, 0.25, 0)\n            ], [\n                0,\n                0,\n                1,\n                1\n            ], [\n                1,\n                1\n            ])\n        ];\n        const trimmedSurface = surface.trimWithLoop(uvLoop);\n        const point = trimmedSurface.evaluate(0.5, 0.5);\n        if (!point || point.distanceTo(new Point(0.5, 0.5, 0)) > 0.000001) {\n            throw new Error('Point inside trim should evaluate correctly');\n        }\n    }\n    testSurfaceEvaluationOutsideTrim() {\n        const surface = new NURBSSurface(1, 1, [\n            [\n                new Point(0, 0, 0),\n                new Point(0, 1, 0)\n            ],\n            [\n                new Point(1, 0, 0),\n                new Point(1, 1, 0)\n            ]\n        ], [\n            0,\n            0,\n            1,\n            1\n        ], [\n            0,\n            0,\n            1,\n            1\n        ], [\n            [\n                1,\n                1\n            ],\n            [\n                1,\n                1\n            ]\n        ]);\n        const uvLoop = [\n            new NURBSCurve(1, [\n                new Point(0.25, 0.25, 0),\n                new Point(0.75, 0.25, 0)\n            ], [\n                0,\n                0,\n                1,\n                1\n            ], [\n                1,\n                1\n            ]),\n            new NURBSCurve(1, [\n                new Point(0.75, 0.25, 0),\n                new Point(0.75, 0.75, 0)\n            ], [\n                0,\n                0,\n                1,\n                1\n            ], [\n                1,\n                1\n            ]),\n            new NURBSCurve(1, [\n                new Point(0.75, 0.75, 0),\n                new Point(0.25, 0.75, 0)\n            ], [\n                0,\n                0,\n                1,\n                1\n            ], [\n                1,\n                1\n            ]),\n            new NURBSCurve(1, [\n                new Point(0.25, 0.75, 0),\n                new Point(0.25, 0.25, 0)\n            ], [\n                0,\n                0,\n                1,\n                1\n            ], [\n                1,\n                1\n            ])\n        ];\n        const trimmedSurface = surface.trimWithLoop(uvLoop);\n        const point = trimmedSurface.evaluate(0.1, 0.1);\n        if (point !== null) {\n            throw new Error('Point outside trim should return null');\n        }\n    }\n    testFaceSplitting() {\n        const surface = new NURBSSurface(1, 1, [\n            [\n                new Point(0, 0, 0),\n                new Point(0, 1, 0)\n            ],\n            [\n                new Point(1, 0, 0),\n                new Point(1, 1, 0)\n            ]\n        ], [\n            0,\n            0,\n            1,\n            1\n        ], [\n            0,\n            0,\n            1,\n            1\n        ], [\n            [\n                1,\n                1\n            ],\n            [\n                1,\n                1\n            ]\n        ]);\n        const v1 = new Vertex(new Point(0, 0, 0));\n        const v2 = new Vertex(new Point(1, 0, 0));\n        const v3 = new Vertex(new Point(1, 1, 0));\n        const v4 = new Vertex(new Point(0, 1, 0));\n        const e1 = new Edge(new NURBSCurve(1, [\n            v1.point,\n            v2.point\n        ], [\n            0,\n            0,\n            1,\n            1\n        ], [\n            1,\n            1\n        ]), v1, v2);\n        const e2 = new Edge(new NURBSCurve(1, [\n            v2.point,\n            v3.point\n        ], [\n            0,\n            0,\n            1,\n            1\n        ], [\n            1,\n            1\n        ]), v2, v3);\n        const e3 = new Edge(new NURBSCurve(1, [\n            v3.point,\n            v4.point\n        ], [\n            0,\n            0,\n            1,\n            1\n        ], [\n            1,\n            1\n        ]), v3, v4);\n        const e4 = new Edge(new NURBSCurve(1, [\n            v4.point,\n            v1.point\n        ], [\n            0,\n            0,\n            1,\n            1\n        ], [\n            1,\n            1\n        ]), v4, v1);\n        const loop = new Loop([\n            e1,\n            e2,\n            e3,\n            e4\n        ]);\n        const face = new Face(surface, [loop]);\n        // Adjusted intersection curve to ensure it intersects e1 and e3\n        const intersectionCurve = {\n            curve: new NURBSCurve(1, [\n                new Point(0.5, 0, 0),\n                new Point(0.5, 1, 0)\n            ], [\n                0,\n                0,\n                1,\n                1\n            ], [\n                1,\n                1\n            ]),\n            params1: [\n                {\n                    u: 0.5,\n                    v: 0\n                },\n                {\n                    u: 0.5,\n                    v: 1\n                }\n            ]\n        };\n        const splitter = new FaceSplitter();\n        const newFaces = splitter.splitFaceWithCurves(face, [intersectionCurve]);\n        // Debug: Log intersections\n        const intersections = e1.curve.intersect(intersectionCurve.curve);\n        console.log('Intersections with e1:', intersections);\n        if (newFaces.length !== 2) {\n            throw new Error(`Face splitting should produce exactly 2 faces, got ${ newFaces.length }`);\n        }\n    }\n}\nexport class FaceSplitterHelper {\n    findEdgeCurveIntersections(edge, intersectionCurve, tolerance = 0.000001) {\n        const curve = intersectionCurve.curve;\n        const intersections = curve.intersect(edge.curve, tolerance) || [];\n        // Ensure array\n        const results = [];\n        for (let intersection of intersections) {\n            const tEdge = intersection.t2;\n            const tCurve = intersection.t1;\n            if (tEdge >= edge.tMin - tolerance && tEdge <= edge.tMax + tolerance && tCurve >= curve.tMin - tolerance && tCurve <= curve.tMax + tolerance) {\n                const point = edge.curve.evaluate(tEdge);\n                results.push({\n                    point,\n                    tEdge,\n                    tCurve\n                });\n            }\n        }\n        return results;\n    }\n}\nconst idCounter = {\n    vertex: 0,\n    edge: 0,\n    loop: 0,\n    face: 0,\n    shell: 0,\n    solid: 0,\n    getNext(type) {\n        return this[type]++;\n    }\n};\n// Function to split a face along an intersection curve\nexport function splitFaceWithCurve(face, intersectionCurve, tolerance = 0.000001) {\n    const {curve, params1} = intersectionCurve;\n    // From intersectSurface or intersectCurve\n    const surface = face.surface;\n    // Step 1: Create vertices along the intersection curve\n    const vertices = params1.map(param => new Vertex(surface.evaluate(param.u, param.v)));\n    if (vertices.length < 2)\n        throw new Error('Intersection curve must have at least two points');\n    // Step 2: Create edges along the intersection curve\n    const edges = [];\n    for (let i = 0; i < vertices.length - 1; i++) {\n        const tMin = i / (vertices.length - 1);\n        const tMax = (i + 1) / (vertices.length - 1);\n        edges.push(new Edge(curve, vertices[i], vertices[i + 1], tMin, tMax));\n    }\n    // Step 3: Split the original loop (assuming a simple rectangular face for now)\n    const originalLoop = face.loops[0];\n    const originalEdges = originalLoop.edges;\n    // Find where the intersection curve intersects the boundary (simplified assumption: intersects two edges)\n    const intersectionPoints = [\n        vertices[0].point,\n        // Start of intersection curve\n        vertices[vertices.length - 1].point\n    ];\n    // End of intersection curve\n    let splitEdges1 = [], splitEdges2 = [];\n    let addedStart = false, addedEnd = false;\n    for (let edge of originalEdges) {\n        const start = edge.getStartPoint();\n        const end = edge.getEndPoint();\n        if (start.distanceTo(intersectionPoints[0]) < tolerance && !addedStart) {\n            splitEdges1.push(edge);\n            splitEdges2.push(new Edge(edge.curve, edge.vertices[0], vertices[0], edge.tMin, edge.tMin));\n            splitEdges1.push(edges[0]);\n            // First intersection edge\n            addedStart = true;\n        } else if (end.distanceTo(intersectionPoints[1]) < tolerance && !addedEnd) {\n            splitEdges1.push(new Edge(edge.curve, vertices[vertices.length - 1], edge.vertices[1], edge.tMax, edge.tMax));\n            splitEdges2.push(edge);\n            splitEdges2 = splitEdges2.concat(edges.slice().reverse());\n            // Reverse intersection edges for second loop\n            addedEnd = true;\n        } else {\n            splitEdges1.push(edge);\n            splitEdges2.push(edge);\n        }\n    }\n    // Step 4: Create new loops\n    const loop1 = new Loop(splitEdges1);\n    const loop2 = new Loop(splitEdges2);\n    // Step 5: Trim the surface and create new faces\n    const [uMin, uMax] = surface.getDomainU();\n    const [vMin, vMax] = surface.getDomainV();\n    const midU = (params1[0].u + params1[params1.length - 1].u) / 2;\n    // Simplified split point\n    const surface1 = surface.trim(uMin, midU, vMin, vMax);\n    const surface2 = surface.trim(midU, uMax, vMin, vMax);\n    const face1 = new Face(surface1, [loop1]);\n    const face2 = new Face(surface2, [loop2]);\n    return [\n        face1,\n        face2\n    ];\n}\n// Helper: Find intersection points between an edge and an intersection curve\nexport function findEdgeCurveIntersections(edge, intersectionCurve, tolerance = 0.000001) {\n    const curve = intersectionCurve.curve;\n    const intersections = curve.intersectCurve(edge.curve, tolerance);\n    const results = [];\n    for (let intersection of intersections) {\n        const tEdge = intersection.t2;\n        // Parameter on edge's curve\n        const tCurve = intersection.t1;\n        // Parameter on intersection curve\n        if (tEdge >= edge.tMin - tolerance && tEdge <= edge.tMax + tolerance && tCurve >= curve.tMin - tolerance && tCurve <= curve.tMax + tolerance) {\n            const point = edge.curve.evaluate(tEdge);\n            results.push({\n                point,\n                tEdge,\n                tCurve\n            });\n        }\n    }\n    return results;\n}\n// Helper: Split an edge at given parameter values\nexport function splitEdge(edge, tValues, tolerance = 0.000001) {\n    if (tValues.length === 0)\n        return [edge];\n    tValues.sort((a, b) => a - b);\n    const newEdges = [];\n    let currentVertex = edge.vertices[0];\n    let currentT = edge.tMin;\n    for (let t of tValues) {\n        if (t <= currentT + tolerance || t >= edge.tMax - tolerance)\n            continue;\n        const newPoint = edge.curve.evaluate(t);\n        const newVertex = new Vertex(newPoint);\n        newEdges.push(new Edge(edge.curve, currentVertex, newVertex, currentT, t));\n        currentVertex = newVertex;\n        currentT = t;\n    }\n    newEdges.push(new Edge(edge.curve, currentVertex, edge.vertices[1], currentT, edge.tMax));\n    return newEdges;\n}\n// Helper: Check if a point is inside a loop (2D projection for simplicity)\nexport function isPointInLoop(point, loop, surface, tolerance = 0.000001) {\n    // Project to UV space for simplicity (assumes surface is roughly planar in this example)\n    let crossings = 0;\n    for (let i = 0; i < loop.edges.length; i++) {\n        const edge = loop.edges[i];\n        const p1 = edge.getStartPoint();\n        const p2 = edge.getEndPoint();\n        if (p1.y > point.y !== p2.y > point.y && point.x < p1.x + (p2.x - p1.x) * (point.y - p1.y) / (p2.y - p1.y)) {\n            crossings++;\n        }\n    }\n    return crossings % 2 === 1;\n}\n// Helper: Convert a 3D edge to a UV NURBS curve on the surface\nexport function edgeToUVCurve(edge, surface, tolerance = 0.000001) {\n    const [tMin, tMax] = [\n        edge.tMin,\n        edge.tMax\n    ];\n    const samples = 10;\n    const dt = (tMax - tMin) / (samples - 1);\n    const uvPoints = [];\n    for (let i = 0; i < samples; i++) {\n        const t = tMin + i * dt;\n        const point3D = edge.curve.evaluate(t);\n        let minDist = Infinity;\n        let bestUV = null;\n        const uRange = surface.getDomainU();\n        const vRange = surface.getDomainV();\n        const uSteps = 20, vSteps = 20;\n        for (let u = uRange[0]; u <= uRange[1]; u += (uRange[1] - uRange[0]) / uSteps) {\n            for (let v = vRange[0]; v <= vRange[1]; v += (vRange[1] - vRange[0]) / vSteps) {\n                const p = surface.evaluate(u, v);\n                if (p && p.distanceTo(point3D) < minDist) {\n                    minDist = p.distanceTo(point3D);\n                    bestUV = new Point(u, v, 0);\n                }\n            }\n        }\n        if (minDist > tolerance)\n            throw new Error('Could not map edge point to surface UV space accurately');\n        uvPoints.push(bestUV);\n    }\n    return new NURBSCurve(2, uvPoints, [\n        0,\n        0,\n        0,\n        ...Array(uvPoints.length - 2).fill().map((_, i) => (i + 1) / (uvPoints.length - 1)),\n        1,\n        1,\n        1\n    ], Array(uvPoints.length).fill(1));\n}\n// Updated splitFaceWithCurves\nexport function splitFaceWithCurves(face, intersectionCurves, tolerance = 0.000001) {\n    const surface = face.surface;\n    const originalLoops = face.loops;\n    const edgeIntersections = new Map();\n    const allVertices = new Set();\n    const allEdges = new Set();\n    originalLoops.forEach(loop => loop.edges.forEach(edge => allEdges.add(edge)));\n    intersectionCurves.forEach(intersection => {\n        const curve = intersection.curve;\n        allEdges.forEach(edge => {\n            const intersections = findEdgeCurveIntersections(edge, intersection, tolerance);\n            if (intersections.length > 0) {\n                edgeIntersections.set(edge, (edgeIntersections.get(edge) || []).concat(intersections));\n            }\n        });\n    });\n    const newEdgesMap = new Map();\n    edgeIntersections.forEach((intersections, edge) => {\n        const tValues = intersections.map(i => i.tEdge);\n        const newEdges = splitEdge(edge, tValues, tolerance);\n        newEdgesMap.set(edge, newEdges);\n        newEdges.forEach(e => {\n            allVertices.add(e.vertices[0]);\n            allVertices.add(e.vertices[1]);\n            allEdges.add(e);\n        });\n        allEdges.delete(edge);\n    });\n    allEdges.forEach(edge => {\n        if (!newEdgesMap.has(edge)) {\n            allVertices.add(edge.vertices[0]);\n            allVertices.add(edge.vertices[1]);\n        }\n    });\n    const curveEdges = [];\n    intersectionCurves.forEach(intersection => {\n        const {curve, params1} = intersection;\n        const vertices = params1.map(param => new Vertex(surface.evaluate(param.u, param.v)));\n        for (let i = 0; i < vertices.length - 1; i++) {\n            const tMin = i / (vertices.length - 1);\n            const tMax = (i + 1) / (vertices.length - 1);\n            const newEdge = new Edge(curve, vertices[i], vertices[i + 1], tMin, tMax);\n            curveEdges.push(newEdge);\n            allEdges.add(newEdge);\n            allVertices.add(vertices[i]);\n            allVertices.add(vertices[i + 1]);\n        }\n    });\n    const loops = [];\n    const visitedEdges = new Set();\n    while (allEdges.size > 0) {\n        const startEdge = [...allEdges][0];\n        if (visitedEdges.has(startEdge)) {\n            allEdges.delete(startEdge);\n            continue;\n        }\n        const loopEdges = [];\n        let currentEdge = startEdge;\n        let currentVertex = currentEdge.vertices[0];\n        let closed = false;\n        do {\n            loopEdges.push(currentEdge);\n            visitedEdges.add(currentEdge);\n            allEdges.delete(currentEdge);\n            const nextVertex = currentEdge.vertices[0].point.equals(currentVertex.point) ? currentEdge.vertices[1] : currentEdge.vertices[0];\n            let nextEdge = null;\n            for (let edge of allEdges) {\n                if (!visitedEdges.has(edge) && (edge.vertices[0].point.equals(nextVertex.point) || edge.vertices[1].point.equals(nextVertex.point))) {\n                    nextEdge = edge;\n                    break;\n                }\n            }\n            if (!nextEdge) {\n                if (nextVertex.point.equals(loopEdges[0].vertices[0].point)) {\n                    closed = true;\n                    break;\n                }\n                break;\n            }\n            currentEdge = nextEdge;\n            currentVertex = nextVertex;\n        } while (!closed && loopEdges.length < 1000);\n        if (closed && loopEdges.length >= 3) {\n            loops.push(new Loop(loopEdges));\n        }\n    }\n    const faces = [];\n    const outerLoops = [];\n    const innerLoopsMap = new Map();\n    loops.forEach(loop => {\n        const centroid = loop.edges.reduce((sum, edge) => sum.add(edge.getStartPoint()), new Point(0, 0, 0)).scale(1 / loop.edges.length);\n        let isOuter = true;\n        for (let otherLoop of loops) {\n            if (loop !== otherLoop && isPointInLoop(centroid, otherLoop, surface, tolerance)) {\n                isOuter = false;\n                break;\n            }\n        }\n        if (isOuter) {\n            outerLoops.push(loop);\n            innerLoopsMap.set(loop, []);\n        } else {\n            for (let outer of outerLoops) {\n                if (isPointInLoop(centroid, outer, surface, tolerance)) {\n                    innerLoopsMap.get(outer).push(loop);\n                    break;\n                }\n            }\n        }\n    });\n    outerLoops.forEach(outerLoop => {\n        const innerLoops = innerLoopsMap.get(outerLoop);\n        const outerUVCurves = outerLoop.edges.map(edge => edgeToUVCurve(edge, surface, tolerance));\n        for (let i = 0; i < outerUVCurves.length; i++) {\n            const curr = outerUVCurves[i];\n            const next = outerUVCurves[(i + 1) % outerUVCurves.length];\n            const currEnd = curr.evaluate(curr.getDomain()[1]);\n            next.controlPoints[0] = currEnd;\n        }\n        const innerUVCurves = innerLoops.map(innerLoop => {\n            const curves = innerLoop.edges.map(edge => edgeToUVCurve(edge, surface, tolerance));\n            for (let i = 0; i < curves.length; i++) {\n                const curr = curves[i];\n                const next = curves[(i + 1) % curves.length];\n                const currEnd = curr.evaluate(curr.getDomain()[1]);\n                next.controlPoints[0] = currEnd;\n            }\n            return curves;\n        });\n        const trimmedSurface = surface.trimWithLoop(outerUVCurves, innerUVCurves, tolerance);\n        const faceLoops = [new Loop(outerLoop.edges)];\n        innerLoops.forEach(innerLoop => faceLoops.push(new Loop(innerLoop.edges)));\n        faces.push(new Face(trimmedSurface, faceLoops));\n    });\n    return faces;\n}\nconst tests = new Tests();\nconst tester = new Tester(tests);\ntester.runTests();",
      "filePath": "./simpleBREP.js",
      "description": "// Code file to be edited",
      "hidden": true
    },
    {
      "role": "assistant",
      "content": "Thanks for sharing the complete source code that I will be editing.",
      "hidden": false
    },
    {
      "role": "user",
      "content": "TEll me about our conversation so far. \n",
      "hidden": false
    },
    {
      "role": "assistant",
      "content": "In this conversation, we have established a set of guidelines for generating JavaScript code snippets. The key points are:\n\n1. Provide full, ready-to-use code solutions in ES6+ standards and best practices.\n2. Use modern JavaScript features like destructuring, arrow functions, async/await, and template literals.\n3. Optimize for readability and performance by structuring code clearly, minimizing dependencies, and anticipating potential optimizations.\n4. Incorporate robust error handling and edge case management in each solution to create resilient, production-ready code.\n5. Explain briefly and concisely if requested, focusing on clarity, simplicity, and relevance to the task.\n6. Anticipate the engineer's needs by building modular, maintainable, and JavaScript standards-adherent code.\n7. Address any challenges related to cross-browser compatibility, asynchronous operations, or API integration effectively.\n8. Only generate JavaScript, CSS, and HTML code as requested.\n9. Never make global variables or functions; all functionality must be encapsulated in a class.\n10. Do not include examples or tests in the code snippets.\n11. No external modifications are allowed – do not perform any monkey-patching or modify any code outside the class definition unless it's absolutely necessary for the task.\n12. Avoid modifying class constructors unless it's absolutely necessary for the task.\n13. Do not create global variables or functions; all logic should remain encapsulated within a class.\n14. If a class or function is exported, include the export statement in the snippet.\n15. Methods must be encapsulated in a class, and do not include methods that are not being modified in the code snippets.\n\nThese guidelines will ensure that I generate efficient, clean, modular JavaScript code tailored to your needs as an experienced engineer proficient in ES6+ standards.",
      "hidden": false
    }
  ],
  "title": "\"JavaScript Code Snippets: Efficient Solutions & Best Practices\"",
  "id": "20250319_050448537Z",
  "targetFile": "./simpleBREP.js",
  "chatMode": "chat",
  "conversationNew": false,
  "lastModified": "2025-03-19T05:05:27.675Z"
}