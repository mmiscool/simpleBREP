{
  "messages": [
    {
      "role": "system",
      "content": "./.aiCoder/prompts/default-system-prompt.md",
      "filePath": "./.aiCoder/prompts/default-system-prompt.md",
      "description": "",
      "hidden": true
    },
    {
      "role": "user",
      "content": "./.aiCoder/prompts/default-plan-prompt.md",
      "filePath": "./.aiCoder/prompts/default-plan-prompt.md",
      "description": "",
      "hidden": true
    },
    {
      "role": "user",
      "content": "./brep.js",
      "filePath": "./brep.js",
      "description": "// Code file to be edited",
      "hidden": true
    },
    {
      "role": "system",
      "content": "./.aiCoder/prompts/snippet-production-prompt.md",
      "filePath": "./.aiCoder/prompts/snippet-production-prompt.md",
      "description": "",
      "hidden": true
    },
    {
      "role": "user",
      "content": "Write the projectPoint method in the Surface class.\nRemember to respond with a snippet in the form of the following:\n```\nclass Surface {\n    projectPoint(point) {\n        // your code here\n    }\n}\n```\n",
      "hidden": false
    },
    {
      "role": "assistant",
      "content": "```javascript\nclass Surface {\n    projectPoint(point) {\n        if (!point) {\n            return null;\n        }\n        if (this.type === 'plane') {\n            const origin = this.parameters.origin || { x: 0, y: 0, z: 0 };\n            const normal = this.parameters.normal || { x: 0, y: 0, z: 1 };\n            const uDir = this.parameters.uDir || { x: 1, y: 0, z: 0 };\n            const vDir = this.parameters.vDir || { x: 0, y: 1, z: 0 };\n    \n            const v = {\n              x: point.x - origin.x,\n              y: point.y - origin.y,\n              z: point.z - origin.z\n            };\n    \n            const u = (v.x * uDir.x + v.y * uDir.y + v.z * uDir.z);\n            const vParam = (v.x * vDir.x + v.y * vDir.y + v.z * vDir.z);\n    \n            return { u: u, v: vParam };\n          } else if (this.type === 'sphere') {\n              const center = this.parameters.center || { x: 0, y: 0, z: 0 };\n              const radius = this.parameters.radius || 1;\n              const v = {\n                  x: point.x - center.x,\n                  y: point.y - center.y,\n                  z: point.z - center.z\n              };\n              const magnitude = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);\n              if(magnitude < 1e-8){\n                return { u: 0, v: 0 };\n              }\n              const normalized = {\n                  x: v.x / magnitude,\n                  y: v.y / magnitude,\n                  z: v.z / magnitude\n              };\n              const u = Math.atan2(normalized.y, normalized.x);\n              const vParam = Math.asin(normalized.z);\n              return { u: u, v: vParam };\n          } else if (this.type === 'cylinder') {\n              const origin = this.parameters.origin || { x: 0, y: 0, z: 0 };\n              const axis = this.parameters.axis || { x: 0, y: 0, z: 1 };\n              const radius = this.parameters.radius || 1;\n      \n              const v = {\n                  x: point.x - origin.x,\n                  y: point.y - origin.y,\n                  z: point.z - origin.z\n              };\n      \n              const proj = v.x * axis.x + v.y * axis.y + v.z * axis.z;\n              const projVector = {\n                  x: proj * axis.x,\n                  y: proj * axis.y,\n                  z: proj * axis.z\n              };\n      \n              const radialVector = {\n                  x: v.x - projVector.x,\n                  y: v.y - projVector.y,\n                  z: v.z - projVector.z\n              };\n              const radialMag = Math.sqrt(radialVector.x * radialVector.x + radialVector.y * radialVector.y + radialVector.z * radialVector.z);\n                if(radialMag < 1e-8){\n                    return { u: 0, v: 0 };\n                }\n              const u = Math.atan2(radialVector.y, radialVector.x);\n              const vParam = proj;\n              return { u: u, v: vParam };\n          } else if (this.type === 'cone') {\n            const origin = this.parameters.origin || { x: 0, y: 0, z: 0 };\n            const apex = this.parameters.apex || { x: 0, y: 0, z: 1 };\n            const angle = this.parameters.angle || Math.PI / 4;\n      \n            const v = {\n              x: point.x - origin.x,\n              y: point.y - origin.y,\n              z: point.z - origin.z\n            };\n      \n           const direction = {\n            x: apex.x - origin.x,\n            y: apex.y - origin.y,\n            z: apex.z - origin.z\n          };\n          const magnitude = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);\n           const axis = {\n                x: direction.x / magnitude,\n                y: direction.y / magnitude,\n                z: direction.z / magnitude\n            };\n      \n           const proj = v.x * axis.x + v.y * axis.y + v.z * axis.z;\n            const projVector = {\n                x: proj * axis.x,\n                y: proj * axis.y,\n                z: proj * axis.z\n            };\n            const radialVector = {\n              x: v.x - projVector.x,\n              y: v.y - projVector.y,\n              z: v.z - projVector.z\n            };\n      \n              const radialMag = Math.sqrt(radialVector.x * radialVector.x + radialVector.y * radialVector.y + radialVector.z * radialVector.z);\n            if(radialMag < 1e-8){\n              return { u: 0, v: 0 };\n            }\n            const u = Math.atan2(radialVector.y, radialVector.x);\n      \n            const vParam = proj ;\n            return { u: u, v: vParam };\n          }else if (this.type === 'nurbs') {\n             if (!this.parameters.nurbsSurface) {\n                  return null;\n              }\n                const nurbsSurface = this.parameters.nurbsSurface;\n                 let initialU = 0.5;\n                 let initialV = 0.5;\n                 let iterations = 0;\n                 const maxIterations = 100;\n                 const tolerance = 1e-8;\n                 let currentPoint = nurbsSurface.evaluate(initialU,initialV);\n      \n                 while (iterations < maxIterations) {\n                   \n                   const surfacePoint = nurbsSurface.evaluate(initialU, initialV);\n                   if(!surfacePoint)\n                   {\n                     return null;\n                   }\n                   const diff = {\n                     x: point.x - surfacePoint[0],\n                     y: point.y - surfacePoint[1],\n                     z: point.z - surfacePoint[2]\n                   };\n                  const diffMag =  Math.sqrt(diff.x * diff.x + diff.y * diff.y + diff.z * diff.z)\n                   if(diffMag < tolerance){\n                     return {u:initialU, v:initialV};\n                   }\n                   \n                    const du = nurbsSurface.uDerivative(initialU, initialV, 1);\n                    const dv = nurbsSurface.vDerivative(initialU, initialV, 1);\n                    if(!du || !dv){\n                        return null;\n                    }\n                    const J = [\n                        [du[0], dv[0]],\n                        [du[1], dv[1]],\n                        [du[2], dv[2]]\n                    ];\n      \n                    const JT = [\n                        [J[0][0], J[1][0], J[2][0]],\n                        [J[0][1], J[1][1], J[2][1]]\n                    ]\n      \n                     const JTJ = [\n                         [JT[0][0]*J[0][0] + JT[0][1]*J[1][0] + JT[0][2]*J[2][0] , JT[0][0]*J[0][1] + JT[0][1]*J[1][1] + JT[0][2]*J[2][1]],\n                         [JT[1][0]*J[0][0] + JT[1][1]*J[1][0] + JT[1][2]*J[2][0] , JT[1][0]*J[0][1] + JT[1][1]*J[1][1] + JT[1][2]*J[2][1]]\n                     ];\n      \n                      const JTdiff = [\n                        JT[0][0] * diff.x + JT[0][1] * diff.y + JT[0][2] * diff.z,\n                        JT[1][0] * diff.x + JT[1][1] * diff.y + JT[1][2] * diff.z\n                     ];\n                     const det = JTJ[0][0] * JTJ[1][1] - JTJ[0][1] * JTJ[1][0];\n                     if(Math.abs(det) < 1e-10){\n                        return {u:initialU, v:initialV};\n                     }\n                     const invJTJ = [\n                        [JTJ[1][1]/det , -JTJ[0][1]/det],\n                        [-JTJ[1][0]/det, JTJ[0][0]/det]\n                    ];\n                    const deltaU = invJTJ[0][0] * JTdiff[0] + invJTJ[0][1] * JTdiff[1];\n                    const deltaV = invJTJ[1][0] * JTdiff[0] + invJTJ[1][1] * JTdiff[1];\n      \n                     initialU -= deltaU;\n                     initialV -= deltaV;\n                     iterations++;\n      \n                     if(initialU < 0)\n                     {\n                        initialU = 0;\n                     }\n                     if(initialU > 1)\n                     {\n                       initialU = 1;\n                     }\n                     if(initialV < 0)\n                     {\n                       initialV = 0;\n                     }\n                     if(initialV > 1)\n                     {\n                       initialV = 1;\n                     }\n                  }\n      \n              return {u:initialU, v:initialV}\n           }\n        return null;\n    }\n}\n```",
      "hidden": false
    }
  ],
  "title": "NURBS Library for BREP Kernel Development",
  "id": "20250110_104521618Z",
  "targetFile": "./brep.js",
  "chatMode": "chat",
  "conversationNew": false,
  "lastModified": "2025-01-10T10:45:44.490Z"
}