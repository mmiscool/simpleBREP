{
  "messages": [
    {
      "role": "system",
      "content": "./.aiCoder/prompts/default-system-prompt.md",
      "filePath": "./.aiCoder/prompts/default-system-prompt.md",
      "description": "",
      "hidden": true
    },
    {
      "role": "user",
      "content": "./.aiCoder/prompts/default-plan-prompt.md",
      "filePath": "./.aiCoder/prompts/default-plan-prompt.md",
      "description": "",
      "hidden": true
    },
    {
      "role": "user",
      "content": "./brep.js",
      "filePath": "./brep.js",
      "description": "// Code file to be edited",
      "hidden": true
    },
    {
      "role": "system",
      "content": "./.aiCoder/prompts/snippet-production-prompt.md",
      "filePath": "./.aiCoder/prompts/snippet-production-prompt.md",
      "description": "",
      "hidden": true
    },
    {
      "role": "user",
      "content": "I want to build a complete BREP kernel in javascript. ",
      "hidden": false
    },
    {
      "role": "assistant",
      "content": "Okay, let's start building a foundation for a BREP kernel in JavaScript. I'll provide you with the code for the `NurbsCurve` class, as you requested.  This class will be a core component of your BREP kernel. Remember, this will only contain the methods you requested.\n\n```javascript\nclass NurbsCurve {\n    constructor(knotVector, controlPoints, degree, dimension = 3, isRational = true) {\n      //Input Validation\n      if (!knotVector || !Array.isArray(knotVector) || knotVector.length < degree + 2) {\n        throw new Error(\"Invalid knot vector.\");\n      }\n      if (!controlPoints || !Array.isArray(controlPoints) || controlPoints.length === 0) {\n        throw new Error(\"Invalid control points.\");\n      }\n      if (controlPoints.length !== knotVector.length - degree - 1)\n      {\n        throw new Error(\"Number of control points must match knot vector and degree\")\n      }\n\n      if (typeof degree !== 'number' || degree < 1) {\n          throw new Error(\"Degree must be a positive number.\");\n      }\n      if (dimension !== 2 && dimension !== 3) {\n          throw new Error(\"Dimension must be 2 or 3\");\n      }\n\n      this.knotVector = knotVector;\n      this.controlPoints = controlPoints;\n      this.degree = degree;\n      this.dimension = dimension;\n      this.isRational = isRational;\n    }\n\n\n    evaluate(u) {\n      const homogeneousPoint = this.evaluateHomogeneous(u);\n      if (this.isRational) {\n          const w = homogeneousPoint[this.dimension];\n          const cartesianPoint = homogeneousPoint.slice(0, this.dimension).map(coord => coord / w);\n          return cartesianPoint;\n      } else {\n          return homogeneousPoint.slice(0, this.dimension);\n      }\n    }\n\n    evaluateHomogeneous(u) {\n      const degree = this.degree;\n      const knotVector = this.knotVector;\n      const controlPoints = this.controlPoints;\n      const dimension = this.dimension;\n      const n = controlPoints.length -1; //n is the number of basis functions - 1\n\n\n      if(u < knotVector[0] || u > knotVector[knotVector.length - 1]){\n        throw new Error(\"Parameter u is out of bounds\")\n      }\n  \n      let span = this.findSpan(n, degree, u, knotVector);\n\n      const basisValues = this.basisFunctions(span, u, degree, knotVector);\n\n      let point = new Array(dimension + (this.isRational ? 1 : 0)).fill(0);\n\n\n      for (let i = 0; i <= degree; i++) {\n        const controlPoint = controlPoints[span - degree + i];\n          for(let j = 0; j < point.length; j++){\n            point[j] += basisValues[i] * controlPoint[j];\n          }\n      }\n      return point;\n    }\n\n    derivative(u, order) {\n      if (order < 0) {\n        throw new Error(\"Order must be a non-negative integer.\");\n      }\n      if (order === 0)\n      {\n        return this.evaluate(u)\n      }\n      const degree = this.degree;\n      const knotVector = this.knotVector;\n      const controlPoints = this.controlPoints;\n      const dimension = this.dimension;\n      const n = controlPoints.length -1; //n is the number of basis functions - 1\n\n      if(u < knotVector[0] || u > knotVector[knotVector.length - 1]){\n        throw new Error(\"Parameter u is out of bounds\")\n      }\n\n      let ders = this.curveDerivatives(u, order);\n      let point = new Array(dimension).fill(0);\n      if(this.isRational)\n      {\n        let C = new Array(order + 1).fill(0).map(() => new Array(dimension).fill(0));\n        let w = new Array(order + 1).fill(0);\n\n        for(let k = 0; k <= order; k++){\n          w[k] = ders[k][dimension];\n            for(let j = 0; j < dimension; j++){\n              C[k][j] = ders[k][j];\n            }\n        }\n\n        for(let k = 0; k <= order; k++){\n            for(let j = 0; j < dimension; j++){\n               let result = C[k][j];\n               for(let i = 1; i <= k; i++)\n               {\n                result -= (this.binomialCoefficient(k, i) * w[i] * C[k-i][j])\n               }\n                point[j] = result / w[0];\n           }\n        }\n      } else {\n        for(let j = 0; j < dimension; j++){\n            point[j] = ders[order][j];\n          }\n      }\n      \n      return point;\n\n    }\n\n    getControlPoints() {\n        return this.controlPoints.map(cp => [...cp]); // Return a copy to prevent modification\n    }\n\n\n    transform(matrix) {\n        if (!matrix || matrix.length !== 4 || !matrix.every(row => row.length === 4)) {\n            throw new Error(\"Transformation matrix must be a 4x4 array.\");\n        }\n\n\n        this.controlPoints = this.controlPoints.map(cp => {\n           const transformedPoint = [0, 0, 0, 0];\n           for(let i = 0; i < 4; i++){\n            for (let j = 0; j < 4; j++){\n                 transformedPoint[i] += matrix[i][j] * cp[j];\n             }\n            }\n          return transformedPoint;\n      });\n    }\n\n\n    refine(u) {\n         const degree = this.degree;\n         const knotVector = this.knotVector;\n         const controlPoints = this.controlPoints;\n        \n         const n = controlPoints.length -1; \n\n\n         if(u < knotVector[0] || u > knotVector[knotVector.length - 1]){\n            throw new Error(\"Parameter u is out of bounds\")\n          }\n\n         let span = this.findSpan(n, degree, u, knotVector);\n\n         let newKnots = [...knotVector];\n\n         newKnots.splice(span + 1, 0, u);\n       \n         let newControlPoints = [];\n\n\n        const alpha = new Array(degree + 1).fill(0);\n        for (let i = 0; i <= n; i++) {\n            newControlPoints.push([...controlPoints[i]])\n        }\n\n\n        for(let i = 1; i <= degree; i++){\n            alpha[i] = new Array(degree + 1).fill(0);\n            let j = span - degree + i;\n            for(let k = 1; k <= degree - i + 1; k++){\n                alpha[k] = (u - knotVector[j + k - 1]) / (knotVector[j + degree - i + k] - knotVector[j + k - 1]);\n                for(let m = 0; m < newControlPoints[0].length; m++){\n                    newControlPoints[j + k - 1][m] = (1 - alpha[k]) * newControlPoints[j + k - 1][m] + alpha[k] * newControlPoints[j + k][m];\n                 }\n            }\n        }\n        \n         this.knotVector = newKnots\n         this.controlPoints = newControlPoints;\n    }\n\n    degreeElevate() {\n      \n        const degree = this.degree;\n        const knotVector = this.knotVector;\n        const controlPoints = this.controlPoints;\n        const n = controlPoints.length -1;\n    \n        const newDegree = degree + 1;\n    \n        const newControlPoints = new Array(n + 2).fill(null).map(() => new Array(controlPoints[0].length).fill(0));\n\n         //copy control points\n        for(let i = 0; i <= n; i++){\n            for(let j = 0; j < controlPoints[0].length; j++){\n               newControlPoints[i][j] = controlPoints[i][j];\n            }\n        }\n\n      const alpha = new Array(n + 2).fill(0);\n        for (let i = 0; i <= n; i++)\n        {\n            alpha[i] = 1;\n         }\n          \n        for (let k = 1; k <= newDegree; k++){\n             let j = n + 1;\n            for(let i = n; i >= 0 ; i--){\n                if (alpha[i] > 0)\n                {\n                  j = i;\n                 }\n                 alpha[i] = (knotVector[i + newDegree] - knotVector[i+k]) / (knotVector[i + newDegree] - knotVector[i + 1]);\n                 for(let m = 0; m < newControlPoints[0].length; m++){\n                    newControlPoints[i][m] = alpha[i] * newControlPoints[i][m] + (1 - alpha[i]) * newControlPoints[j][m]\n                  }\n             }\n        }\n         this.degree = newDegree;\n         this.controlPoints = newControlPoints;\n    }\n\n    knotRemove(u) {\n      \n      const degree = this.degree;\n      const knotVector = this.knotVector;\n      const controlPoints = this.controlPoints;\n      const n = controlPoints.length - 1;\n     \n      if(u < knotVector[0] || u > knotVector[knotVector.length - 1]){\n          throw new Error(\"Parameter u is out of bounds\")\n      }\n\n\n      let span = this.findSpan(n, degree, u, knotVector);\n\n\n      if (this.isMultipleKnot(u, knotVector) === false)\n      {\n        throw new Error(\"Cannot remove a single knot\")\n      }\n       let newKnots = [...knotVector];\n       let newControlPoints = [...controlPoints]\n\n       newKnots.splice(span + 1, 1);\n\n\n       const alpha = new Array(degree + 1).fill(0);\n        for (let i = 0; i <= n; i++) {\n            newControlPoints.push([...controlPoints[i]])\n        }\n\n\n        for(let i = 1; i <= degree; i++){\n            alpha[i] = new Array(degree + 1).fill(0);\n            let j = span - degree + i;\n            for(let k = 1; k <= degree - i + 1; k++){\n                alpha[k] = (u - knotVector[j + k - 1]) / (knotVector[j + degree - i + k] - knotVector[j + k - 1]);\n                for(let m = 0; m < newControlPoints[0].length; m++){\n                    newControlPoints[j + k - 1][m] = (1 - alpha[k]) * newControlPoints[j + k - 1][m] + alpha[k] * newControlPoints[j + k][m];\n                 }\n            }\n        }\n         \n         newControlPoints.splice(span,1);\n       \n         this.knotVector = newKnots;\n         this.controlPoints = newControlPoints\n    }\n\n    split(u) {\n        const degree = this.degree;\n        const knotVector = this.knotVector;\n        const controlPoints = this.controlPoints;\n        const n = controlPoints.length - 1;\n\n\n        if(u < knotVector[0] || u > knotVector[knotVector.length - 1]){\n            throw new Error(\"Parameter u is out of bounds\")\n         }\n        \n        const leftCurve = this.clone();\n        const rightCurve = this.clone();\n      \n        let span = this.findSpan(n, degree, u, knotVector);\n\n        for (let i = 0; i <= degree; i++)\n        {\n            rightCurve.refine(u)\n        }\n\n      \n      let leftControlPoints = [];\n      let rightControlPoints = [];\n      let leftKnotVector = [];\n      let rightKnotVector = [];\n\n      for(let i = 0; i <= span; i++){\n         leftKnotVector.push(knotVector[i]);\n      }\n\n      for(let i = span + degree + 1; i < knotVector.length; i++){\n         rightKnotVector.push(knotVector[i]);\n      }\n\n\n        for(let i = 0; i <= span; i++){\n          leftControlPoints.push(leftCurve.controlPoints[i])\n        }\n        for(let i = span ; i < leftCurve.controlPoints.length; i++){\n            rightControlPoints.push(leftCurve.controlPoints[i])\n          }\n\n\n          leftCurve.controlPoints = leftControlPoints;\n          rightCurve.controlPoints = rightControlPoints;\n\n          leftCurve.knotVector = leftKnotVector;\n          rightCurve.knotVector = rightKnotVector;\n\n\n          return [leftCurve, rightCurve];\n      }\n    \n    reverse() {\n      this.controlPoints.reverse();\n      this.knotVector.reverse();\n\n      for(let i = 0; i < this.knotVector.length; i++)\n      {\n        this.knotVector[i] = -this.knotVector[i]\n      }\n\n      let min = Math.min(...this.knotVector);\n\n      for(let i = 0; i < this.knotVector.length; i++)\n      {\n        this.knotVector[i] = this.knotVector[i] - min\n      }\n\n      return this;\n      }\n      \n\n    isPeriodic() {\n        const knotVector = this.knotVector;\n        const degree = this.degree;\n        const n = this.controlPoints.length - 1;\n        \n        const firstKnot = knotVector[0];\n        const lastKnot = knotVector[knotVector.length -1];\n\n        if (n < degree) {\n          return false; // Not enough control points to be periodic\n        }\n        \n        if(Math.abs(lastKnot - firstKnot) < 1e-8){\n          return true;\n        }\n  \n        return false;\n    }\n  \n    isClosed() {\n        if(this.isPeriodic() === true) {\n          return true\n        }\n\n        const firstPoint = this.evaluate(this.knotVector[0]);\n        const lastPoint = this.evaluate(this.knotVector[this.knotVector.length-1])\n\n        if(firstPoint.length !== lastPoint.length) return false;\n        \n        for(let i = 0; i < firstPoint.length; i++){\n          if(Math.abs(firstPoint[i] - lastPoint[i]) > 1e-8){\n              return false\n            }\n        }\n        return true;\n    }\n\n    getBoundingBox() {\n        let minX, minY, minZ, maxX, maxY, maxZ;\n        minX = minY = minZ = Infinity;\n        maxX = maxY = maxZ = -Infinity;\n\n\n        const step = 0.1;\n        for (let u = this.knotVector[0]; u <= this.knotVector[this.knotVector.length -1]; u += step) {\n          const point = this.evaluate(u);\n           \n            minX = Math.min(minX, point[0]);\n            minY = Math.min(minY, point[1]);\n             if(point.length === 3){\n               minZ = Math.min(minZ, point[2]);\n             }\n             maxX = Math.max(maxX, point[0]);\n             maxY = Math.max(maxY, point[1]);\n             if(point.length === 3){\n                maxZ = Math.max(maxZ, point[2]);\n             }\n          }\n        \n        if(this.dimension === 2)\n          return { min: [minX, minY], max: [maxX, maxY] };\n\n          return { min: [minX, minY, minZ], max: [maxX, maxY, maxZ] };\n    }\n\n    clone() {\n        return new NurbsCurve(\n            [...this.knotVector],\n            this.controlPoints.map(cp => [...cp]),\n            this.degree,\n            this.dimension,\n            this.isRational\n        );\n    }\n  \n    getLength() {\n       const gaussLegendre = this.gaussLegendreQuadrature(10);\n\n       let sum = 0;\n        for (let i = 0; i < gaussLegendre.length; i++) {\n           const u = gaussLegendre[i][0]\n           const weight = gaussLegendre[i][1]\n            const tangent = this.derivative(u, 1)\n            const length = Math.sqrt(tangent.reduce((sum, val) => sum + val * val, 0))\n            sum += weight * length;\n        }\n        return sum;\n    }\n\n  getParameterAtLength(length) {\n\n    const tolerance = 1e-6; // Adjust as needed\n    let u = 0;\n    let low = this.knotVector[0];\n    let high = this.knotVector[this.knotVector.length-1]\n\n    for(let i = 0; i < 100; i++){\n      const currentLength = this.getLengthAtParameter(u);\n        if (Math.abs(currentLength - length) < tolerance) {\n            return u;\n        }\n\n        if(currentLength < length){\n             low = u;\n            u = (high + u)/ 2\n        } else {\n          high = u\n          u = (low + u) / 2\n        }\n      \n    }\n\n      return u;\n\n  }\n    getCurvature(u) {\n        const firstDerivative = this.derivative(u, 1);\n        const secondDerivative = this.derivative(u, 2);\n\n        const dx = firstDerivative[0];\n        const dy = firstDerivative[1];\n        const ddx = secondDerivative[0];\n        const ddy = secondDerivative[1];\n\n          if (firstDerivative.length === 3){\n                const dz = firstDerivative[2];\n                const ddz = secondDerivative[2];\n             \n                const numerator = Math.sqrt(Math.pow((dy * ddz) - (dz * ddy), 2) + Math.pow((dz * ddx) - (dx * ddz), 2) + Math.pow((dx * ddy) - (dy * ddx), 2))\n              const denominator = Math.pow((dx * dx) + (dy * dy) + (dz * dz), 1.5)\n              return  numerator / denominator;\n          }\n          const numerator = Math.abs((dx * ddy) - (dy * ddx));\n          const denominator = Math.pow((dx * dx) + (dy * dy), 1.5);\n        return numerator / denominator;\n\n    }\n\n    getNormal(u) {\n       const firstDerivative = this.derivative(u, 1);\n       const secondDerivative = this.derivative(u, 2);\n\n        const dx = firstDerivative[0];\n        const dy = firstDerivative[1];\n        const ddx = secondDerivative[0];\n        const ddy = secondDerivative[1];\n\n        if (firstDerivative.length === 3){\n            const dz = firstDerivative[2];\n            const ddz = secondDerivative[2];\n            const normal = [\n              (dy * ddz) - (dz * ddy),\n              (dz * ddx) - (dx * ddz),\n              (dx * ddy) - (dy * ddx),\n            ]\n            const magnitude = Math.sqrt(normal[0]*normal[0] + normal[1]*normal[1] + normal[2]*normal[2]);\n            return [normal[0] / magnitude, normal[1] / magnitude, normal[2] / magnitude]\n        }\n        const normal = [ -(dy), dx]\n        const magnitude = Math.sqrt(normal[0]*normal[0] + normal[1]*normal[1]);\n          return [normal[0] / magnitude, normal[1] / magnitude]\n    }\n    \n      getTanget(u) {\n        const tangent = this.derivative(u, 1)\n        const magnitude = Math.sqrt(tangent.reduce((sum, val) => sum + val * val, 0))\n        return tangent.map(t => t / magnitude)\n      }\n\n\n    // Helper Functions\n    findSpan(n, degree, u, knotVector) {\n        if(u === knotVector[n+1])\n        {\n          return n;\n        }\n        let low = degree;\n        let high = n + 1;\n        let mid = Math.floor((low + high) / 2);\n        while(u < knotVector[mid] || u >= knotVector[mid + 1]){\n          if (u < knotVector[mid])\n          {\n            high = mid;\n          } else {\n            low = mid\n          }\n          mid = Math.floor((low + high) / 2)\n        }\n      return mid;\n    }\n\n\n    basisFunctions(span, u, degree, knotVector) {\n      const basisValues = new Array(degree + 1).fill(0);\n      const left = new Array(degree + 1).fill(0);\n      const right = new Array(degree + 1).fill(0);\n      basisValues[0] = 1;\n\n      for (let j = 1; j <= degree; j++)\n      {\n          left[j] = u - knotVector[span + 1 - j];\n          right[j] = knotVector[span + j] - u;\n          let saved = 0;\n          for(let r = 0; r < j; r++){\n              const temp = basisValues[r] / (right[r + 1] + left[j - r]);\n              basisValues[r] = saved + right[r + 1] * temp;\n              saved = left[j - r] * temp\n          }\n          basisValues[j] = saved\n      }\n      return basisValues;\n    }\n\n    curveDerivatives(u, order) {\n        const degree = this.degree;\n        const knotVector = this.knotVector;\n        const controlPoints = this.controlPoints;\n        const dimension = this.dimension;\n        const n = controlPoints.length - 1;\n\n\n        let du = Math.min(order, degree);\n\n        if(u < knotVector[0] || u > knotVector[knotVector.length - 1]){\n          throw new Error(\"Parameter u is out of bounds\")\n        }\n\n        let span = this.findSpan(n, degree, u, knotVector);\n\n        const ders = new Array(order + 1).fill(null).map(() => new Array(dimension + (this.isRational ? 1 : 0)).fill(0));\n        const ndu = new Array(degree + 1).fill(null).map(() => new Array(degree + 1).fill(0));\n        const a = new Array(2).fill(null).map(() => new Array(degree + 1).fill(0));\n\n        ndu[0][0] = 1;\n\n        for(let j = 1; j <= degree; j++){\n            let left = u - knotVector[span + 1 - j];\n            let right = knotVector[span + j] - u;\n            let saved = 0;\n\n            for (let r = 0; r < j; r++){\n                ndu[j][r] = right + left;\n                const temp = ndu[j-1][r] / ndu[j][r]\n                ndu[j][r] = saved + right * temp;\n                saved = left * temp;\n            }\n            ndu[j][j] = saved;\n        }\n\n\n        for (let j = 0; j <= degree; j++) {\n             for(let k = 0; k <= dimension + (this.isRational ? 1 : 0); k++){\n               ders[0][k] += ndu[degree][j] * controlPoints[span - degree + j][k];\n            }\n         }\n\n        for (let r = 0; r <= degree; r++) {\n            let s1 = 0;\n            let s2 = 1;\n            a[0][0] = 1;\n           for (let k = 1; k <= du; k++) {\n            let d = 0;\n                let rk = r - k;\n                let pk = degree - k\n                if (r >= k) {\n                  a[s2][0] = a[s1][0] / ndu[pk+1][k]\n                  d = a[s2][0] * (ndu[pk][r] - ndu[pk][rk])\n                }\n\n                 if (r < k){\n                    d = 0;\n                 }\n                  else {\n                       d = a[s2][0] * ndu[pk][r]\n                  }\n                \n                  if (r < k) continue\n                \n                a[s2][k] = d\n                let j = 1;\n                while(j <= k){\n                  if(r >= j){\n                    d = (a[s1][j] - a[s1][j-1]) / ndu[pk + 1][j];\n                    a[s2][j] = d * (ndu[pk][r] - ndu[pk][rk + j])\n                    \n                  }else {\n                      a[s2][j] = 0;\n                  }\n                 j++\n              }\n\n            let temp = s1;\n            s1 = s2;\n            s2 = temp;\n\n           }\n           if(r <= order){\n            for(let k = 0; k <= dimension + (this.isRational ? 1 : 0); k++){\n               ders[r][k] = a[s1][0] * controlPoints[span - degree + r][k]\n            }\n             for(let k = 1; k <= du; k++){\n              for(let m = 0; m <= dimension + (this.isRational ? 1 : 0); m++){\n                  ders[r][m] += a[s1][k] * controlPoints[span - degree + r + k][m];\n                }\n              }\n         \n           }\n        }\n        return ders;\n    }\n    \n    binomialCoefficient(n, k) {\n        if (k < 0 || k > n) {\n            return 0;\n        }\n        if (k === 0 || k === n) {\n            return 1;\n        }\n        if (k > n / 2) {\n            k = n - k;\n        }\n        let res = 1;\n        for (let i = 1; i <= k; ++i) {\n            res = (res * (n - i + 1)) / i;\n        }\n        return res;\n    }\n\n    isMultipleKnot(u, knotVector){\n      let count = 0\n      for(let i = 0; i < knotVector.length; i++)\n      {\n        if(Math.abs(knotVector[i]- u) < 1e-8){\n            count++\n        }\n      }\n        return count > 1;\n    }\n    getLengthAtParameter(u){\n       const gaussLegendre = this.gaussLegendreQuadrature(10);\n       let sum = 0;\n       const startKnot = this.knotVector[0]\n        for (let i = 0; i < gaussLegendre.length; i++) {\n          let param = ((u - startKnot)/2) * (gaussLegendre[i][0] + 1) + startKnot\n           const weight = gaussLegendre[i][1]\n           const tangent = this.derivative(param, 1)\n           const length = Math.sqrt(tangent.reduce((sum, val) => sum + val * val, 0))\n           sum += weight * length;\n       }\n       return ((u-startKnot)/2) * sum;\n    }\n    gaussLegendreQuadrature(n) {\n      if (n === 1) return [[0, 2]];\n      if (n === 2) return [[-0.577350269189626, 1], [0.577350269189626, 1]];\n      if (n === 3) return [[-0.774596669241483, 0.555555555555556], [0, 0.888888888888889], [0.774596669241483, 0.555555555555556]];\n      if(n === 4) return [[-0.861136311594052, 0.347854845137454], [-0.339981043584856, 0.652145154862546], [0.339981043584856, 0.652145154862546], [0.861136311594052, 0.347854845137454]];\n      if(n === 5) return [[-0.906179845938664, 0.236926885056189], [-0.538469310105683, 0.478628670499366], [0, 0.568888888888889], [0.538469310105683, 0.478628670499366], [0.906179845938664, 0.236926885056189]];\n      if(n === 6) return [[-0.932469514203152, 0.171324492379170], [-0.661209386466265, 0.360761573048139], [-0.238619186083197, 0.467913934572691], [0.238619186083197, 0.467913934572691], [0.661209386466265, 0.360761573048139], [0.932469514203152, 0.171324492379170]];\n      if(n === 7) return [[-0.949107912342759, 0.129484966168870], [-0.741531185599394, 0.279705391489274], [-0.405845151377397, 0.381830050505119], [0, 0.417959183673469], [0.405845151377397, 0.381830050505119], [0.741531185599394, 0.279705391489274], [0.949107912342759, 0.129484966168870]];\n      if(n === 8) return [[-0.960289856497536, 0.101228536290376], [-0.796666477410134, 0.222381034453374], [-0.525532409916329, 0.313706645877887], [-0.183434642495650, 0.362683783378362], [0.183434642495650, 0.362683783378362], [0.525532409916329, 0.313706645877887], [0.796666477410134, 0.222381034453374], [0.960289856497536, 0.101228536290376]];\n      if(n === 9) return [[-0.968160239507626, 0.081274388361574], [-0.836031107326636, 0.180648160694857], [-0.613371432700590, 0.260610696402935], [-0.324253423403809, 0.31234707704000",
      "hidden": false
    }
  ],
  "title": "Building a BREP Kernel with NURBS",
  "id": "20250110_100418003Z",
  "targetFile": "./brep.js",
  "chatMode": "chat",
  "conversationNew": false,
  "lastModified": "2025-01-10T10:06:13.898Z"
}