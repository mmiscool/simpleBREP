{
  "messages": [
    {
      "role": "system",
      "content": "./.aiCoder/prompts/default-system-prompt.md",
      "filePath": "./.aiCoder/prompts/default-system-prompt.md",
      "description": ""
    },
    {
      "role": "user",
      "content": "./.aiCoder/prompts/default-plan-prompt.md",
      "filePath": "./.aiCoder/prompts/default-plan-prompt.md",
      "description": ""
    },
    {
      "role": "user",
      "content": "./NURBS.js",
      "filePath": "./NURBS.js",
      "description": "// Code file to be edited"
    },
    {
      "role": "system",
      "content": "./.aiCoder/prompts/snippet-production-prompt.md",
      "filePath": "./.aiCoder/prompts/snippet-production-prompt.md",
      "description": ""
    },
    {
      "role": "user",
      "content": "Write the curveCurveIntersection function.\nRemember to respond with a snippet in the form of the following:\n```\nfunction curveCurveIntersection(curveA, curveB) {\n    // your code here\n}\n```            \n"
    },
    {
      "role": "assistant",
      "content": "```javascript\nclass Intersection {\n    constructor(curveIndexA, curveIndexB, surfaceIndexA, surfaceIndexB, uParamA, vParamA, uParamB, vParamB, point) {\n        this.curveIndexA = curveIndexA;\n        this.curveIndexB = curveIndexB;\n        this.surfaceIndexA = surfaceIndexA;\n        this.surfaceIndexB = surfaceIndexB;\n        this.uParamA = uParamA;\n        this.vParamA = vParamA;\n        this.uParamB = uParamB;\n        this.vParamB = vParamB;\n        this.point = point;\n    }\n}\nclass NurbsCurve {\n    constructor(knotVector, controlPoints, degree, dimension) {\n        this.knotVector = knotVector;\n        this.controlPoints = controlPoints;\n        this.degree = degree;\n        this.dimension = dimension;\n    }\n    evaluate(t) {\n        if (t < 0 || t > 1) {\n            throw new Error('Parameter t must be between 0 and 1.');\n        }\n        const n = this.controlPoints.length - 1;\n        const p = this.degree;\n        const U = this.knotVector;\n        if (n < p) {\n            throw new Error('The number of control points must be greater than the degree.');\n        }\n        const dim = this.dimension;\n        let span = this.findSpan(n, p, t, U);\n        let basis = this.basisFuns(span, t, p, U);\n        let C = new Array(dim).fill(0);\n        for (let j = 0; j <= p; j++) {\n            let point = this.controlPoints[span - p + j];\n            let weight = point[dim];\n            // Get the weight from the last element\n            for (let k = 0; k < dim; k++) {\n                C[k] += basis[j] * point[k] * weight;\n            }\n        }\n        let weightSum = 0;\n        for (let j = 0; j <= p; j++) {\n            let point = this.controlPoints[span - p + j];\n            let weight = point[dim];\n            weightSum += basis[j] * weight;\n        }\n        for (let k = 0; k < dim; k++) {\n            C[k] = C[k] / weightSum;\n        }\n        return C;\n    }\n    evaluateRational(t) {\n        if (t < 0 || t > 1) {\n            throw new Error('Parameter t must be between 0 and 1.');\n        }\n        const n = this.controlPoints.length - 1;\n        const p = this.degree;\n        const U = this.knotVector;\n        if (n < p) {\n            throw new Error('The number of control points must be greater than the degree.');\n        }\n        const dim = this.dimension;\n        let span = this.findSpan(n, p, t, U);\n        let basis = this.basisFuns(span, t, p, U);\n        let C = new Array(dim + 1).fill(0);\n        for (let j = 0; j <= p; j++) {\n            let point = this.controlPoints[span - p + j];\n            for (let k = 0; k <= dim; k++) {\n                C[k] += basis[j] * point[k];\n            }\n        }\n        return C;\n    }\n    getControlPoints() {\n        return this.controlPoints;\n    }\n    transform(matrix) {\n        if (!matrix || matrix.length !== 4 || matrix.some(row => row.length !== 4)) {\n            throw new Error('Transformation matrix must be a 4x4 matrix.');\n        }\n        const transformPoint = (point, matrix) => {\n            const x = point[0];\n            const y = point[1];\n            const z = point[2] || 0;\n            const w = point[this.dimension] || 1;\n            const transformedX = matrix[0][0] * x + matrix[0][1] * y + matrix[0][2] * z + matrix[0][3] * w;\n            const transformedY = matrix[1][0] * x + matrix[1][1] * y + matrix[1][2] * z + matrix[1][3] * w;\n            const transformedZ = matrix[2][0] * x + matrix[2][1] * y + matrix[2][2] * z + matrix[2][3] * w;\n            const transformedW = matrix[3][0] * x + matrix[3][1] * y + matrix[3][2] * z + matrix[3][3] * w;\n            if (this.dimension === 2) {\n                return [\n                    transformedX,\n                    transformedY,\n                    transformedW\n                ];\n            } else {\n                return [\n                    transformedX,\n                    transformedY,\n                    transformedZ,\n                    transformedW\n                ];\n            }\n        };\n        this.controlPoints = this.controlPoints.map(point => transformPoint(point, matrix));\n    }\n    homogenize() {\n        if (this.controlPoints && this.controlPoints[0].length === this.dimension) {\n            this.controlPoints = this.controlPoints.map(point => {\n                const homogeneousPoint = [\n                    ...point,\n                    1\n                ];\n                return homogeneousPoint;\n            });\n        }\n    }\n    dehomogenize() {\n        if (this.controlPoints && this.controlPoints[0].length === this.dimension + 1) {\n            this.controlPoints = this.controlPoints.map(point => {\n                const weight = point[this.dimension];\n                const cartesianPoint = point.slice(0, this.dimension).map(coord => coord / weight);\n                return cartesianPoint;\n            });\n        }\n    }\n    derivative(t, order) {\n        if (t < 0 || t > 1) {\n            throw new Error('Parameter t must be between 0 and 1.');\n        }\n        if (order < 1) {\n            throw new Error('Derivative order must be greater than 0.');\n        }\n        if (order > this.degree) {\n            throw new Error('Derivative order cannot be greater than the degree of the curve.');\n        }\n        const n = this.controlPoints.length - 1;\n        const p = this.degree;\n        const U = this.knotVector;\n        if (n < p) {\n            throw new Error('The number of control points must be greater than the degree.');\n        }\n        const dim = this.dimension;\n        let ders = this.curveDerivatives(t, order);\n        let derivative = new Array(dim).fill(0);\n        for (let k = 0; k < dim; k++) {\n            derivative[k] = ders[order][k];\n        }\n        return derivative;\n    }\n    parameterize() {\n        const U = this.knotVector;\n        const p = this.degree;\n        const n = this.controlPoints.length - 1;\n        let tMin = p;\n        while (tMin < U.length && U[tMin] === U[p]) {\n            tMin++;\n        }\n        tMin = tMin - 1;\n        const t0 = U[p];\n        const t1 = U[n + 1];\n        return {\n            t0: t0,\n            t1: t1,\n            tMin: tMin\n        };\n    }\n    continuity(order) {\n        const p = this.degree;\n        const U = this.knotVector;\n        const n = this.controlPoints.length - 1;\n        if (order > p) {\n            return 0;\n        }\n        let minContinuity = p;\n        for (let i = p + 1; i < n + 1; i++) {\n            let mult = 1;\n            while (i < U.length && U[i] === U[i - 1]) {\n                mult++;\n                i++;\n            }\n            minContinuity = Math.min(minContinuity, p - mult + 1);\n        }\n        return Math.min(minContinuity, order);\n    }\n    visualize() {\n        const numberOfPoints = 50;\n        const curvePoints = [];\n        for (let i = 0; i <= numberOfPoints; i++) {\n            const t = i / numberOfPoints;\n            curvePoints.push(this.evaluate(t));\n        }\n        return {\n            controlPoints: this.controlPoints.map(cp => cp.slice(0, this.dimension)),\n            curvePoints: curvePoints,\n            dimension: this.dimension\n        };\n    }\n    split(t) {\n        if (t < 0 || t > 1) {\n            throw new Error('Parameter t must be between 0 and 1.');\n        }\n        const n = this.controlPoints.length - 1;\n        const p = this.degree;\n        const U = this.knotVector;\n        const dim = this.dimension;\n        let span = this.findSpan(n, p, t, U);\n        const tParam = U[0] + (U[U.length - 1] - U[0]) * t;\n        let k = span + 1;\n        if (tParam === U[span]) {\n            k = span;\n        }\n        let newKnots = [...U];\n        for (let i = 0; i < p + 1; i++) {\n            newKnots.splice(k, 0, tParam);\n        }\n        let newControlPoints = [...this.controlPoints];\n        for (let r = 1; r <= p; r++) {\n            let alpha = new Array(n + p + 1).fill(0);\n            for (let i = 0; i < p - r + 1; i++) {\n                alpha[span - p + r + i] = (tParam - U[span + i]) / (U[span + 1 + i] - U[span + i]);\n            }\n            for (let i = span - p + r; i < n + 1; i++) {\n                let newPoint = [];\n                for (let j = 0; j <= dim; j++) {\n                    newPoint.push((1 - alpha[i]) * newControlPoints[i - 1][j] + alpha[i] * newControlPoints[i][j]);\n                }\n                newControlPoints[i] = newPoint;\n            }\n            newControlPoints.splice(span + 1, 0, newControlPoints[span].slice());\n        }\n        const curve1ControlPoints = newControlPoints.slice(0, span + 1);\n        const curve2ControlPoints = newControlPoints.slice(span + 1);\n        const curve1KnotVector = newKnots.slice(0, k + p + 1);\n        const curve2KnotVector = newKnots.slice(k);\n        return [\n            new NurbsCurve(curve1KnotVector, curve1ControlPoints, p, dim),\n            new NurbsCurve(curve2KnotVector, curve2ControlPoints, p, dim)\n        ];\n    }\n    insertKnot(t) {\n        if (t < 0 || t > 1) {\n            throw new Error('Parameter t must be between 0 and 1.');\n        }\n        const n = this.controlPoints.length - 1;\n        const p = this.degree;\n        const U = this.knotVector;\n        const dim = this.dimension;\n        let span = this.findSpan(n, p, t, U);\n        const tParam = U[0] + (U[U.length - 1] - U[0]) * t;\n        let k = span + 1;\n        if (tParam === U[span]) {\n            k = span;\n        }\n        let newKnots = [...U];\n        newKnots.splice(k, 0, tParam);\n        let newControlPoints = [...this.controlPoints];\n        for (let r = 1; r <= p; r++) {\n            let alpha = new Array(n + p + 1).fill(0);\n            for (let i = 0; i < p - r + 1; i++) {\n                alpha[span - p + r + i] = (tParam - U[span + i]) / (U[span + 1 + i] - U[span + i]);\n            }\n            for (let i = span - p + r; i < n + r; i++) {\n                let newPoint = [];\n                for (let j = 0; j <= dim; j++) {\n                    newPoint.push((1 - alpha[i]) * newControlPoints[i - 1][j] + alpha[i] * newControlPoints[i][j]);\n                }\n                newControlPoints[i] = newPoint;\n            }\n            newControlPoints.splice(span + 1, 0, newControlPoints[span].slice());\n        }\n        this.knotVector = newKnots;\n        this.controlPoints = newControlPoints;\n    }\n    elevateDegree() {\n        const p = this.degree;\n        const n = this.controlPoints.length - 1;\n        const U = this.knotVector;\n        const dim = this.dimension;\n        const newDegree = p + 1;\n        const newControlPoints = [];\n        const newKnotVector = [];\n        // Step 1: Create a new knot vector\n        for (let i = 0; i <= n + p + 1; i++) {\n            newKnotVector[i] = U[i];\n        }\n        for (let i = 0; i < p + 1; i++) {\n            newKnotVector.push(U[n + 1]);\n        }\n        // Step 2: Calculate new control points\n        for (let i = 0; i <= n; i++) {\n            newControlPoints[i] = this.controlPoints[i];\n        }\n        for (let k = 1; k <= p; k++) {\n            for (let i = n + k; i > k - 1; i--) {\n                const alpha = (newKnotVector[i + newDegree] - newKnotVector[i]) / (newKnotVector[i + newDegree] - newKnotVector[i] + newKnotVector[i - k] - newKnotVector[i - 1 - k]);\n                let newPoint = [];\n                for (let j = 0; j <= dim; j++) {\n                    newPoint.push((1 - alpha) * newControlPoints[i - 1][j] + alpha * newControlPoints[i][j]);\n                }\n                newControlPoints[i] = newPoint;\n            }\n            let newPoint = [];\n            for (let j = 0; j <= dim; j++) {\n                newPoint.push(this.controlPoints[0][j]);\n            }\n            newControlPoints.unshift(newPoint);\n        }\n        this.degree = newDegree;\n        this.controlPoints = newControlPoints;\n        this.knotVector = newKnotVector;\n    }\n    clone() {\n        const clonedKnotVector = [...this.knotVector];\n        const clonedControlPoints = this.controlPoints.map(point => [...point]);\n        return new NurbsCurve(clonedKnotVector, clonedControlPoints, this.degree, this.dimension);\n    }\n    findSpan(n, p, u, U) {\n        if (u >= U[n + 1]) {\n            return n;\n        }\n        let low = p;\n        let high = n + 1;\n        let mid = Math.floor((low + high) / 2);\n        while (u < U[mid] || u >= U[mid + 1]) {\n            if (u < U[mid]) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n            mid = Math.floor((low + high) / 2);\n        }\n        return mid;\n    }\n    basisFuns(i, u, p, U) {\n        let N = new Array(p + 1).fill(0);\n        let left = new Array(p + 1).fill(0);\n        let right = new Array(p + 1).fill(0);\n        N[0] = 1;\n        for (let j = 1; j <= p; j++) {\n            left[j] = u - U[i + 1 - j];\n            right[j] = U[i + j] - u;\n            let saved = 0;\n            for (let r = 0; r < j; r++) {\n                let temp = N[r] / (right[r + 1] + left[j - r]);\n                N[r] = saved + right[r + 1] * temp;\n                saved = left[j - r] * temp;\n            }\n            N[j] = saved;\n        }\n        return N;\n    }\n    curveDerivatives(u, n) {\n        const p = this.degree;\n        const U = this.knotVector;\n        const dim = this.dimension;\n        const controlPoints = this.controlPoints;\n        let du = Math.min(n, p);\n        let CK = [];\n        for (let k = 0; k <= n; k++) {\n            CK.push(new Array(dim).fill(0));\n        }\n        let span = this.findSpan(controlPoints.length - 1, p, u, U);\n        let N = this.basisFuns(span, u, p, U);\n        let V = [];\n        for (let i = 0; i <= p; i++) {\n            V.push(controlPoints[span - p + i]);\n        }\n        for (let k = 0; k <= p; k++) {\n            let point = V[k];\n            let weight = point[dim];\n            for (let j = 0; j < dim; j++) {\n                CK[0][j] += N[k] * point[j] * weight;\n            }\n        }\n        let weightSum = 0;\n        for (let k = 0; k <= p; k++) {\n            let weight = V[k][dim];\n            weightSum += N[k] * weight;\n        }\n        for (let j = 0; j < dim; j++) {\n            CK[0][j] = CK[0][j] / weightSum;\n        }\n        for (let k = 1; k <= du; k++) {\n            let nders = new Array(p + 1).fill(0);\n            for (let j = 0; j <= p; j++) {\n                nders[j] = N[j];\n            }\n            for (let j = 0; j <= p; j++) {\n                let point = V[j];\n                let weight = point[dim];\n                for (let l = 0; l < dim; l++) {\n                    CK[k][l] += this.basisFunsDerivative(span, u, p, U, k, ders)[j][l] * weight;\n                }\n            }\n            let weightSum = 0;\n            for (let j = 0; j <= p; j++) {\n                let weight = V[j][dim];\n                weightSum += this.basisFunsDerivative(span, u, p, U, k, ders)[j][dim];\n            }\n            for (let l = 0; l < dim; l++) {\n                CK[k][l] = CK[k][l] / weightSum;\n            }\n        }\n        return CK;\n    }\n    basisFunsDerivative(i, u, p, U, n, ders) {\n        let dersArray = [];\n        let nders = new Array(p + 1).fill(0);\n        let left = new Array(p + 1).fill(0);\n        let right = new Array(p + 1).fill(0);\n        if (n === 0) {\n            for (let j = 0; j <= p; j++) {\n                let point = new Array(this.dimension + 1).fill(0);\n                point[this.dimension] = this.basisFuns(i, u, p, U)[j];\n                dersArray.push(point);\n            }\n            return dersArray;\n        }\n        for (let j = 0; j <= p; j++) {\n            let point = new Array(this.dimension + 1).fill(0);\n            dersArray.push(point);\n        }\n        for (let j = 0; j <= p; j++) {\n            nders[j] = 0;\n        }\n        nders[0] = 1;\n        for (let j = 1; j <= p; j++) {\n            left[j] = u - U[i + 1 - j];\n            right[j] = U[i + j] - u;\n            let saved = 0;\n            for (let r = 0; r < j; r++) {\n                let temp = nders[r] / (right[r + 1] + left[j - r]);\n                nders[r] = saved + right[r + 1] * temp;\n                saved = left[j - r] * temp;\n            }\n            nders[j] = saved;\n        }\n        for (let k = 0; k <= p; k++) {\n            let point = dersArray[k];\n            point[this.dimension] = nders[k];\n            dersArray[k] = point;\n        }\n        for (let k = 1; k <= n; k++) {\n            let temp = new Array(p + 1).fill(0);\n            for (let j = 0; j <= p; j++) {\n                temp[j] = 0;\n            }\n            for (let j = 0; j <= p; j++) {\n                let d = 0;\n                if (j > 0) {\n                    d = temp[j - 1] / (U[i + j] - U[i + 1 - p + j - 1]);\n                }\n                if (j < p) {\n                    d = d - temp[j] / (U[i + j + 1] - U[i + 1 - p + j]);\n                }\n                nders[j] = d * p;\n            }\n            for (let z = 0; z <= p; z++) {\n                let point = dersArray[z];\n                point[this.dimension] = nders[z];\n                dersArray[z] = point;\n            }\n            for (let z = 0; z <= p; z++) {\n                temp[z] = dersArray[z][this.dimension];\n            }\n        }\n        return dersArray;\n    }\n}\nfunction curveCurveIntersection(curveA, curveB) {\n    const intersections = [];\n     const curveAParameterization = curveA.parameterize();\n     const curveBParameterization = curveB.parameterize();\n    const initialStep = 0.1;\n    const tolerance = 1e-5;\n    const maxIterations = 100;\n    for (let tA = curveAParameterization.t0; tA <= curveAParameterization.t1; tA += initialStep) {\n        for (let tB = curveBParameterization.t0; tB <= curveBParameterization.t1; tB += initialStep) {\n            let currentT_A = tA;\n            let currentT_B = tB;\n            let converged = false;\n            for (let i = 0; i < maxIterations; i++) {\n                const pointA = curveA.evaluate(currentT_A);\n                const pointB = curveB.evaluate(currentT_B);\n                const diff = pointA.map((coord, index) => coord - pointB[index]);\n                const distance = Math.sqrt(diff.reduce((sum, val) => sum + val * val, 0));\n                if (distance < tolerance) {\n                    intersections.push(new Intersection(0, 1, null, null, currentT_A, null, currentT_B, null, pointA));\n                    converged = true;\n                    break;\n                }\n                const derivA = curveA.derivative(currentT_A, 1);\n                const derivB = curveB.derivative(currentT_B, 1);\n               \n                const dA = [derivA[0], derivA[1], derivA[2] || 0];\n                const dB = [derivB[0], derivB[1], derivB[2] || 0];\n                const jacobianMatrix = [\n                  [dA[0], -dB[0]],\n                  [dA[1], -dB[1]],\n                  [dA[2], -dB[2]]\n                ];\n                \n                const jtj = [\n                    [0,0],\n                    [0,0]\n                ]\n                 const jt_delta = [\n                    [0],\n                    [0]\n                ]\n                for(let row = 0; row < jacobianMatrix.length; row++){\n                    for(let col = 0; col < jacobianMatrix[0].length; col++){\n                       for(let k = 0; k < jacobianMatrix[0].length; k++){\n                           jtj[col][k] += jacobianMatrix[row][col] * jacobianMatrix[row][k]\n                       }\n                       jt_delta[col][0] += jacobianMatrix[row][col] * diff[row]\n                    }\n                }\n                const jtj_det = (jtj[0][0] * jtj[1][1]) - (jtj[0][1] * jtj[1][0]);\n                if (Math.abs(jtj_det) < tolerance) {\n                    break;\n                }\n                const jtj_inverse = [\n                    [jtj[1][1] / jtj_det, -jtj[0][1] / jtj_det],\n                    [-jtj[1][0] / jtj_det, jtj[0][0] / jtj_det],\n                ]\n                 const deltaT_A = (jtj_inverse[0][0] * jt_delta[0][0]) + (jtj_inverse[0][1] * jt_delta[1][0]);\n                 const deltaT_B = (jtj_inverse[1][0] * jt_delta[0][0]) + (jtj_inverse[1][1] * jt_delta[1][0]);\n                currentT_A -= deltaT_A;\n                currentT_B -= deltaT_B;\n                  currentT_A = Math.min(1, Math.max(0, currentT_A));\n                    currentT_B = Math.min(1, Math.max(0, currentT_B));\n            }\n        }\n    }\n    return intersections;\n}\n```"
    }
  ],
  "title": "Implement curveCurveIntersection",
  "id": "20250101_090853772Z",
  "targetFile": "./NURBS.js",
  "chatMode": "chat",
  "lastModified": "2025-01-01T09:09:39.678Z"
}