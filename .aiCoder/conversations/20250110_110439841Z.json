{
  "messages": [
    {
      "role": "system",
      "content": "./.aiCoder/prompts/default-system-prompt.md",
      "filePath": "./.aiCoder/prompts/default-system-prompt.md",
      "description": "",
      "hidden": true
    },
    {
      "role": "user",
      "content": "./.aiCoder/prompts/default-plan-prompt.md",
      "filePath": "./.aiCoder/prompts/default-plan-prompt.md",
      "description": "",
      "hidden": true
    },
    {
      "role": "user",
      "content": "./brep.js",
      "filePath": "./brep.js",
      "description": "// Code file to be edited",
      "hidden": true
    },
    {
      "role": "system",
      "content": "./.aiCoder/prompts/snippet-production-prompt.md",
      "filePath": "./.aiCoder/prompts/snippet-production-prompt.md",
      "description": "",
      "hidden": true
    },
    {
      "role": "user",
      "content": "Are there any place holders or unimplemented portions of the classes?\nList each method as an individual numbered item in the list like this:\n##ACTION LIST\n1. className.methodName\n2. className.methodName",
      "hidden": false
    },
    {
      "role": "assistant",
      "content": "## ACTION LIST\n1.  Edge.tangentAt\n2.  Face.faceFaceIntersection\n3.  Surface.getBoundingBox\n4.  NurbsCurve.dersBasisFunc",
      "hidden": false
    },
    {
      "role": "user",
      "content": "Perform action 1.  Edge.tangentAt",
      "hidden": false
    },
    {
      "role": "assistant",
      "content": "```javascript\nexport class Edge {\n    constructor(startVertex, endVertex, NurbsCurve) {\n        if (!startVertex || !endVertex) {\n            throw new Error('Edge must have a start and end vertex');\n        }\n        this.startVertex = startVertex;\n        this.endVertex = endVertex;\n        this.curve = NurbsCurve;\n    }\n    length() {\n        if (!this.curve) {\n            return this.startVertex.distanceTo(this.endVertex);\n        }\n        return this.curve.getLength();\n    }\n    pointAt(t) {\n        if (!this.curve) {\n            const start = this.startVertex;\n            const end = this.endVertex;\n            const x = start.x + (end.x - start.x) * t;\n            const y = start.y + (end.y - start.y) * t;\n            const z = start.z + (end.z - start.z) * t;\n            return {\n                x,\n                y,\n                z\n            };\n        }\n        return this.curve.evaluate(t);\n    }\n    tangentAt(t) {\n         if (!this.curve) {\n            const start = this.startVertex;\n            const end = this.endVertex;\n            const dx = end.x - start.x;\n            const dy = end.y - start.y;\n            const dz = end.z - start.z;\n            const length = Math.sqrt(dx * dx + dy * dy + dz * dz);\n             if (length < 1e-8) {\n                return {\n                    x: 0,\n                    y: 0,\n                    z: 0\n                };\n            }\n            return {\n                x: dx / length,\n                y: dy / length,\n                z: dz / length\n            };\n        }\n        return this.curve.getTanget(t);\n    }\n    reverse() {\n        const temp = this.startVertex;\n        this.startVertex = this.endVertex;\n        this.endVertex = temp;\n        if (this.curve) {\n            this.curve.reverse();\n        }\n    }\n}\n```",
      "hidden": false
    },
    {
      "role": "user",
      "content": "Perform action 2.  Face.faceFaceIntersection",
      "hidden": false
    },
    {
      "role": "assistant",
      "content": "```javascript\nexport class Face {\n    constructor(edges, surface) {\n        if (!edges || !Array.isArray(edges) || edges.length === 0) {\n            throw new Error('Face must have at least one edge.');\n        }\n        if (!surface) {\n            throw new Error('Face must have a surface.');\n        }\n        this.edges = edges;\n        this.surface = surface;\n        this.holes = [];\n    }\n    normalAt(point) {\n        if (!this.surface) {\n            return null;\n        }\n        const projectedPoint = this.surface.projectPoint(point);\n        if (!projectedPoint) {\n            return null;\n        }\n        return this.surface.normalAt(projectedPoint.u, projectedPoint.v);\n    }\n    area() {\n        if (!this.surface) {\n            return 0;\n        }\n        let totalArea = this.surface.getSurfaceArea();\n        if (this.holes && this.holes.length > 0) {\n            for (const hole of this.holes) {\n                totalArea -= hole.area();\n            }\n        }\n        return totalArea;\n    }\n    containsPoint(point) {\n        if (!this.surface) {\n            return false;\n        }\n        const projectedPoint = this.surface.projectPoint(point);\n        if (!projectedPoint) {\n            return false;\n        }\n        const u = projectedPoint.u;\n        const v = projectedPoint.v;\n        let windingNumber = 0;\n        for (const edge of this.edges) {\n            let startPoint = edge.pointAt(0);\n            let endPoint = edge.pointAt(1);\n            const startProjected = this.surface.projectPoint(startPoint);\n            const endProjected = this.surface.projectPoint(endPoint);\n            if (!startProjected || !endProjected) {\n                continue;\n            }\n            const startU = startProjected.u;\n            const startV = startProjected.v;\n            const endU = endProjected.u;\n            const endV = endProjected.v;\n            //Check if edge is colinear with ray and handle that case\n            if (Math.abs(endV - startV) < 1e-8) {\n                if (Math.min(startU, endU) <= u && u <= Math.max(startU, endU) && Math.abs(startV - v) < 1e-8) {\n                    return true;\n                }\n                // Point is on the edge.\n                continue;\n            }\n            if (startV <= v) {\n                if (endV > v) {\n                    const vt = (v - startV) / (endV - startV);\n                    if (vt >= 0 && vt <= 1) {\n                        //check for valid parameter\n                        const ut = startU + (endU - startU) * vt;\n                        if (ut > u) {\n                            windingNumber++;\n                        }\n                    }\n                }\n            } else {\n                if (endV <= v) {\n                    const vt = (v - startV) / (endV - startV);\n                    if (vt >= 0 && vt <= 1) {\n                        //check for valid parameter\n                        const ut = startU + (endU - startU) * vt;\n                        if (ut < u) {\n                            windingNumber--;\n                        }\n                    }\n                }\n            }\n        }\n        if (this.holes && this.holes.length > 0) {\n            for (const hole of this.holes) {\n                let holeWindingNumber = 0;\n                for (const edge of hole.edges) {\n                    let startPoint = edge.pointAt(0);\n                    let endPoint = edge.pointAt(1);\n                    const startProjected = this.surface.projectPoint(startPoint);\n                    const endProjected = this.surface.projectPoint(endPoint);\n                    if (!startProjected || !endProjected) {\n                        continue;\n                    }\n                    const startU = startProjected.u;\n                    const startV = startProjected.v;\n                    const endU = endProjected.u;\n                    const endV = endProjected.v;\n                    if (Math.abs(endV - startV) < 1e-8) {\n                        if (Math.min(startU, endU) <= u && u <= Math.max(startU, endU) && Math.abs(startV - v) < 1e-8) {\n                            return false;\n                        }\n                        // Point is on a hole edge.\n                        continue;\n                    }\n                    if (startV <= v) {\n                        if (endV > v) {\n                            const vt = (v - startV) / (endV - startV);\n                            if (vt >= 0 && vt <= 1) {\n                                //check for valid parameter\n                                const ut = startU + (endU - startU) * vt;\n                                if (ut > u) {\n                                    holeWindingNumber++;\n                                }\n                            }\n                        }\n                    } else {\n                        if (endV <= v) {\n                            const vt = (v - startV) / (endV - startV);\n                            if (vt >= 0 && vt <= 1) {\n                                //check for valid parameter\n                                const ut = startU + (endU - startU) * vt;\n                                if (ut < u) {\n                                    holeWindingNumber--;\n                                }\n                            }\n                        }\n                    }\n                }\n                if (holeWindingNumber !== 0) {\n                    return false;\n                }\n            }\n        }\n        return windingNumber !== 0;\n    }\n   intersectEdge(edge) {\n        if (!edge) {\n            return [];\n        }\n        const surface = this.surface;\n        if (!surface) {\n            return [];\n        }\n        let intersections = [];\n        if (surface.type === 'plane') {\n            const planeOrigin = surface.parameters.origin;\n            const planeNormal = surface.parameters.normal;\n            if (!planeOrigin || !planeNormal) {\n                return [];\n            }\n            const edgeStart = edge.pointAt(0);\n            const edgeEnd = edge.pointAt(1);\n            if (!edgeStart || !edgeEnd) {\n                return [];\n            }\n            const edgeVector = {\n                x: edgeEnd.x - edgeStart.x,\n                y: edgeEnd.y - edgeStart.y,\n                z: edgeEnd.z - edgeStart.z\n            };\n            const startToOrigin = {\n                x: planeOrigin.x - edgeStart.x,\n                y: planeOrigin.y - edgeStart.y,\n                z: planeOrigin.z - edgeStart.z\n            };\n            const denominator = planeNormal.x * edgeVector.x + planeNormal.y * edgeVector.y + planeNormal.z * edgeVector.z;\n            if (Math.abs(denominator) < 1e-8) {\n                return [];\n            }\n            const t = (planeNormal.x * startToOrigin.x + planeNormal.y * startToOrigin.y + planeNormal.z * startToOrigin.z) / denominator;\n            if (t >= 0 && t <= 1) {\n                const intersectionPoint = edge.pointAt(t);\n                if (this.containsPoint(intersectionPoint)) {\n                    intersections.push(intersectionPoint);\n                }\n            }\n            return intersections;\n        } else if (surface.type === 'sphere' || surface.type === 'cylinder' || surface.type === 'cone') {\n            const numSamples = 100;\n            for (let i = 0; i < numSamples; i++) {\n                const t0 = i / numSamples;\n                const t1 = (i + 1) / numSamples;\n                const p0 = edge.pointAt(t0);\n                const p1 = edge.pointAt(t1);\n                if (!p0 || !p1) {\n                    continue;\n                }\n                const p0Projected = surface.projectPoint(p0);\n                const p1Projected = surface.projectPoint(p1);\n                if (!p0Projected || !p1Projected) {\n                    continue;\n                }\n                const p0Surface = surface.pointAt(p0Projected.u, p0Projected.v);\n                const p1Surface = surface.pointAt(p1Projected.u, p1Projected.v);\n                const tolerance = 1e-8;\n                const dist0 = Math.sqrt(Math.pow(p0.x - p0Surface.x, 2) + Math.pow(p0.y - p0Surface.y, 2) + Math.pow(p0.z - p0Surface.z, 2));\n                const dist1 = Math.sqrt(Math.pow(p1.x - p1Surface.x, 2) + Math.pow(p1.y - p1Surface.y, 2) + Math.pow(p1.z - p1Surface.z, 2));\n                if (dist0 < tolerance && dist1 < tolerance) {\n                    let mid = (t0 + t1) / 2;\n                    const pMid = edge.pointAt(mid);\n                    if (this.containsPoint(pMid)) {\n                        intersections.push(pMid);\n                    }\n                } else if (dist0 < tolerance || dist1 < tolerance || dist0 * dist1 < 0) {\n                    let low = t0;\n                    let high = t1;\n                    for (let j = 0; j < 20; j++) {\n                        const mid = (low + high) / 2;\n                        const pMid = edge.pointAt(mid);\n                         const pMidProjected = surface.projectPoint(pMid);\n                        if (!pMidProjected) {\n                            continue;\n                        }\n                        const pMidSurface = surface.pointAt(pMidProjected.u, pMidProjected.v);\n                        const distMid = Math.sqrt(Math.pow(pMid.x - pMidSurface.x, 2) + Math.pow(pMid.y - pMidSurface.y, 2) + Math.pow(pMid.z - pMidSurface.z, 2));\n                         if (distMid < tolerance) {\n                            if (this.containsPoint(pMid)) {\n                                intersections.push(pMid);\n                            }\n                            break;\n                        } else if (dist0 * distMid < 0) {\n                            high = mid;\n                        } else {\n                            low = mid;\n                        }\n                    }\n                }\n            }\n            return intersections;\n        } else if (surface.type === 'nurbs') {\n            const nurbsSurface = surface.parameters.nurbsSurface;\n            if (!nurbsSurface) {\n                return [];\n            }\n             const numSamples = 100;\n            for (let i = 0; i < numSamples; i++) {\n                const t0 = i / numSamples;\n                const t1 = (i + 1) / numSamples;\n                const p0 = edge.pointAt(t0);\n                const p1 = edge.pointAt(t1);\n                if (!p0 || !p1) {\n                    continue;\n                }\n                const p0Projected = surface.projectPoint(p0);\n                const p1Projected = surface.projectPoint(p1);\n                if (!p0Projected || !p1Projected) {\n                    continue;\n                }\n                const p0Surface = surface.pointAt(p0Projected.u, p0Projected.v);\n                const p1Surface = surface.pointAt(p1Projected.u, p1Projected.v);\n                 const tolerance = 1e-8;\n                const dist0 = Math.sqrt(Math.pow(p0.x - p0Surface.x, 2) + Math.pow(p0.y - p0Surface.y, 2) + Math.pow(p0.z - p0Surface.z, 2));\n                const dist1 = Math.sqrt(Math.pow(p1.x - p1Surface.x, 2) + Math.pow(p1.y - p1Surface.y, 2) + Math.pow(p1.z - p1Surface.z, 2));\n                if (dist0 < tolerance && dist1 < tolerance) {\n                    let mid = (t0 + t1) / 2;\n                    const pMid = edge.pointAt(mid);\n                    if (this.containsPoint(pMid)) {\n                       intersections.push(pMid);\n                    }\n                } else if (dist0 < tolerance || dist1 < tolerance || dist0 * dist1 < 0) {\n                    let low = t0;\n                    let high = t1;\n                    for (let j = 0; j < 20; j++) {\n                         const mid = (low + high) / 2;\n                        const pMid = edge.pointAt(mid);\n                        const pMidProjected = surface.projectPoint(pMid);\n                        if (!pMidProjected) {\n                            continue;\n                        }\n                        const pMidSurface = surface.pointAt(pMidProjected.u, pMidProjected.v);\n                        const distMid = Math.sqrt(Math.pow(pMid.x - pMidSurface.x, 2) + Math.pow(pMid.y - pMidSurface.y, 2) + Math.pow(pMid.z - pMidSurface.z, 2));\n                        if (distMid < tolerance) {\n                            if (this.containsPoint(pMid)) {\n                                intersections.push(pMid);\n                            }\n                            break;\n                        } else if (dist0 * distMid < 0) {\n                            high = mid;\n                        } else {\n                            low = mid;\n                        }\n                    }\n                }\n            }\n            return intersections;\n        }\n        return intersections;\n    }\n    addHole(loop) {\n        if (!loop || !(loop instanceof Loop)) {\n            throw new Error('Invalid loop provided');\n        }\n        this.holes.push(loop);\n    }\n    removeHole(loop) {\n        if (!loop) {\n            return;\n        }\n        this.holes = this.holes.filter(h => h !== loop);\n    }\n     faceFaceIntersection(faceB) {\n        if (!faceB) {\n            return [];\n        }\n        const surfaceA = this.surface;\n        const surfaceB = faceB.surface;\n         if (!surfaceA || !surfaceB) {\n            return [];\n        }\n         if (surfaceA.type != 'nurbs' || surfaceB.type != 'nurbs') {\n            return [];\n        }\n        const nurbsSurfaceA = surfaceA.parameters.nurbsSurface;\n        const nurbsSurfaceB = surfaceB.parameters.nurbsSurface;\n        if (!nurbsSurfaceA || !nurbsSurfaceB) {\n            return [];\n        }\n        const intersection = new NurbsIntersection();\n        return intersection.surfaceSurfaceIntersection(nurbsSurfaceA, nurbsSurfaceB, 1e-8);\n    }\n}\n```",
      "hidden": false
    },
    {
      "role": "user",
      "content": "Perform action 3.  Surface.getBoundingBox",
      "hidden": false
    },
    {
      "role": "assistant",
      "content": "```javascript\nexport class Surface {\n    constructor(type, parameters) {\n        if (!type || typeof type !== 'string') {\n            throw new Error('Surface type must be a non-empty string.');\n        }\n        this.type = type;\n        this.parameters = parameters || {};\n    }\n    pointAt(u, v) {\n        if (this.type === 'plane') {\n            const origin = this.parameters.origin || {\n                x: 0,\n                y: 0,\n                z: 0\n            };\n            const normal = this.parameters.normal || {\n                x: 0,\n                y: 0,\n                z: 1\n            };\n            const uDir = this.parameters.uDir || {\n                x: 1,\n                y: 0,\n                z: 0\n            };\n            const vDir = this.parameters.vDir || {\n                x: 0,\n                y: 1,\n                z: 0\n            };\n            const point = {\n                x: origin.x + u * uDir.x + v * vDir.x,\n                y: origin.y + u * uDir.y + v * vDir.y,\n                z: origin.z + u * uDir.z + v * vDir.z\n            };\n            return point;\n        } else if (this.type === 'sphere') {\n            const center = this.parameters.center || {\n                x: 0,\n                y: 0,\n                z: 0\n            };\n            const radius = this.parameters.radius || 1;\n            const x = center.x + radius * Math.cos(v) * Math.cos(u);\n            const y = center.y + radius * Math.cos(v) * Math.sin(u);\n            const z = center.z + radius * Math.sin(v);\n            return {\n                x,\n                y,\n                z\n            };\n        } else if (this.type === 'cylinder') {\n            const origin = this.parameters.origin || {\n                x: 0,\n                y: 0,\n                z: 0\n            };\n            const axis = this.parameters.axis || {\n                x: 0,\n                y: 0,\n                z: 1\n            };\n            const radius = this.parameters.radius || 1;\n            const x = origin.x + radius * Math.cos(u) + v * axis.x;\n            const y = origin.y + radius * Math.sin(u) + v * axis.y;\n            const z = origin.z + v * axis.z;\n            return {\n                x,\n                y,\n                z\n            };\n        } else if (this.type === 'cone') {\n             const origin = this.parameters.origin || {\n                x: 0,\n                y: 0,\n                z: 0\n            };\n            const apex = this.parameters.apex || {\n                x: 0,\n                y: 0,\n                z: 1\n            };\n            const angle = this.parameters.angle || Math.PI / 4;\n            const height = Math.sqrt(Math.pow(apex.x - origin.x, 2) + Math.pow(apex.y - origin.y, 2) + Math.pow(apex.z - origin.z, 2));\n            const direction = {\n                x: apex.x - origin.x,\n                y: apex.y - origin.y,\n                z: apex.z - origin.z\n            };\n            const magnitude = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);\n            const axis = {\n                x: direction.x / magnitude,\n                y: direction.y / magnitude,\n                z: direction.z / magnitude\n            };\n            const r = v * Math.tan(angle);\n            const x = origin.x + r * Math.cos(u) + v * axis.x;\n            const y = origin.y + r * Math.sin(u) + v * axis.y;\n            const z = origin.z + v * axis.z;\n             return {\n                x,\n                y,\n                z\n            };\n        } else if (this.type === 'nurbs') {\n            if (!this.parameters.nurbsSurface) {\n                return null;\n            }\n            return this.parameters.nurbsSurface.evaluate(u, v);\n        }\n        return null;\n    }\n    normalAt(u, v) {\n         if (this.type === 'plane') {\n            const normal = this.parameters.normal || {\n                x: 0,\n                y: 0,\n                z: 1\n            };\n            return {\n                x: normal.x,\n                y: normal.y,\n                z: normal.z\n            };\n        } else if (this.type === 'sphere') {\n            const center = this.parameters.center || {\n                x: 0,\n                y: 0,\n                z: 0\n            };\n            const radius = this.parameters.radius || 1;\n             const point = this.pointAt(u, v);\n             if(!point){\n                 return null;\n             }\n             const normal = {\n                x: point.x - center.x,\n                y: point.y - center.y,\n                z: point.z - center.z\n            };\n            const magnitude = Math.sqrt(normal.x * normal.x + normal.y * normal.y + normal.z * normal.z);\n            return {\n                x: normal.x / magnitude,\n                y: normal.y / magnitude,\n                z: normal.z / magnitude\n            };\n        } else if (this.type === 'cylinder') {\n             const origin = this.parameters.origin || {\n                x: 0,\n                y: 0,\n                z: 0\n            };\n            const axis = this.parameters.axis || {\n                x: 0,\n                y: 0,\n                z: 1\n            };\n            const point = this.pointAt(u,v);\n            if(!point){\n                return null;\n            }\n            const relativePoint = {\n                x: point.x - origin.x,\n                y: point.y - origin.y,\n                z: point.z - origin.z\n            };\n              const normal = {\n                x: relativePoint.x - (relativePoint.x * axis.x + relativePoint.y * axis.y + relativePoint.z * axis.z) * axis.x,\n                y: relativePoint.y - (relativePoint.x * axis.x + relativePoint.y * axis.y + relativePoint.z * axis.z) * axis.y,\n                z: relativePoint.z - (relativePoint.x * axis.x + relativePoint.y * axis.y + relativePoint.z * axis.z) * axis.z\n            };\n            const magnitude = Math.sqrt(normal.x * normal.x + normal.y * normal.y + normal.z * normal.z);\n             return {\n                x: normal.x / magnitude,\n                y: normal.y / magnitude,\n                z: normal.z / magnitude\n            };\n        } else if (this.type === 'cone') {\n             const origin = this.parameters.origin || {\n                x: 0,\n                y: 0,\n                z: 0\n            };\n            const apex = this.parameters.apex || {\n                x: 0,\n                y: 0,\n                z: 1\n            };\n            const angle = this.parameters.angle || Math.PI / 4;\n            const height = Math.sqrt(Math.pow(apex.x - origin.x, 2) + Math.pow(apex.y - origin.y, 2) + Math.pow(apex.z - origin.z, 2));\n             const direction = {\n                x: apex.x - origin.x,\n                y: apex.y - origin.y,\n                z: apex.z - origin.z\n            };\n            const magnitude = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);\n            const axis = {\n                x: direction.x / magnitude,\n                y: direction.y / magnitude,\n                z: direction.z / magnitude\n            };\n            const r = Math.tan(angle);\n            const point = this.pointAt(u,v);\n            if(!point){\n                return null;\n            }\n             const relativePoint = {\n                x: point.x - origin.x,\n                y: point.y - origin.y,\n                z: point.z - origin.z\n            };\n             const normal = {\n                x: relativePoint.x * Math.cos(angle) * Math.cos(u) + axis.x * Math.sin(angle),\n                y: relativePoint.y * Math.cos(angle) * Math.sin(u) + axis.y * Math.sin(angle),\n                z: relativePoint.z * Math.cos(angle) + axis.z * Math.sin(angle)\n            };\n           const normalMagnitude = Math.sqrt(normal.x * normal.x + normal.y * normal.y + normal.z * normal.z);\n            return {\n                x: normal.x / normalMagnitude,\n                y: normal.y / normalMagnitude,\n                z: normal.z / normalMagnitude\n            };\n        } else if (this.type === 'nurbs') {\n            if (!this.parameters.nurbsSurface) {\n                return null;\n            }\n            return this.parameters.nurbsSurface.normal(u, v);\n        }\n        return null;\n    }\n    projectPoint(point) {\n        if (!point) {\n            return null;\n        }\n        if (this.type === 'plane') {\n             const origin = this.parameters.origin || {\n                x: 0,\n                y: 0,\n                z: 0\n            };\n            const normal = this.parameters.normal || {\n                x: 0,\n                y: 0,\n                z: 1\n            };\n            const uDir = this.parameters.uDir || {\n                x: 1,\n                y: 0,\n                z: 0\n            };\n            const vDir = this.parameters.vDir || {\n                x: 0,\n                y: 1,\n                z: 0\n            };\n            const v = {\n                x: point.x - origin.x,\n                y: point.y - origin.y,\n                z: point.z - origin.z\n            };\n            const u = v.x * uDir.x + v.y * uDir.y + v.z * uDir.z;\n            const vParam = v.x * vDir.x + v.y * vDir.y + v.z * vDir.z;\n            return {\n                u: u,\n                v: vParam\n            };\n        } else if (this.type === 'sphere') {\n            const center = this.parameters.center || {\n                x: 0,\n                y: 0,\n                z: 0\n            };\n            const radius = this.parameters.radius || 1;\n            const v = {\n                x: point.x - center.x,\n                y: point.y - center.y,\n                z: point.z - center.z\n            };\n            const magnitude = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);\n            if(magnitude < 1e-8){\n                return { u: 0, v: 0 };\n            }\n            const normalized = {\n                x: v.x / magnitude,\n                y: v.y / magnitude,\n                z: v.z / magnitude\n            };\n            const u = Math.atan2(normalized.y, normalized.x);\n            const vParam = Math.asin(normalized.z);\n             return {\n                u: u,\n                v: vParam\n            };\n        } else if (this.type === 'cylinder') {\n             const origin = this.parameters.origin || {\n                x: 0,\n                y: 0,\n                z: 0\n            };\n            const axis = this.parameters.axis || {\n                x: 0,\n                y: 0,\n                z: 1\n            };\n            const radius = this.parameters.radius || 1;\n            const v = {\n                x: point.x - origin.x,\n                y: point.y - origin.y,\n                z: point.z - origin.z\n            };\n            const proj = v.x * axis.x + v.y * axis.y + v.z * axis.z;\n             const projVector = {\n                x: proj * axis.x,\n                y: proj * axis.y,\n                z: proj * axis.z\n            };\n            const radialVector = {\n                x: v.x - projVector.x,\n                y: v.y - projVector.y,\n                z: v.z - projVector.z\n            };\n           const radialMag = Math.sqrt(radialVector.x * radialVector.x + radialVector.y * radialVector.y + radialVector.z * radialVector.z);\n            if(radialMag < 1e-8){\n                 return { u: 0, v: 0 };\n            }\n            const u = Math.atan2(radialVector.y, radialVector.x);\n            const vParam = proj;\n             return {\n                u: u,\n                v: vParam\n            };\n        } else if (this.type === 'cone') {\n             const origin = this.parameters.origin || {\n                x: 0,\n                y: 0,\n                z: 0\n            };\n            const apex = this.parameters.apex || {\n                x: 0,\n                y: 0,\n                z: 1\n            };\n            const angle = this.parameters.angle || Math.PI / 4;\n            const v = {\n                x: point.x - origin.x,\n                y: point.y - origin.y,\n                z: point.z - origin.z\n            };\n            const direction = {\n                x: apex.x - origin.x,\n                y: apex.y - origin.y,\n                z: apex.z - origin.z\n            };\n           const magnitude = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);\n            const axis = {\n                x: direction.x / magnitude,\n                y: direction.y / magnitude,\n                z: direction.z / magnitude\n            };\n            const proj = v.x * axis.x + v.y * axis.y + v.z * axis.z;\n           const projVector = {\n                x: proj * axis.x,\n                y: proj * axis.y,\n                z: proj * axis.z\n            };\n            const radialVector = {\n                x: v.x - projVector.x,\n                y: v.y - projVector.y,\n                z: v.z - projVector.z\n            };\n            const radialMag = Math.sqrt(radialVector.x * radialVector.x + radialVector.y * radialVector.y + radialVector.z * radialVector.z);\n            if(radialMag < 1e-8){\n                return { u: 0, v: 0 };\n            }\n             const u = Math.atan2(radialVector.y, radialVector.x);\n            const vParam = proj;\n            return {\n                u: u,\n                v: vParam\n            };\n        } else if (this.type === 'nurbs') {\n            if (!this.parameters.nurbsSurface) {\n                return null;\n            }\n             const nurbsSurface = this.parameters.nurbsSurface;\n            let initialU = 0.5;\n            let initialV = 0.5;\n            let iterations = 0;\n            const maxIterations = 100;\n            const tolerance = 1e-8;\n            let currentPoint = nurbsSurface.evaluate(initialU, initialV);\n           while (iterations < maxIterations) {\n                const surfacePoint = nurbsSurface.evaluate(initialU, initialV);\n                 if(!surfacePoint){\n                     return null;\n                 }\n                const diff = {\n                    x: point.x - surfacePoint[0],\n                    y: point.y - surfacePoint[1],\n                    z: point.z - surfacePoint[2]\n                };\n               const diffMag = Math.sqrt(diff.x * diff.x + diff.y * diff.y + diff.z * diff.z);\n                if (diffMag < tolerance) {\n                     return {\n                        u: initialU,\n                        v: initialV\n                    };\n                }\n                 const du = nurbsSurface.uDerivative(initialU, initialV, 1);\n                 const dv = nurbsSurface.vDerivative(initialU, initialV, 1);\n                 if(!du || !dv){\n                     return null\n                 }\n                const J = [\n                    [\n                        du[0],\n                        dv[0]\n                    ],\n                    [\n                        du[1],\n                        dv[1]\n                    ],\n                    [\n                        du[2],\n                        dv[2]\n                    ]\n                ];\n                const JT = [\n                    [\n                        J[0][0],\n                        J[1][0],\n                        J[2][0]\n                    ],\n                    [\n                        J[0][1],\n                        J[1][1],\n                        J[2][1]\n                    ]\n                ];\n                const JTJ = [\n                    [\n                        JT[0][0] * J[0][0] + JT[0][1] * J[1][0] + JT[0][2] * J[2][0],\n                        JT[0][0] * J[0][1] + JT[0][1] * J[1][1] + JT[0][2] * J[2][1]\n                    ],\n                    [\n                        JT[1][0] * J[0][0] + JT[1][1] * J[1][0] + JT[1][2] * J[2][0],\n                        JT[1][0] * J[0][1] + JT[1][1] * J[1][1] + JT[1][2] * J[2][1]\n                    ]\n                ];\n                 const JTdiff = [\n                    JT[0][0] * diff.x + JT[0][1] * diff.y + JT[0][2] * diff.z,\n                    JT[1][0] * diff.x + JT[1][1] * diff.y + JT[1][2] * diff.z\n                ];\n               const det = JTJ[0][0] * JTJ[1][1] - JTJ[0][1] * JTJ[1][0];\n                 if (Math.abs(det) < 1e-10) {\n                    return {\n                        u: initialU,\n                        v: initialV\n                    };\n                }\n                const invJTJ = [\n                    [\n                        JTJ[1][1] / det,\n                        -JTJ[0][1] / det\n                    ],\n                    [\n                        -JTJ[1][0] / det,\n                        JTJ[0][0] / det\n                    ]\n                ];\n                 const deltaU = invJTJ[0][0] * JTdiff[0] + invJTJ[0][1] * JTdiff[1];\n                 const deltaV = invJTJ[1][0] * JTdiff[0] + invJTJ[1][1] * JTdiff[1];\n                initialU -= deltaU;\n                initialV -= deltaV;\n                iterations++;\n                if(initialU < 0){\n                    initialU = 0;\n                }\n                if(initialU > 1){\n                     initialU = 1;\n                }\n                if(initialV < 0){\n                     initialV = 0;\n                }\n                if(initialV > 1){\n                     initialV = 1;\n                }\n            }\n              return {\n                u: initialU,\n                v: initialV\n            };\n        }\n        return null;\n    }\n    getBoundingBox() {\n         if (this.type === 'plane') {\n            return null;\n        }\n        else if (this.type === 'sphere') {\n             const center = this.parameters.center || {\n                x: 0,\n                y: 0,\n                z: 0\n            };\n            const radius = this.parameters.radius || 1;\n            return {\n                min: {\n                    x: center.x - radius,\n                    y: center.y - radius,\n                    z: center.z - radius\n                },\n                max: {\n                    x: center.x + radius,\n                    y: center.y + radius,\n                    z: center.z + radius\n                }\n            };\n        } else if (this.type === 'cylinder') {\n             const origin = this.parameters.origin || {\n                x: 0,\n                y: 0,\n                z: 0\n            };\n            const axis = this.parameters.axis || {\n                x: 0,\n                y: 0,\n                z: 1\n            };\n           const radius = this.parameters.radius || 1;\n           const height = 2;\n            const absAxisX = Math.abs(axis.x);\n            const absAxisY = Math.abs(axis.y);\n            const absAxisZ = Math.abs(axis.z);\n           const bounds = {\n                min: {\n                    x: 0,\n                    y: 0,\n                    z: 0\n                },\n                max: {\n                    x: 0,\n                    y: 0,\n                    z: 0\n                }\n            };\n            bounds.min.x = origin.x - radius;\n            bounds.min.y = origin.y - radius;\n             bounds.min.z = origin.z - height * absAxisZ;\n             bounds.max.x = origin.x + radius;\n            bounds.max.y = origin.y + radius;\n            bounds.max.z = origin.z + height * absAxisZ;\n             return bounds\n        } else if (this.type === 'cone') {\n           const origin = this.parameters.origin || {\n                x: 0,\n                y: 0,\n                z: 0\n            };\n            const apex = this.parameters.apex || {\n                x: 0,\n                y: 0,\n                z: 1\n            };\n            const angle = this.parameters.angle || Math.PI / 4;\n            const height = Math.sqrt(Math.pow(apex.x - origin.x, 2) + Math.pow(apex.y - origin.y, 2) + Math.pow(apex.z - origin.z, 2));\n            const radius = height * Math.tan(angle);\n            const bounds = {\n                min: {\n                    x: 0,\n                    y: 0,\n                    z: 0\n                },\n                max: {\n                    x: 0,\n                    y: 0,\n                    z: 0\n                }\n            };\n             bounds.min.x = Math.min(origin.x,apex.x) - radius;\n            bounds.min.y = Math.min(origin.y,apex.y) - radius;\n            bounds.min.z = Math.min(origin.z, apex.z) ;\n            bounds.max.x = Math.max(origin.x,apex.x) + radius;\n            bounds.max.y = Math.max(origin.y,apex.y) + radius;\n             bounds.max.z = Math.max(origin.z, apex.z);\n            return bounds;\n        } else if (this.type === 'nurbs') {\n             if (!this.parameters.nurbsSurface) {\n                return null;\n            }\n            return this.parameters.nurbsSurface.getBoundingBox();\n        }\n        return null;\n    }\n}\n```",
      "hidden": false
    }
  ],
  "title": "3D Geometry Library Code Review",
  "id": "20250110_110439841Z",
  "targetFile": "./brep.js",
  "chatMode": "chat",
  "conversationNew": false,
  "lastModified": "2025-01-10T11:06:37.275Z"
}